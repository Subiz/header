// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO3

package logan

/** @param totalAlloc
  *   TotalAlloc is cumulative bytes allocated for heap objects.
  *  
  *   TotalAlloc increases as heap objects are allocated, but
  *   unlike Alloc and HeapAlloc, it does not decrease when
  *   objects are freed.
  * @param sys
  *   Sys is the total bytes of memory obtained from the OS.
  *  
  *   Sys is the sum of the XSys fields below. Sys measures the
  *   virtual address space reserved by the Go runtime for the
  *   heap, stacks, and other internal data structures. It's
  *   likely that not all of the virtual address space is backed
  *   by physical memory at any given moment, though in general
  *   it all was at some point.
  * @param lookups
  *   Lookups is the number of pointer lookups performed by the
  *   runtime.
  *  
  *   This is primarily useful for debugging runtime internals.
  * @param mallocs
  *   Mallocs is the cumulative count of heap objects allocated.
  *   The number of live objects is Mallocs - Frees.
  * @param frees
  *   Frees is the cumulative count of heap objects freed.
  * @param heapAlloc
  *   HeapAlloc is bytes of allocated heap objects.
  *  
  *   "Allocated" heap objects include all reachable objects, as
  *   well as unreachable objects that the garbage collector has
  *   not yet freed. Specifically, HeapAlloc increases as heap
  *   objects are allocated and decreases as the heap is swept
  *   and unreachable objects are freed. Sweeping occurs
  *   incrementally between GC cycles, so these two processes
  *   occur simultaneously, and as a result HeapAlloc tends to
  *   change smoothly (in contrast with the sawtooth that is
  *   typical of stop-the-world garbage collectors).
  * @param heapSys
  *   HeapSys is bytes of heap memory obtained from the OS.
  *  
  *   HeapSys measures the amount of virtual address space
  *   reserved for the heap. This includes virtual address space
  *   that has been reserved but not yet used, which consumes no
  *   physical memory, but tends to be small, as well as virtual
  *   address space for which the physical memory has been
  *   returned to the OS after it became unused (see HeapReleased
  *   for a measure of the latter).
  *  
  *   HeapSys estimates the largest size the heap has had.
  * @param heapIdle
  *   HeapIdle is bytes in idle (unused) spans.
  *  
  *   Idle spans have no objects in them. These spans could be
  *   (and may already have been) returned to the OS, or they can
  *   be reused for heap allocations, or they can be reused as
  *   stack memory.
  *  
  *   HeapIdle minus HeapReleased estimates the amount of memory
  *   that could be returned to the OS, but is being retained by
  *   the runtime so it can grow the heap without requesting more
  *   memory from the OS. If this difference is significantly
  *   larger than the heap size, it indicates there was a recent
  *   transient spike in live heap size.
  * @param heapInuse
  *   HeapInuse is bytes in in-use spans.
  *  
  *   In-use spans have at least one object in them. These spans
  *   can only be used for other objects of roughly the same
  *   size.
  *  
  *   HeapInuse minus HeapAlloc esimates the amount of memory
  *   that has been dedicated to particular size classes, but is
  *   not currently being used. This is an upper bound on
  *   fragmentation, but in general this memory can be reused
  *   efficiently.
  * @param heapReleased
  *   HeapReleased is bytes of physical memory returned to the OS.
  *  
  *   This counts heap memory from idle spans that was returned
  *   to the OS and has not yet been reacquired for the heap.
  * @param heapObjects
  *   HeapObjects is the number of allocated heap objects.
  *  
  *   Like HeapAlloc, this increases as objects are allocated and
  *   decreases as the heap is swept and unreachable objects are
  *   freed.
  * @param stackInuse
  *   StackInuse is bytes in stack spans.
  *  
  *   In-use stack spans have at least one stack in them. These
  *   spans can only be used for other stacks of the same size.
  *  
  *   There is no StackIdle because unused stack spans are
  *   returned to the heap (and hence counted toward HeapIdle).
  * @param stackSys
  *   StackSys is bytes of stack memory obtained from the OS.
  *  
  *   StackSys is StackInuse, plus any memory obtained directly
  *   from the OS for OS thread stacks (which should be minimal).
  * @param mSpanInuse
  *   MSpanInuse is bytes of allocated mspan structures.
  * @param mSpanSys
  *   MSpanSys is bytes of memory obtained from the OS for mspan
  *   structures.
  * @param mCacheInuse
  *   MCacheInuse is bytes of allocated mcache structures.
  * @param mCacheSys
  *   MCacheSys is bytes of memory obtained from the OS for
  *   mcache structures.
  * @param buckHashSys
  *   BuckHashSys is bytes of memory in profiling bucket hash tables.
  * @param gcSys
  *   GCSys is bytes of memory in garbage collection metadata.
  * @param otherSys
  *   OtherSys is bytes of memory in miscellaneous off-heap
  *   runtime allocations.
  * @param nextGc
  *   NextGC is the target heap size of the next GC cycle.
  *  
  *   The garbage collector's goal is to keep HeapAlloc â‰¤ NextGC.
  *   At the end of each GC cycle, the target for the next cycle
  *   is computed based on the amount of reachable data and the
  *   value of GOGC.
  * @param lastGc
  *   LastGC is the time the last garbage collection finished, as
  *   nanoseconds since 1970 (the UNIX epoch).
  * @param pauseTotalNs
  *   PauseTotalNs is the cumulative nanoseconds in GC
  *   stop-the-world pauses since the program started.
  *  
  *   During a stop-the-world pause, all goroutines are paused
  *   and only the garbage collector can run.
  * @param numGc
  *   NumGC is the number of completed GC cycles.
  * @param numForcedGc
  *   NumForcedGC is the number of GC cycles that were forced by
  *   the application calling the GC function.
  * @param gcCpuFraction
  *   GCCPUFraction is the fraction of this program's available
  *   CPU time used by the GC since the program started.
  *  
  *   GCCPUFraction is expressed as a number between 0 and 1,
  *   where 0 means GC has consumed none of this program's CPU. A
  *   program's available CPU time is defined as the integral of
  *   GOMAXPROCS since the program started. That is, if
  *   GOMAXPROCS is 2 and a program has been running for 10
  *   seconds, its "available CPU" is 20 seconds. GCCPUFraction
  *   does not include CPU time used for write barrier activity.
  *  
  *   This is the same as the fraction of CPU reported by
  *   GODEBUG=gctrace=1.
  */
@SerialVersionUID(0L)
final case class MemStats(
    alloc: _root_.scala.Long = 0L,
    totalAlloc: _root_.scala.Long = 0L,
    sys: _root_.scala.Long = 0L,
    lookups: _root_.scala.Long = 0L,
    mallocs: _root_.scala.Long = 0L,
    frees: _root_.scala.Long = 0L,
    heapAlloc: _root_.scala.Long = 0L,
    heapSys: _root_.scala.Long = 0L,
    heapIdle: _root_.scala.Long = 0L,
    heapInuse: _root_.scala.Long = 0L,
    heapReleased: _root_.scala.Long = 0L,
    heapObjects: _root_.scala.Long = 0L,
    stackInuse: _root_.scala.Long = 0L,
    stackSys: _root_.scala.Long = 0L,
    mSpanInuse: _root_.scala.Long = 0L,
    mSpanSys: _root_.scala.Long = 0L,
    mCacheInuse: _root_.scala.Long = 0L,
    mCacheSys: _root_.scala.Long = 0L,
    buckHashSys: _root_.scala.Long = 0L,
    gcSys: _root_.scala.Long = 0L,
    otherSys: _root_.scala.Long = 0L,
    nextGc: _root_.scala.Long = 0L,
    lastGc: _root_.scala.Long = 0L,
    pauseTotalNs: _root_.scala.Long = 0L,
    numGc: _root_.scala.Int = 0,
    numForcedGc: _root_.scala.Int = 0,
    gcCpuFraction: _root_.scala.Double = 0.0
    ) extends scalapb.GeneratedMessage with scalapb.Message[MemStats] with scalapb.lenses.Updatable[MemStats] {
    @transient
    private[this] var __serializedSizeCachedValue: _root_.scala.Int = 0
    private[this] def __computeSerializedValue(): _root_.scala.Int = {
      var __size = 0
      if (alloc != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(2, alloc) }
      if (totalAlloc != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(3, totalAlloc) }
      if (sys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(4, sys) }
      if (lookups != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(5, lookups) }
      if (mallocs != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(6, mallocs) }
      if (frees != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(7, frees) }
      if (heapAlloc != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(8, heapAlloc) }
      if (heapSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(9, heapSys) }
      if (heapIdle != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(10, heapIdle) }
      if (heapInuse != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(11, heapInuse) }
      if (heapReleased != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(12, heapReleased) }
      if (heapObjects != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(13, heapObjects) }
      if (stackInuse != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(14, stackInuse) }
      if (stackSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(15, stackSys) }
      if (mSpanInuse != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(16, mSpanInuse) }
      if (mSpanSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(17, mSpanSys) }
      if (mCacheInuse != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(18, mCacheInuse) }
      if (mCacheSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(19, mCacheSys) }
      if (buckHashSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(20, buckHashSys) }
      if (gcSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(21, gcSys) }
      if (otherSys != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(22, otherSys) }
      if (nextGc != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(23, nextGc) }
      if (lastGc != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(24, lastGc) }
      if (pauseTotalNs != 0L) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt64Size(25, pauseTotalNs) }
      if (numGc != 0) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt32Size(26, numGc) }
      if (numForcedGc != 0) { __size += _root_.com.google.protobuf.CodedOutputStream.computeUInt32Size(27, numForcedGc) }
      if (gcCpuFraction != 0.0) { __size += _root_.com.google.protobuf.CodedOutputStream.computeDoubleSize(28, gcCpuFraction) }
      __size
    }
    final override def serializedSize: _root_.scala.Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): _root_.scala.Unit = {
      {
        val __v = alloc
        if (__v != 0L) {
          _output__.writeUInt64(2, __v)
        }
      };
      {
        val __v = totalAlloc
        if (__v != 0L) {
          _output__.writeUInt64(3, __v)
        }
      };
      {
        val __v = sys
        if (__v != 0L) {
          _output__.writeUInt64(4, __v)
        }
      };
      {
        val __v = lookups
        if (__v != 0L) {
          _output__.writeUInt64(5, __v)
        }
      };
      {
        val __v = mallocs
        if (__v != 0L) {
          _output__.writeUInt64(6, __v)
        }
      };
      {
        val __v = frees
        if (__v != 0L) {
          _output__.writeUInt64(7, __v)
        }
      };
      {
        val __v = heapAlloc
        if (__v != 0L) {
          _output__.writeUInt64(8, __v)
        }
      };
      {
        val __v = heapSys
        if (__v != 0L) {
          _output__.writeUInt64(9, __v)
        }
      };
      {
        val __v = heapIdle
        if (__v != 0L) {
          _output__.writeUInt64(10, __v)
        }
      };
      {
        val __v = heapInuse
        if (__v != 0L) {
          _output__.writeUInt64(11, __v)
        }
      };
      {
        val __v = heapReleased
        if (__v != 0L) {
          _output__.writeUInt64(12, __v)
        }
      };
      {
        val __v = heapObjects
        if (__v != 0L) {
          _output__.writeUInt64(13, __v)
        }
      };
      {
        val __v = stackInuse
        if (__v != 0L) {
          _output__.writeUInt64(14, __v)
        }
      };
      {
        val __v = stackSys
        if (__v != 0L) {
          _output__.writeUInt64(15, __v)
        }
      };
      {
        val __v = mSpanInuse
        if (__v != 0L) {
          _output__.writeUInt64(16, __v)
        }
      };
      {
        val __v = mSpanSys
        if (__v != 0L) {
          _output__.writeUInt64(17, __v)
        }
      };
      {
        val __v = mCacheInuse
        if (__v != 0L) {
          _output__.writeUInt64(18, __v)
        }
      };
      {
        val __v = mCacheSys
        if (__v != 0L) {
          _output__.writeUInt64(19, __v)
        }
      };
      {
        val __v = buckHashSys
        if (__v != 0L) {
          _output__.writeUInt64(20, __v)
        }
      };
      {
        val __v = gcSys
        if (__v != 0L) {
          _output__.writeUInt64(21, __v)
        }
      };
      {
        val __v = otherSys
        if (__v != 0L) {
          _output__.writeUInt64(22, __v)
        }
      };
      {
        val __v = nextGc
        if (__v != 0L) {
          _output__.writeUInt64(23, __v)
        }
      };
      {
        val __v = lastGc
        if (__v != 0L) {
          _output__.writeUInt64(24, __v)
        }
      };
      {
        val __v = pauseTotalNs
        if (__v != 0L) {
          _output__.writeUInt64(25, __v)
        }
      };
      {
        val __v = numGc
        if (__v != 0) {
          _output__.writeUInt32(26, __v)
        }
      };
      {
        val __v = numForcedGc
        if (__v != 0) {
          _output__.writeUInt32(27, __v)
        }
      };
      {
        val __v = gcCpuFraction
        if (__v != 0.0) {
          _output__.writeDouble(28, __v)
        }
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): logan.MemStats = {
      var __alloc = this.alloc
      var __totalAlloc = this.totalAlloc
      var __sys = this.sys
      var __lookups = this.lookups
      var __mallocs = this.mallocs
      var __frees = this.frees
      var __heapAlloc = this.heapAlloc
      var __heapSys = this.heapSys
      var __heapIdle = this.heapIdle
      var __heapInuse = this.heapInuse
      var __heapReleased = this.heapReleased
      var __heapObjects = this.heapObjects
      var __stackInuse = this.stackInuse
      var __stackSys = this.stackSys
      var __mSpanInuse = this.mSpanInuse
      var __mSpanSys = this.mSpanSys
      var __mCacheInuse = this.mCacheInuse
      var __mCacheSys = this.mCacheSys
      var __buckHashSys = this.buckHashSys
      var __gcSys = this.gcSys
      var __otherSys = this.otherSys
      var __nextGc = this.nextGc
      var __lastGc = this.lastGc
      var __pauseTotalNs = this.pauseTotalNs
      var __numGc = this.numGc
      var __numForcedGc = this.numForcedGc
      var __gcCpuFraction = this.gcCpuFraction
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 16 =>
            __alloc = _input__.readUInt64()
          case 24 =>
            __totalAlloc = _input__.readUInt64()
          case 32 =>
            __sys = _input__.readUInt64()
          case 40 =>
            __lookups = _input__.readUInt64()
          case 48 =>
            __mallocs = _input__.readUInt64()
          case 56 =>
            __frees = _input__.readUInt64()
          case 64 =>
            __heapAlloc = _input__.readUInt64()
          case 72 =>
            __heapSys = _input__.readUInt64()
          case 80 =>
            __heapIdle = _input__.readUInt64()
          case 88 =>
            __heapInuse = _input__.readUInt64()
          case 96 =>
            __heapReleased = _input__.readUInt64()
          case 104 =>
            __heapObjects = _input__.readUInt64()
          case 112 =>
            __stackInuse = _input__.readUInt64()
          case 120 =>
            __stackSys = _input__.readUInt64()
          case 128 =>
            __mSpanInuse = _input__.readUInt64()
          case 136 =>
            __mSpanSys = _input__.readUInt64()
          case 144 =>
            __mCacheInuse = _input__.readUInt64()
          case 152 =>
            __mCacheSys = _input__.readUInt64()
          case 160 =>
            __buckHashSys = _input__.readUInt64()
          case 168 =>
            __gcSys = _input__.readUInt64()
          case 176 =>
            __otherSys = _input__.readUInt64()
          case 184 =>
            __nextGc = _input__.readUInt64()
          case 192 =>
            __lastGc = _input__.readUInt64()
          case 200 =>
            __pauseTotalNs = _input__.readUInt64()
          case 208 =>
            __numGc = _input__.readUInt32()
          case 216 =>
            __numForcedGc = _input__.readUInt32()
          case 225 =>
            __gcCpuFraction = _input__.readDouble()
          case tag => _input__.skipField(tag)
        }
      }
      logan.MemStats(
          alloc = __alloc,
          totalAlloc = __totalAlloc,
          sys = __sys,
          lookups = __lookups,
          mallocs = __mallocs,
          frees = __frees,
          heapAlloc = __heapAlloc,
          heapSys = __heapSys,
          heapIdle = __heapIdle,
          heapInuse = __heapInuse,
          heapReleased = __heapReleased,
          heapObjects = __heapObjects,
          stackInuse = __stackInuse,
          stackSys = __stackSys,
          mSpanInuse = __mSpanInuse,
          mSpanSys = __mSpanSys,
          mCacheInuse = __mCacheInuse,
          mCacheSys = __mCacheSys,
          buckHashSys = __buckHashSys,
          gcSys = __gcSys,
          otherSys = __otherSys,
          nextGc = __nextGc,
          lastGc = __lastGc,
          pauseTotalNs = __pauseTotalNs,
          numGc = __numGc,
          numForcedGc = __numForcedGc,
          gcCpuFraction = __gcCpuFraction
      )
    }
    def withAlloc(__v: _root_.scala.Long): MemStats = copy(alloc = __v)
    def withTotalAlloc(__v: _root_.scala.Long): MemStats = copy(totalAlloc = __v)
    def withSys(__v: _root_.scala.Long): MemStats = copy(sys = __v)
    def withLookups(__v: _root_.scala.Long): MemStats = copy(lookups = __v)
    def withMallocs(__v: _root_.scala.Long): MemStats = copy(mallocs = __v)
    def withFrees(__v: _root_.scala.Long): MemStats = copy(frees = __v)
    def withHeapAlloc(__v: _root_.scala.Long): MemStats = copy(heapAlloc = __v)
    def withHeapSys(__v: _root_.scala.Long): MemStats = copy(heapSys = __v)
    def withHeapIdle(__v: _root_.scala.Long): MemStats = copy(heapIdle = __v)
    def withHeapInuse(__v: _root_.scala.Long): MemStats = copy(heapInuse = __v)
    def withHeapReleased(__v: _root_.scala.Long): MemStats = copy(heapReleased = __v)
    def withHeapObjects(__v: _root_.scala.Long): MemStats = copy(heapObjects = __v)
    def withStackInuse(__v: _root_.scala.Long): MemStats = copy(stackInuse = __v)
    def withStackSys(__v: _root_.scala.Long): MemStats = copy(stackSys = __v)
    def withMSpanInuse(__v: _root_.scala.Long): MemStats = copy(mSpanInuse = __v)
    def withMSpanSys(__v: _root_.scala.Long): MemStats = copy(mSpanSys = __v)
    def withMCacheInuse(__v: _root_.scala.Long): MemStats = copy(mCacheInuse = __v)
    def withMCacheSys(__v: _root_.scala.Long): MemStats = copy(mCacheSys = __v)
    def withBuckHashSys(__v: _root_.scala.Long): MemStats = copy(buckHashSys = __v)
    def withGcSys(__v: _root_.scala.Long): MemStats = copy(gcSys = __v)
    def withOtherSys(__v: _root_.scala.Long): MemStats = copy(otherSys = __v)
    def withNextGc(__v: _root_.scala.Long): MemStats = copy(nextGc = __v)
    def withLastGc(__v: _root_.scala.Long): MemStats = copy(lastGc = __v)
    def withPauseTotalNs(__v: _root_.scala.Long): MemStats = copy(pauseTotalNs = __v)
    def withNumGc(__v: _root_.scala.Int): MemStats = copy(numGc = __v)
    def withNumForcedGc(__v: _root_.scala.Int): MemStats = copy(numForcedGc = __v)
    def withGcCpuFraction(__v: _root_.scala.Double): MemStats = copy(gcCpuFraction = __v)
    def getFieldByNumber(__fieldNumber: _root_.scala.Int): scala.Any = {
      (__fieldNumber: @_root_.scala.unchecked) match {
        case 2 => {
          val __t = alloc
          if (__t != 0L) __t else null
        }
        case 3 => {
          val __t = totalAlloc
          if (__t != 0L) __t else null
        }
        case 4 => {
          val __t = sys
          if (__t != 0L) __t else null
        }
        case 5 => {
          val __t = lookups
          if (__t != 0L) __t else null
        }
        case 6 => {
          val __t = mallocs
          if (__t != 0L) __t else null
        }
        case 7 => {
          val __t = frees
          if (__t != 0L) __t else null
        }
        case 8 => {
          val __t = heapAlloc
          if (__t != 0L) __t else null
        }
        case 9 => {
          val __t = heapSys
          if (__t != 0L) __t else null
        }
        case 10 => {
          val __t = heapIdle
          if (__t != 0L) __t else null
        }
        case 11 => {
          val __t = heapInuse
          if (__t != 0L) __t else null
        }
        case 12 => {
          val __t = heapReleased
          if (__t != 0L) __t else null
        }
        case 13 => {
          val __t = heapObjects
          if (__t != 0L) __t else null
        }
        case 14 => {
          val __t = stackInuse
          if (__t != 0L) __t else null
        }
        case 15 => {
          val __t = stackSys
          if (__t != 0L) __t else null
        }
        case 16 => {
          val __t = mSpanInuse
          if (__t != 0L) __t else null
        }
        case 17 => {
          val __t = mSpanSys
          if (__t != 0L) __t else null
        }
        case 18 => {
          val __t = mCacheInuse
          if (__t != 0L) __t else null
        }
        case 19 => {
          val __t = mCacheSys
          if (__t != 0L) __t else null
        }
        case 20 => {
          val __t = buckHashSys
          if (__t != 0L) __t else null
        }
        case 21 => {
          val __t = gcSys
          if (__t != 0L) __t else null
        }
        case 22 => {
          val __t = otherSys
          if (__t != 0L) __t else null
        }
        case 23 => {
          val __t = nextGc
          if (__t != 0L) __t else null
        }
        case 24 => {
          val __t = lastGc
          if (__t != 0L) __t else null
        }
        case 25 => {
          val __t = pauseTotalNs
          if (__t != 0L) __t else null
        }
        case 26 => {
          val __t = numGc
          if (__t != 0) __t else null
        }
        case 27 => {
          val __t = numForcedGc
          if (__t != 0) __t else null
        }
        case 28 => {
          val __t = gcCpuFraction
          if (__t != 0.0) __t else null
        }
      }
    }
    def getField(__field: _root_.scalapb.descriptors.FieldDescriptor): _root_.scalapb.descriptors.PValue = {
      require(__field.containingMessage eq companion.scalaDescriptor)
      (__field.number: @_root_.scala.unchecked) match {
        case 2 => _root_.scalapb.descriptors.PLong(alloc)
        case 3 => _root_.scalapb.descriptors.PLong(totalAlloc)
        case 4 => _root_.scalapb.descriptors.PLong(sys)
        case 5 => _root_.scalapb.descriptors.PLong(lookups)
        case 6 => _root_.scalapb.descriptors.PLong(mallocs)
        case 7 => _root_.scalapb.descriptors.PLong(frees)
        case 8 => _root_.scalapb.descriptors.PLong(heapAlloc)
        case 9 => _root_.scalapb.descriptors.PLong(heapSys)
        case 10 => _root_.scalapb.descriptors.PLong(heapIdle)
        case 11 => _root_.scalapb.descriptors.PLong(heapInuse)
        case 12 => _root_.scalapb.descriptors.PLong(heapReleased)
        case 13 => _root_.scalapb.descriptors.PLong(heapObjects)
        case 14 => _root_.scalapb.descriptors.PLong(stackInuse)
        case 15 => _root_.scalapb.descriptors.PLong(stackSys)
        case 16 => _root_.scalapb.descriptors.PLong(mSpanInuse)
        case 17 => _root_.scalapb.descriptors.PLong(mSpanSys)
        case 18 => _root_.scalapb.descriptors.PLong(mCacheInuse)
        case 19 => _root_.scalapb.descriptors.PLong(mCacheSys)
        case 20 => _root_.scalapb.descriptors.PLong(buckHashSys)
        case 21 => _root_.scalapb.descriptors.PLong(gcSys)
        case 22 => _root_.scalapb.descriptors.PLong(otherSys)
        case 23 => _root_.scalapb.descriptors.PLong(nextGc)
        case 24 => _root_.scalapb.descriptors.PLong(lastGc)
        case 25 => _root_.scalapb.descriptors.PLong(pauseTotalNs)
        case 26 => _root_.scalapb.descriptors.PInt(numGc)
        case 27 => _root_.scalapb.descriptors.PInt(numForcedGc)
        case 28 => _root_.scalapb.descriptors.PDouble(gcCpuFraction)
      }
    }
    def toProtoString: _root_.scala.Predef.String = _root_.scalapb.TextFormat.printToUnicodeString(this)
    def companion = logan.MemStats
}

object MemStats extends scalapb.GeneratedMessageCompanion[logan.MemStats] {
  implicit def messageCompanion: scalapb.GeneratedMessageCompanion[logan.MemStats] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): logan.MemStats = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    logan.MemStats(
      __fieldsMap.getOrElse(__fields.get(0), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(1), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(2), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(3), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(4), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(5), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(6), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(7), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(8), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(9), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(10), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(11), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(12), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(13), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(14), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(15), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(16), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(17), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(18), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(19), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(20), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(21), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(22), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(23), 0L).asInstanceOf[_root_.scala.Long],
      __fieldsMap.getOrElse(__fields.get(24), 0).asInstanceOf[_root_.scala.Int],
      __fieldsMap.getOrElse(__fields.get(25), 0).asInstanceOf[_root_.scala.Int],
      __fieldsMap.getOrElse(__fields.get(26), 0.0).asInstanceOf[_root_.scala.Double]
    )
  }
  implicit def messageReads: _root_.scalapb.descriptors.Reads[logan.MemStats] = _root_.scalapb.descriptors.Reads{
    case _root_.scalapb.descriptors.PMessage(__fieldsMap) =>
      require(__fieldsMap.keys.forall(_.containingMessage == scalaDescriptor), "FieldDescriptor does not match message type.")
      logan.MemStats(
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(2).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(3).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(4).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(5).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(6).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(7).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(8).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(9).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(10).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(11).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(12).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(13).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(14).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(15).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(16).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(17).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(18).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(19).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(20).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(21).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(22).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(23).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(24).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(25).get).map(_.as[_root_.scala.Long]).getOrElse(0L),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(26).get).map(_.as[_root_.scala.Int]).getOrElse(0),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(27).get).map(_.as[_root_.scala.Int]).getOrElse(0),
        __fieldsMap.get(scalaDescriptor.findFieldByNumber(28).get).map(_.as[_root_.scala.Double]).getOrElse(0.0)
      )
    case _ => throw new RuntimeException("Expected PMessage")
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = LoganProto.javaDescriptor.getMessageTypes.get(3)
  def scalaDescriptor: _root_.scalapb.descriptors.Descriptor = LoganProto.scalaDescriptor.messages(3)
  def messageCompanionForFieldNumber(__number: _root_.scala.Int): _root_.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__number)
  lazy val nestedMessagesCompanions: Seq[_root_.scalapb.GeneratedMessageCompanion[_]] = Seq.empty
  def enumCompanionForFieldNumber(__fieldNumber: _root_.scala.Int): _root_.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__fieldNumber)
  lazy val defaultInstance = logan.MemStats(
  )
  implicit class MemStatsLens[UpperPB](_l: _root_.scalapb.lenses.Lens[UpperPB, logan.MemStats]) extends _root_.scalapb.lenses.ObjectLens[UpperPB, logan.MemStats](_l) {
    def alloc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.alloc)((c_, f_) => c_.copy(alloc = f_))
    def totalAlloc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.totalAlloc)((c_, f_) => c_.copy(totalAlloc = f_))
    def sys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.sys)((c_, f_) => c_.copy(sys = f_))
    def lookups: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.lookups)((c_, f_) => c_.copy(lookups = f_))
    def mallocs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.mallocs)((c_, f_) => c_.copy(mallocs = f_))
    def frees: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.frees)((c_, f_) => c_.copy(frees = f_))
    def heapAlloc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapAlloc)((c_, f_) => c_.copy(heapAlloc = f_))
    def heapSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapSys)((c_, f_) => c_.copy(heapSys = f_))
    def heapIdle: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapIdle)((c_, f_) => c_.copy(heapIdle = f_))
    def heapInuse: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapInuse)((c_, f_) => c_.copy(heapInuse = f_))
    def heapReleased: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapReleased)((c_, f_) => c_.copy(heapReleased = f_))
    def heapObjects: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.heapObjects)((c_, f_) => c_.copy(heapObjects = f_))
    def stackInuse: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.stackInuse)((c_, f_) => c_.copy(stackInuse = f_))
    def stackSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.stackSys)((c_, f_) => c_.copy(stackSys = f_))
    def mSpanInuse: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.mSpanInuse)((c_, f_) => c_.copy(mSpanInuse = f_))
    def mSpanSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.mSpanSys)((c_, f_) => c_.copy(mSpanSys = f_))
    def mCacheInuse: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.mCacheInuse)((c_, f_) => c_.copy(mCacheInuse = f_))
    def mCacheSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.mCacheSys)((c_, f_) => c_.copy(mCacheSys = f_))
    def buckHashSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.buckHashSys)((c_, f_) => c_.copy(buckHashSys = f_))
    def gcSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.gcSys)((c_, f_) => c_.copy(gcSys = f_))
    def otherSys: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.otherSys)((c_, f_) => c_.copy(otherSys = f_))
    def nextGc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.nextGc)((c_, f_) => c_.copy(nextGc = f_))
    def lastGc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.lastGc)((c_, f_) => c_.copy(lastGc = f_))
    def pauseTotalNs: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Long] = field(_.pauseTotalNs)((c_, f_) => c_.copy(pauseTotalNs = f_))
    def numGc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.numGc)((c_, f_) => c_.copy(numGc = f_))
    def numForcedGc: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Int] = field(_.numForcedGc)((c_, f_) => c_.copy(numForcedGc = f_))
    def gcCpuFraction: _root_.scalapb.lenses.Lens[UpperPB, _root_.scala.Double] = field(_.gcCpuFraction)((c_, f_) => c_.copy(gcCpuFraction = f_))
  }
  final val ALLOC_FIELD_NUMBER = 2
  final val TOTAL_ALLOC_FIELD_NUMBER = 3
  final val SYS_FIELD_NUMBER = 4
  final val LOOKUPS_FIELD_NUMBER = 5
  final val MALLOCS_FIELD_NUMBER = 6
  final val FREES_FIELD_NUMBER = 7
  final val HEAP_ALLOC_FIELD_NUMBER = 8
  final val HEAP_SYS_FIELD_NUMBER = 9
  final val HEAP_IDLE_FIELD_NUMBER = 10
  final val HEAP_INUSE_FIELD_NUMBER = 11
  final val HEAP_RELEASED_FIELD_NUMBER = 12
  final val HEAP_OBJECTS_FIELD_NUMBER = 13
  final val STACK_INUSE_FIELD_NUMBER = 14
  final val STACK_SYS_FIELD_NUMBER = 15
  final val M_SPAN_INUSE_FIELD_NUMBER = 16
  final val M_SPAN_SYS_FIELD_NUMBER = 17
  final val M_CACHE_INUSE_FIELD_NUMBER = 18
  final val M_CACHE_SYS_FIELD_NUMBER = 19
  final val BUCK_HASH_SYS_FIELD_NUMBER = 20
  final val GC_SYS_FIELD_NUMBER = 21
  final val OTHER_SYS_FIELD_NUMBER = 22
  final val NEXT_GC_FIELD_NUMBER = 23
  final val LAST_GC_FIELD_NUMBER = 24
  final val PAUSE_TOTAL_NS_FIELD_NUMBER = 25
  final val NUM_GC_FIELD_NUMBER = 26
  final val NUM_FORCED_GC_FIELD_NUMBER = 27
  final val GC_CPU_FRACTION_FIELD_NUMBER = 28
}

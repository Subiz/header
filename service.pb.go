// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package header

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	account "github.com/subiz/header/account"
	api "github.com/subiz/header/api"
	avatar "github.com/subiz/header/avatar"
	client "github.com/subiz/header/client"
	common "github.com/subiz/header/common"
	content "github.com/subiz/header/content"
	conversation "github.com/subiz/header/conversation"
	deal "github.com/subiz/header/deal"
	event "github.com/subiz/header/event"
	file "github.com/subiz/header/file"
	kafpc "github.com/subiz/header/kafpc"
	kv "github.com/subiz/header/kv"
	noti5 "github.com/subiz/header/noti5"
	notibox "github.com/subiz/header/notibox"
	payment "github.com/subiz/header/payment"
	placeholder "github.com/subiz/header/placeholder"
	pubsub "github.com/subiz/header/pubsub"
	user "github.com/subiz/header/user"
	widget "github.com/subiz/header/widget"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 3769 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5b, 0x3d, 0x70, 0x1b, 0xc7,
	0x15, 0x0e, 0x29, 0x99, 0x14, 0x1e, 0x40, 0x12, 0x58, 0x50, 0xa2, 0x08, 0xc9, 0xd6, 0xaf, 0x25,
	0xeb, 0x87, 0xa0, 0x7c, 0x92, 0x2c, 0xc9, 0xb2, 0x2c, 0x81, 0x14, 0x45, 0x31, 0xa2, 0x64, 0x98,
	0x00, 0xe5, 0xa4, 0xc8, 0x78, 0x0e, 0xc0, 0x12, 0xbc, 0xf0, 0x70, 0x87, 0xdc, 0x1e, 0x20, 0xc1,
	0x55, 0x26, 0x33, 0x99, 0x24, 0x93, 0xc9, 0x24, 0x55, 0x66, 0x52, 0xa4, 0x77, 0x93, 0x26, 0x5d,
	0x3a, 0xf7, 0x69, 0x92, 0x49, 0x95, 0x26, 0x55, 0xba, 0x74, 0xa9, 0x3c, 0xa9, 0x32, 0xfb, 0x77,
	0x77, 0xbb, 0xf7, 0x03, 0x50, 0x76, 0xd2, 0x70, 0xb8, 0xef, 0x7d, 0xef, 0xed, 0xdb, 0xb7, 0x6f,
	0x77, 0xdf, 0xbe, 0x5b, 0xc0, 0x1c, 0xc1, 0xde, 0xd0, 0x6a, 0xe3, 0x6a, 0xdf, 0x73, 0x7d, 0x17,
	0xcd, 0xec, 0x63, 0xb3, 0x83, 0xbd, 0x4a, 0xa1, 0xed, 0xf6, 0x7a, 0xae, 0xc3, 0xa9, 0x95, 0xfc,
	0x80, 0x60, 0xef, 0xa6, 0x68, 0x00, 0x6d, 0x88, 0xff, 0x51, 0xdb, 0x75, 0x86, 0xd8, 0x23, 0xa6,
	0x6f, 0x05, 0xe0, 0x42, 0xdb, 0xb6, 0xb0, 0xe3, 0x8b, 0xd6, 0x5c, 0xdb, 0x75, 0xfc, 0xb0, 0x09,
	0x1d, 0x6c, 0xda, 0x52, 0x2b, 0x1e, 0x46, 0x18, 0x7b, 0x96, 0x8d, 0x25, 0xe3, 0xc0, 0xdc, 0xeb,
	0xb7, 0x45, 0xe3, 0xd8, 0xc1, 0x50, 0x2a, 0xee, 0x0f, 0x5a, 0x64, 0xd0, 0x12, 0xad, 0x52, 0xdf,
	0x36, 0xdb, 0x78, 0xdf, 0xb5, 0x3b, 0x81, 0x35, 0x73, 0x7d, 0x73, 0xd4, 0x8b, 0x74, 0xed, 0xb8,
	0xbe, 0xd5, 0x72, 0x5f, 0x4b, 0xad, 0xb4, 0x79, 0x5b, 0xea, 0x7a, 0x65, 0x75, 0xba, 0x38, 0x40,
	0x9a, 0xed, 0xb6, 0x3b, 0x08, 0x04, 0x0b, 0xe6, 0xd0, 0xf4, 0x4d, 0xa9, 0x35, 0x67, 0xf6, 0x2d,
	0xfe, 0xaf, 0x71, 0x03, 0x72, 0xb5, 0xbe, 0xd5, 0xc0, 0xde, 0x10, 0x7b, 0xe8, 0x02, 0x1c, 0x5d,
	0x37, 0x6d, 0x1b, 0x15, 0xaa, 0x14, 0xb0, 0x83, 0x7f, 0x34, 0xc0, 0xc4, 0xaf, 0xcc, 0x89, 0x16,
	0xe9, 0xbb, 0x0e, 0xc1, 0xc6, 0x06, 0xe4, 0x6a, 0xed, 0x76, 0x63, 0xd0, 0x7a, 0xde, 0xf5, 0xd0,
	0x5d, 0xc8, 0x35, 0xb0, 0xe9, 0xb5, 0xf7, 0x1b, 0x83, 0x16, 0x5a, 0xae, 0xca, 0x4e, 0x03, 0x9a,
	0xd4, 0x51, 0x0c, 0x58, 0x5c, 0x96, 0x18, 0x7f, 0xc9, 0x03, 0xd4, 0x38, 0x8d, 0x2a, 0xba, 0x03,
	0xf9, 0x75, 0x0f, 0x9b, 0x3e, 0xde, 0xf4, 0xdc, 0x41, 0x1f, 0x95, 0x43, 0x7c, 0x17, 0x3b, 0x3e,
	0x23, 0x56, 0x92, 0x88, 0x54, 0x70, 0xb7, 0xdf, 0x79, 0x03, 0xc1, 0x6b, 0x70, 0x6c, 0x13, 0x8b,
	0xff, 0xa1, 0x2a, 0x82, 0x63, 0xab, 0x93, 0x0c, 0x7e, 0x0c, 0x8b, 0x62, 0x28, 0x3b, 0x98, 0x60,
	0xbf, 0x6e, 0x12, 0xf2, 0xca, 0xf5, 0x3a, 0xe8, 0xed, 0x00, 0xac, 0xd0, 0x43, 0xd7, 0x09, 0xbd,
	0x1b, 0xbd, 0xbe, 0x3f, 0x42, 0x1f, 0xc0, 0x3c, 0xb7, 0x35, 0x90, 0x5f, 0x0c, 0xe4, 0x5f, 0xe0,
	0x57, 0x92, 0x5a, 0x99, 0x57, 0x4d, 0x40, 0x2b, 0x72, 0x8c, 0xbc, 0xa9, 0xb1, 0x63, 0xf0, 0x2b,
	0x90, 0x7f, 0x8c, 0x6d, 0x2c, 0xe1, 0xd1, 0xc1, 0xe9, 0xd0, 0x9b, 0x80, 0x84, 0xad, 0xeb, 0xfb,
	0xa6, 0xd3, 0xc5, 0x1b, 0x3d, 0xd3, 0xb2, 0x63, 0x1d, 0x68, 0xc3, 0xb8, 0x05, 0x68, 0xdd, 0x75,
	0xf6, 0x2c, 0xaf, 0x97, 0x2c, 0xd4, 0x74, 0x0f, 0xb0, 0x13, 0xeb, 0xea, 0x2e, 0x14, 0x6b, 0xed,
	0x36, 0xee, 0xfb, 0x5b, 0xce, 0xd0, 0xf2, 0xd9, 0xf2, 0x9a, 0x70, 0xf8, 0xab, 0x30, 0xb7, 0x89,
	0xa3, 0x62, 0xe3, 0xba, 0x5a, 0x81, 0x3c, 0x43, 0x4f, 0xe8, 0xaf, 0x4b, 0x2c, 0x12, 0xc6, 0x3b,
	0xcb, 0x80, 0x79, 0x31, 0x6e, 0x11, 0xb8, 0x31, 0x43, 0x94, 0x30, 0x67, 0x88, 0xab, 0x00, 0x54,
	0xb7, 0x68, 0x45, 0xb5, 0xc7, 0xb1, 0x37, 0x61, 0x4e, 0x4c, 0xb3, 0x20, 0xc4, 0x20, 0x09, 0x42,
	0x8f, 0x60, 0x8e, 0x2f, 0x1c, 0x49, 0x08, 0x43, 0x52, 0xa1, 0x27, 0xae, 0x44, 0x26, 0x70, 0x05,
	0x60, 0xdb, 0x22, 0x7c, 0xfc, 0x44, 0x31, 0x71, 0x41, 0x75, 0x00, 0x41, 0xab, 0x00, 0xeb, 0xfb,
	0xb8, 0x7d, 0xb0, 0xed, 0x76, 0x2d, 0x07, 0x1d, 0x0f, 0xd8, 0xac, 0x2d, 0x7b, 0x88, 0x68, 0x40,
	0x55, 0x78, 0x2b, 0x13, 0xab, 0xbb, 0xf8, 0x3d, 0x19, 0xba, 0xf1, 0x75, 0xa9, 0x05, 0x61, 0x95,
	0x5b, 0xcd, 0x70, 0xaa, 0xd5, 0x8b, 0x09, 0x0b, 0x98, 0xa0, 0x0f, 0x60, 0xa1, 0xd6, 0xe9, 0x30,
	0x4a, 0xd3, 0xe5, 0xda, 0x43, 0x20, 0x6b, 0x3f, 0xc7, 0xbd, 0x16, 0xf6, 0xf4, 0x7e, 0xee, 0xd3,
	0x95, 0xdf, 0x73, 0x87, 0x3c, 0x96, 0x9e, 0x78, 0x6e, 0xef, 0x10, 0xc2, 0x2b, 0x90, 0xcf, 0x5a,
	0x57, 0xfa, 0xe8, 0xef, 0x43, 0xe9, 0xd3, 0x01, 0xf6, 0x46, 0x6b, 0xa3, 0x4f, 0x5a, 0x3f, 0xc4,
	0x6d, 0xbf, 0x6e, 0xfa, 0xfb, 0x68, 0x59, 0xaa, 0x0c, 0x69, 0xd2, 0x7b, 0xf9, 0x70, 0xd4, 0x04,
	0x55, 0xa1, 0xb0, 0xe5, 0xf8, 0xb8, 0xeb, 0x99, 0x3e, 0x5e, 0x73, 0xc7, 0x47, 0x7d, 0x1d, 0x50,
	0x63, 0xe4, 0xb4, 0xeb, 0x83, 0x96, 0x6d, 0xb5, 0x9f, 0xba, 0xb6, 0xd5, 0x31, 0x47, 0x04, 0x9d,
	0x0f, 0xf7, 0xf0, 0x18, 0x53, 0x76, 0x7b, 0x22, 0xc0, 0xac, 0x0d, 0x88, 0xe5, 0x60, 0x42, 0x9e,
	0xba, 0x03, 0x8f, 0x18, 0x5f, 0x1e, 0x85, 0xfc, 0xfa, 0xc0, 0xf3, 0xb0, 0xd3, 0x1e, 0xd1, 0x3d,
	0xfd, 0x16, 0xcc, 0xd3, 0x29, 0x12, 0x24, 0x0b, 0x13, 0xa4, 0xba, 0x27, 0xb2, 0xd5, 0x46, 0x30,
	0xd7, 0x21, 0xbf, 0x89, 0xa5, 0xd0, 0x48, 0x99, 0xd9, 0x92, 0x8e, 0x67, 0x5b, 0x2a, 0x0f, 0xf3,
	0x80, 0x12, 0x07, 0xa5, 0xc8, 0xf1, 0xb5, 0x76, 0x48, 0xb9, 0x6b, 0x30, 0xcf, 0x03, 0x34, 0xd1,
	0x40, 0x6d, 0xfa, 0xb7, 0xa0, 0x44, 0x1d, 0xb0, 0xf1, 0xba, 0xcd, 0x82, 0x60, 0xc7, 0xf4, 0x31,
	0x41, 0xa7, 0x03, 0xa5, 0x51, 0x7a, 0xdc, 0xb7, 0xaa, 0xd4, 0x13, 0x58, 0xd8, 0xc4, 0x8a, 0xa6,
	0x31, 0x8a, 0x8e, 0x27, 0x72, 0xd1, 0x1a, 0x20, 0xee, 0x2f, 0x85, 0x9a, 0x0c, 0x4e, 0xd3, 0x51,
	0x03, 0xc4, 0x7d, 0x70, 0x08, 0x73, 0x54, 0xcf, 0x18, 0x3f, 0x9e, 0x81, 0xd9, 0x5d, 0x82, 0x3d,
	0x1a, 0x26, 0x1f, 0x43, 0x9e, 0xe7, 0x0b, 0x94, 0x40, 0xd0, 0x52, 0x95, 0x65, 0x63, 0xb4, 0xc1,
	0xc9, 0xa1, 0x6b, 0x62, 0x0c, 0x32, 0xb0, 0x7d, 0xf4, 0x01, 0xa0, 0xba, 0xd5, 0x3e, 0x68, 0xba,
	0x0d, 0xdc, 0xa5, 0xb9, 0x12, 0x3f, 0x23, 0x4a, 0x1c, 0x4d, 0x39, 0x29, 0xa7, 0xf1, 0x47, 0x70,
	0x82, 0x0f, 0x83, 0x2e, 0x6a, 0x45, 0xb6, 0x2c, 0x7a, 0x72, 0xfa, 0xe9, 0xd2, 0x17, 0x01, 0xb8,
	0x23, 0xa9, 0x3d, 0x08, 0x42, 0xdb, 0x94, 0xfd, 0xef, 0x22, 0x00, 0x0f, 0xb3, 0x4c, 0xd4, 0x79,
	0x38, 0xb6, 0x83, 0xcd, 0x8e, 0xc0, 0x84, 0xe1, 0x14, 0xc1, 0xa3, 0x3d, 0x38, 0xbb, 0x4e, 0xbd,
	0x1b, 0x35, 0x94, 0x32, 0xd6, 0x46, 0x35, 0xdf, 0xf7, 0xac, 0xd6, 0xc0, 0xc7, 0x68, 0x85, 0xe3,
	0xc7, 0xe1, 0xe4, 0x88, 0xca, 0x11, 0xb8, 0x4c, 0xef, 0xd0, 0x43, 0x00, 0x46, 0x68, 0xba, 0xbe,
	0x69, 0xcb, 0xc9, 0x08, 0x29, 0x52, 0xf6, 0x64, 0x9c, 0x21, 0x14, 0x5c, 0x81, 0xa3, 0x75, 0xcb,
	0xe9, 0xa2, 0xb2, 0x1c, 0x08, 0x6d, 0x49, 0xb1, 0x42, 0x40, 0x74, 0x9d, 0x2e, 0x3d, 0x78, 0xe9,
	0x9e, 0x6c, 0x5b, 0x26, 0x41, 0x79, 0xae, 0x90, 0x35, 0x74, 0x5f, 0xaf, 0x02, 0x3c, 0xc7, 0x5e,
	0x17, 0xf3, 0x00, 0x41, 0x1c, 0xc9, 0x28, 0x29, 0x93, 0x73, 0x15, 0xe6, 0xa8, 0x43, 0x6b, 0xb6,
	0xdd, 0x74, 0xfb, 0x56, 0x9b, 0x64, 0x2d, 0xd2, 0xdb, 0x90, 0xdf, 0x78, 0xdd, 0x77, 0x3d, 0x3f,
	0x16, 0x7e, 0x9c, 0x9c, 0xd2, 0xc5, 0x43, 0x00, 0x1e, 0x85, 0x2f, 0x5c, 0x1f, 0x4b, 0xa9, 0x90,
	0xa2, 0xf9, 0x29, 0xca, 0x10, 0x79, 0xf4, 0x57, 0x53, 0x00, 0x2f, 0x2d, 0x62, 0xf9, 0x2e, 0x5b,
	0x05, 0x57, 0xa1, 0x40, 0x4d, 0xae, 0x7b, 0x98, 0x60, 0xa7, 0x8d, 0xb5, 0x44, 0x84, 0xc7, 0xb2,
	0xe4, 0x5d, 0x0f, 0xf2, 0xc8, 0x49, 0xd0, 0x57, 0x20, 0x2f, 0x34, 0x0f, 0x2d, 0xfc, 0x2a, 0x09,
	0xba, 0x6d, 0x12, 0xff, 0x25, 0xe5, 0xad, 0xc0, 0x02, 0xdd, 0xb0, 0x9a, 0x6e, 0x5f, 0x58, 0x46,
	0x92, 0xe0, 0x92, 0x67, 0xfc, 0x66, 0x0a, 0xca, 0xb5, 0x81, 0xef, 0xf6, 0x58, 0x94, 0xad, 0x7b,
	0xb8, 0x63, 0xb1, 0x64, 0xfe, 0x43, 0x28, 0xd3, 0xa4, 0x47, 0xe3, 0x28, 0xaa, 0x96, 0xaa, 0xfc,
	0xaa, 0x14, 0x03, 0x3d, 0x80, 0x32, 0x8d, 0x09, 0x9d, 0x9c, 0x86, 0xd7, 0x37, 0x96, 0x2f, 0xa7,
	0x61, 0x96, 0xba, 0x99, 0x9a, 0x71, 0x03, 0x72, 0x74, 0x34, 0xb4, 0x49, 0x90, 0xd8, 0x3d, 0x02,
	0x42, 0x78, 0x86, 0x32, 0x3a, 0x07, 0x9d, 0x83, 0xd9, 0x5a, 0xa7, 0xc3, 0x66, 0x14, 0x42, 0x7a,
	0x25, 0xf2, 0x7f, 0xb8, 0xa2, 0x33, 0x51, 0xb7, 0x00, 0xf8, 0xde, 0x12, 0x8d, 0x8e, 0x90, 0x92,
	0x12, 0x53, 0xd7, 0x60, 0x76, 0x13, 0x33, 0xf3, 0xd0, 0x22, 0x17, 0x11, 0xcd, 0x30, 0xb5, 0x0a,
	0xbb, 0xf8, 0xc6, 0x01, 0xf8, 0xdb, 0x69, 0x98, 0x0b, 0xdd, 0x49, 0x1d, 0xf6, 0x3e, 0x9f, 0xfe,
	0x90, 0xa8, 0x4e, 0x3f, 0x8a, 0xcd, 0x01, 0xa1, 0x59, 0xbd, 0xc8, 0x59, 0x03, 0x22, 0x2a, 0xc5,
	0x70, 0x95, 0x38, 0x09, 0xad, 0x40, 0x51, 0xdc, 0x52, 0x42, 0x5a, 0xc6, 0x32, 0x5d, 0x85, 0x79,
	0xb6, 0xa4, 0x93, 0xc1, 0x09, 0xfa, 0xef, 0x42, 0x51, 0x24, 0xc0, 0x87, 0xb4, 0xcc, 0xf8, 0x6a,
	0x1a, 0x0a, 0xc1, 0x66, 0x49, 0xfd, 0xb2, 0x01, 0x27, 0x99, 0x5f, 0x24, 0xed, 0x31, 0xde, 0xb3,
	0x1c, 0x8b, 0x3b, 0x40, 0x4b, 0x69, 0x2a, 0x62, 0x1b, 0x4b, 0x82, 0x7e, 0x0a, 0xcb, 0xc2, 0xa2,
	0x38, 0x17, 0x2d, 0xa7, 0x0a, 0x56, 0xd2, 0x59, 0x54, 0xa5, 0x70, 0xff, 0xb7, 0xa6, 0x72, 0x1d,
	0x96, 0xc5, 0xbc, 0x24, 0x30, 0x95, 0x48, 0xa6, 0x80, 0x94, 0xf3, 0xfd, 0xd7, 0xd3, 0xb0, 0x10,
	0x3d, 0x81, 0xf8, 0x15, 0x5f, 0xdc, 0x54, 0x04, 0x43, 0x6e, 0xe4, 0x51, 0x5c, 0x25, 0x81, 0x46,
	0x05, 0xf9, 0x20, 0x0f, 0x2b, 0xb8, 0x0a, 0x05, 0x3a, 0x6f, 0x82, 0x46, 0xb4, 0x6b, 0x7e, 0x0c,
	0x4f, 0xe8, 0xb9, 0xc1, 0x87, 0x26, 0x7b, 0xca, 0x08, 0xc8, 0x15, 0xbe, 0xad, 0x26, 0x21, 0x13,
	0x6c, 0x31, 0xfe, 0x30, 0x05, 0x47, 0xeb, 0xd8, 0xeb, 0x21, 0x03, 0x66, 0xf8, 0x68, 0xc2, 0xcc,
	0x5e, 0x6c, 0xe6, 0xd8, 0xeb, 0xa5, 0x6c, 0x0c, 0x77, 0x65, 0x01, 0xa0, 0xe1, 0x53, 0xc1, 0x8a,
	0x2a, 0xc8, 0x88, 0x29, 0x92, 0x77, 0x78, 0x6a, 0xc1, 0x7a, 0x5e, 0x92, 0x2c, 0x49, 0x91, 0x32,
	0x28, 0x38, 0x95, 0xb1, 0xd7, 0xb3, 0x08, 0xa1, 0xf6, 0x7e, 0x7d, 0x04, 0x16, 0xd7, 0x23, 0xa5,
	0xb0, 0x1d, 0x4c, 0x0f, 0x43, 0xec, 0xa1, 0xcf, 0xe1, 0x24, 0x3b, 0xf5, 0xa3, 0x4c, 0xb2, 0x36,
	0x6a, 0x9a, 0x5d, 0x82, 0xce, 0x56, 0x95, 0xea, 0x19, 0xc3, 0x71, 0x96, 0xec, 0xea, 0x5c, 0x06,
	0x42, 0x24, 0x10, 0x2d, 0x7e, 0x7a, 0x0c, 0xbb, 0x92, 0xd2, 0xb4, 0x7a, 0x98, 0xa0, 0x8b, 0xaa,
	0xa4, 0xc6, 0x97, 0xfa, 0xdf, 0x1d, 0x83, 0x12, 0x7d, 0x60, 0x58, 0xdc, 0xc4, 0x3c, 0x71, 0x89,
	0x8e, 0x63, 0xc2, 0x4e, 0x2e, 0xab, 0xa8, 0x98, 0x9a, 0xa0, 0x9b, 0x5d, 0x28, 0x73, 0xbf, 0x29,
	0xce, 0x4a, 0x74, 0x13, 0xc7, 0xc9, 0x1e, 0x4e, 0xab, 0x08, 0xc9, 0x14, 0x6a, 0x7f, 0x40, 0xef,
	0xa4, 0x94, 0x52, 0x1b, 0x9a, 0x96, 0x6d, 0xb5, 0x2c, 0xdb, 0xf2, 0xe9, 0xd5, 0xe9, 0xb2, 0x6e,
	0x7d, 0xc0, 0x1d, 0x1d, 0x42, 0xbd, 0x61, 0x43, 0x91, 0x5d, 0x11, 0x65, 0x06, 0xf1, 0x3f, 0x4d,
	0x4f, 0x8c, 0xaf, 0xa7, 0x60, 0x76, 0x67, 0x60, 0x63, 0x7e, 0x63, 0x14, 0x87, 0x2b, 0x25, 0x20,
	0xa4, 0x59, 0x39, 0xb0, 0x71, 0x25, 0x81, 0x46, 0xa5, 0xf8, 0xc6, 0x72, 0x28, 0xa9, 0xcb, 0xf2,
	0x88, 0x66, 0xad, 0x8c, 0x85, 0x7e, 0x95, 0x2f, 0xa1, 0x18, 0x2c, 0x49, 0xe9, 0x75, 0x9e, 0x72,
	0xd0, 0xff, 0xf5, 0xed, 0x46, 0x05, 0xbb, 0x03, 0x1f, 0x1b, 0xff, 0x98, 0x85, 0x85, 0x68, 0x64,
	0x50, 0x17, 0x5c, 0x81, 0x3c, 0xcd, 0x8d, 0x9f, 0x63, 0x42, 0xcc, 0x2e, 0x46, 0x05, 0x71, 0x3c,
	0x6d, 0xd0, 0xbf, 0x15, 0xa5, 0x85, 0x9e, 0x41, 0xa9, 0xe1, 0x9b, 0x6a, 0x70, 0xb1, 0xbd, 0x21,
	0xd2, 0x11, 0x03, 0xc8, 0x69, 0xaf, 0xe8, 0x71, 0x17, 0x91, 0xbb, 0x07, 0x0b, 0x1b, 0x4e, 0x47,
	0x21, 0x45, 0xed, 0x1f, 0x23, 0x4a, 0x6f, 0xec, 0x6f, 0x22, 0xfa, 0x3d, 0x7e, 0x43, 0x56, 0x97,
	0xc7, 0x25, 0x55, 0x20, 0x06, 0x90, 0xc3, 0x39, 0x95, 0xae, 0x98, 0xa0, 0x0f, 0x61, 0xa1, 0x69,
	0x76, 0x95, 0xce, 0x4e, 0x6a, 0xcb, 0xd6, 0xec, 0xa6, 0xde, 0x0c, 0x4b, 0xbb, 0x8e, 0xff, 0xa6,
	0xd2, 0x77, 0xa0, 0xf8, 0x5d, 0xd7, 0x72, 0x14, 0xe1, 0x45, 0x55, 0x38, 0xb9, 0x5a, 0x74, 0x07,
	0x8a, 0xdb, 0x78, 0xcf, 0x3f, 0xbc, 0xe0, 0x05, 0x98, 0x69, 0x8e, 0xfa, 0xf4, 0xd2, 0x95, 0x11,
	0xc6, 0x87, 0xb8, 0x97, 0x7d, 0xa3, 0x3a, 0x54, 0x1d, 0x4e, 0x88, 0xca, 0x4a, 0xc4, 0xf0, 0x2d,
	0x67, 0xcf, 0x45, 0x19, 0x81, 0x90, 0x19, 0x24, 0x9f, 0x00, 0x3c, 0xb1, 0x6c, 0x1f, 0x7b, 0xec,
	0x22, 0x7c, 0x46, 0x45, 0x86, 0x1c, 0x69, 0xcd, 0xd9, 0x74, 0x80, 0xd8, 0x3f, 0xbb, 0x80, 0x78,
	0x3e, 0xac, 0x74, 0xa3, 0xed, 0x9e, 0x71, 0x84, 0xec, 0xe0, 0xbd, 0xf1, 0x40, 0xb1, 0x93, 0xfe,
	0x69, 0x1a, 0xf2, 0x4d, 0xdc, 0xeb, 0xdb, 0x26, 0x4f, 0x24, 0x1f, 0xc9, 0x6a, 0x95, 0x24, 0xa2,
	0x13, 0x5a, 0x54, 0x09, 0x7a, 0x25, 0x85, 0x4e, 0x35, 0x70, 0xef, 0xbe, 0xb1, 0x86, 0xa0, 0x82,
	0x15, 0x50, 0x32, 0x82, 0xe6, 0x7d, 0x56, 0x8c, 0x4b, 0x44, 0xa6, 0xe9, 0x7f, 0x02, 0x73, 0xec,
	0x0e, 0x29, 0xda, 0x04, 0x9d, 0x4e, 0x72, 0x57, 0x60, 0xe6, 0x52, 0xb2, 0x1a, 0x62, 0xfc, 0x6b,
	0x0a, 0x66, 0x9a, 0x66, 0x97, 0xdf, 0x4b, 0x72, 0xc2, 0x6d, 0x66, 0x17, 0x95, 0x62, 0xeb, 0xb0,
	0x12, 0x27, 0x51, 0x11, 0xe1, 0xa7, 0x89, 0x45, 0x2e, 0x41, 0x4e, 0x38, 0xc6, 0xec, 0x8e, 0x39,
	0x0f, 0xd8, 0x00, 0x69, 0xc2, 0x93, 0x71, 0x1e, 0x30, 0xfe, 0x65, 0x98, 0xa1, 0xfe, 0xd3, 0x14,
	0xc6, 0x3b, 0x37, 0x7e, 0x3f, 0x0d, 0xf3, 0xb2, 0x7c, 0x2b, 0x4e, 0x02, 0x56, 0x0b, 0xb7, 0x64,
	0x49, 0x37, 0xcb, 0xa2, 0x0f, 0xa1, 0x48, 0x2d, 0x8a, 0xc8, 0x93, 0xac, 0x1d, 0x58, 0xc1, 0xd5,
	0x20, 0x17, 0x94, 0x8d, 0xd9, 0x1a, 0x4f, 0x06, 0x56, 0xd2, 0x59, 0xa8, 0x05, 0x25, 0xf6, 0x55,
	0x80, 0xe5, 0x1b, 0x26, 0xcf, 0x37, 0xf4, 0x4d, 0x3c, 0xca, 0x63, 0xe0, 0xd4, 0x84, 0x2d, 0x86,
	0x23, 0x03, 0xdb, 0x37, 0xfe, 0x78, 0x04, 0x50, 0xd3, 0x6a, 0x1f, 0x60, 0x5f, 0xb9, 0x99, 0x7d,
	0x1f, 0xde, 0x61, 0x73, 0xa1, 0x72, 0x32, 0xee, 0x67, 0xda, 0xda, 0xcd, 0x10, 0x24, 0x70, 0x46,
	0x04, 0x5d, 0x1a, 0x46, 0xdf, 0x31, 0x52, 0x81, 0x95, 0x49, 0x81, 0xb4, 0x53, 0x11, 0xb6, 0xff,
	0xc7, 0x4e, 0x3f, 0x83, 0x33, 0x22, 0xf0, 0x53, 0x21, 0xda, 0x2c, 0xe9, 0xf0, 0x94, 0x5b, 0xe0,
	0xdf, 0x67, 0x20, 0xc7, 0x41, 0xbc, 0x2a, 0x54, 0x88, 0x3a, 0x54, 0x3f, 0xda, 0x38, 0xb5, 0x92,
	0x48, 0xa5, 0xb2, 0x51, 0xbf, 0x1c, 0x4a, 0xf6, 0x11, 0x14, 0xa2, 0xf6, 0xa2, 0x73, 0xe9, 0x63,
	0x49, 0x39, 0xd1, 0x6b, 0x90, 0xa3, 0xab, 0x98, 0x8b, 0xbf, 0xa3, 0x8a, 0x07, 0x0c, 0x29, 0x9b,
	0x6c, 0xc4, 0x53, 0x28, 0x88, 0x8d, 0x8f, 0xb7, 0xcf, 0x24, 0xa1, 0x58, 0xea, 0x28, 0xd4, 0x68,
	0xfb, 0xe2, 0x46, 0x83, 0x43, 0x08, 0x7a, 0xc8, 0xb7, 0x9f, 0xc6, 0x76, 0x2d, 0x16, 0xdc, 0x17,
	0xf5, 0x9d, 0x96, 0xbd, 0x83, 0xd8, 0xc6, 0x43, 0x6c, 0xd7, 0xba, 0x1e, 0xc6, 0xfc, 0x16, 0x7c,
	0x8f, 0xed, 0x49, 0x8d, 0xed, 0x9a, 0xb2, 0x47, 0x5c, 0x98, 0x40, 0x16, 0xed, 0xca, 0x8d, 0x98,
	0x4a, 0x4f, 0x22, 0x31, 0xb1, 0x5a, 0x71, 0x93, 0xfd, 0x56, 0xd5, 0x06, 0x1b, 0xba, 0x3e, 0x56,
	0x6d, 0x7a, 0x77, 0x20, 0xcf, 0xeb, 0xd8, 0x7c, 0x6a, 0x92, 0x6e, 0x67, 0xea, 0x14, 0x9f, 0xcb,
	0x40, 0x88, 0x14, 0xe3, 0x73, 0x40, 0xc1, 0x25, 0xd6, 0xb5, 0x87, 0xe2, 0x0e, 0x7b, 0x21, 0xe9,
	0x7a, 0x29, 0xd9, 0x52, 0xfb, 0xc5, 0x6c, 0x90, 0x48, 0x2d, 0x7e, 0x3a, 0x0d, 0xb9, 0x75, 0xf6,
	0x2c, 0x85, 0x9f, 0x15, 0x33, 0x7c, 0x62, 0xd0, 0x7c, 0x55, 0x3c, 0x56, 0xe1, 0xcc, 0x8a, 0xd6,
	0xa6, 0x48, 0x51, 0x7e, 0x18, 0x87, 0xbc, 0x04, 0x47, 0xe9, 0xbd, 0x67, 0x2c, 0xee, 0x01, 0x1c,
	0x8f, 0x9e, 0x3e, 0xb8, 0xc3, 0xe9, 0xea, 0x11, 0x74, 0x52, 0x0a, 0xd5, 0x06, 0xfe, 0xbe, 0xeb,
	0x59, 0x5f, 0x48, 0x98, 0x14, 0xd7, 0xe9, 0x13, 0x8a, 0x1b, 0xff, 0x9c, 0x86, 0xe3, 0x62, 0xfa,
	0xd7, 0xf9, 0xbb, 0x9c, 0xe7, 0xa6, 0x63, 0x76, 0xb1, 0xc7, 0x3f, 0xa7, 0x13, 0xcc, 0xee, 0x47,
	0x94, 0x8e, 0x8a, 0x55, 0xf9, 0x72, 0x47, 0x50, 0x2a, 0x31, 0x4a, 0x58, 0x01, 0x92, 0x84, 0xcc,
	0x44, 0x00, 0xf8, 0xbd, 0x27, 0x06, 0x8c, 0xeb, 0x5d, 0x83, 0xf9, 0x20, 0x4f, 0xf4, 0xd9, 0xf0,
	0xde, 0x0e, 0x30, 0x0a, 0x43, 0x46, 0x41, 0x49, 0x57, 0x41, 0xd0, 0x23, 0x28, 0x6f, 0xbb, 0xee,
	0xc1, 0xa0, 0x2f, 0x29, 0x6b, 0xa3, 0x5d, 0xcf, 0xe6, 0x09, 0x20, 0x43, 0x72, 0x6e, 0x86, 0x86,
	0xbb, 0xf4, 0xba, 0xe5, 0x1c, 0xc8, 0x76, 0xd3, 0xa5, 0xf2, 0x8b, 0xa1, 0xbc, 0xe5, 0xa4, 0x7c,
	0xee, 0x32, 0xfe, 0x33, 0x45, 0xb3, 0x11, 0xd3, 0x16, 0xae, 0x46, 0xab, 0x3c, 0xcb, 0xab, 0x5b,
	0x7d, 0x6c, 0x5b, 0x4e, 0xfc, 0xd3, 0xee, 0x42, 0x95, 0x3d, 0x8b, 0x0a, 0xf9, 0x57, 0x58, 0x26,
	0x29, 0xdb, 0x5a, 0x45, 0x40, 0xc1, 0xa2, 0x1b, 0x32, 0x4b, 0x0e, 0x28, 0x1a, 0x22, 0x49, 0x42,
	0x54, 0x1c, 0x26, 0x95, 0x08, 0xb2, 0xe0, 0x44, 0x8b, 0xb4, 0xc1, 0xff, 0x72, 0x0a, 0x72, 0xec,
	0x53, 0x38, 0xd9, 0xc7, 0x1e, 0x7a, 0x00, 0xb9, 0xc6, 0xa0, 0x45, 0xda, 0x9e, 0xd5, 0xc2, 0xa8,
	0x2c, 0x6e, 0xe4, 0x82, 0xd2, 0x67, 0x27, 0xef, 0xa9, 0x04, 0x62, 0xe4, 0x03, 0x5b, 0x7e, 0xd7,
	0x21, 0x6f, 0xae, 0xc0, 0xf8, 0xeb, 0x34, 0x1c, 0x63, 0x05, 0x00, 0x5e, 0x54, 0x15, 0xe7, 0x0a,
	0xa3, 0x10, 0x74, 0x52, 0x48, 0xb2, 0xef, 0xce, 0x8c, 0x14, 0x4e, 0x68, 0xa4, 0x76, 0x40, 0x90,
	0x11, 0x1d, 0x85, 0xf8, 0x38, 0x12, 0x10, 0x52, 0xce, 0xc1, 0x5b, 0xaa, 0xe9, 0x13, 0x4a, 0xad,
	0xc8, 0xa7, 0x5d, 0xbc, 0x6a, 0x51, 0x14, 0x76, 0xb0, 0x2f, 0x6c, 0x09, 0x55, 0x0d, 0x03, 0x72,
	0x74, 0xdb, 0x61, 0x1f, 0xee, 0x64, 0x17, 0x01, 0x21, 0xf5, 0x63, 0x9c, 0x3c, 0x5d, 0xf9, 0xe7,
	0xbe, 0xa5, 0xf0, 0x63, 0x0f, 0xa7, 0x68, 0xdf, 0x90, 0xa3, 0x0c, 0x96, 0x5e, 0xfe, 0x7b, 0x0a,
	0x96, 0xa2, 0x37, 0x38, 0x66, 0xca, 0x0e, 0x7b, 0x38, 0x48, 0x23, 0xb7, 0x81, 0x9d, 0xce, 0x24,
	0x15, 0x99, 0x6b, 0xb2, 0x52, 0x3d, 0x09, 0xf8, 0x23, 0xfe, 0x82, 0x45, 0xcc, 0xc7, 0x99, 0x78,
	0xd1, 0x23, 0x73, 0xfe, 0x6a, 0xda, 0xc4, 0x9f, 0x4f, 0xba, 0x65, 0x09, 0x33, 0x92, 0x55, 0x18,
	0xbf, 0x9a, 0x82, 0xd9, 0x27, 0x96, 0x2d, 0xbe, 0x95, 0xcd, 0xd6, 0x3d, 0x4c, 0xac, 0xae, 0x83,
	0x8a, 0x55, 0xf6, 0x70, 0x91, 0x72, 0x9e, 0xf2, 0xa7, 0x93, 0x65, 0x4e, 0x11, 0x00, 0xf1, 0xd9,
	0xfd, 0x5d, 0x71, 0x3c, 0x94, 0x42, 0x78, 0xf8, 0x99, 0x2a, 0x20, 0xa1, 0x2b, 0x70, 0x6c, 0xb7,
	0x6f, 0xbb, 0x66, 0x07, 0x8f, 0x83, 0x1a, 0xab, 0xf0, 0xd6, 0x33, 0x73, 0xaf, 0xdf, 0x46, 0x97,
	0xe0, 0xad, 0x1d, 0xdc, 0xb7, 0x47, 0x68, 0xa1, 0xca, 0xdf, 0x4d, 0xca, 0xd8, 0xaf, 0x14, 0x04,
	0x81, 0xaf, 0xcb, 0x97, 0x30, 0xfd, 0xec, 0x25, 0x3a, 0x05, 0x47, 0x1a, 0xd8, 0x47, 0xb9, 0xea,
	0xc1, 0xb0, 0xfa, 0xd2, 0xb4, 0x07, 0xb8, 0x12, 0xfe, 0x8b, 0x96, 0xe1, 0xc8, 0x26, 0xf6, 0xd1,
	0x2c, 0xa5, 0x3c, 0xc3, 0xa3, 0x28, 0xeb, 0x24, 0x1c, 0x79, 0x6a, 0x92, 0x90, 0x75, 0x8c, 0xfe,
	0xb3, 0xe6, 0xba, 0xb6, 0xf1, 0x93, 0x29, 0x28, 0xbc, 0x70, 0x7d, 0xeb, 0xb6, 0xdc, 0xed, 0x6e,
	0xc3, 0x12, 0x1d, 0x2b, 0xa5, 0xed, 0x59, 0x6d, 0xe6, 0xe1, 0x06, 0xf6, 0x7d, 0xbd, 0xe2, 0x32,
	0x5f, 0xe5, 0x0f, 0x32, 0x25, 0xef, 0xbe, 0xfc, 0x3a, 0x93, 0x24, 0xa8, 0x81, 0x75, 0x61, 0xe3,
	0x77, 0x53, 0x50, 0x62, 0x46, 0xb0, 0xa7, 0x65, 0xd2, 0x92, 0xcb, 0xec, 0x93, 0x39, 0x23, 0xa1,
	0x82, 0x90, 0xe0, 0x6f, 0xcf, 0x62, 0x87, 0x53, 0x9e, 0xbf, 0x5b, 0x9a, 0x00, 0xbb, 0x0a, 0x45,
	0x76, 0xd7, 0x62, 0xcc, 0x8d, 0xd7, 0x16, 0xf1, 0x49, 0xa6, 0x80, 0xf1, 0xe7, 0x69, 0x98, 0x7f,
	0xc1, 0x9f, 0xa2, 0x4a, 0xc3, 0x0c, 0x80, 0x60, 0x95, 0x12, 0x74, 0xbc, 0x2a, 0x5f, 0xaa, 0x66,
	0x2d, 0x5b, 0x03, 0xa0, 0x81, 0xb1, 0x73, 0x28, 0x99, 0x5b, 0x50, 0xd8, 0x75, 0xbc, 0xc3, 0xf6,
	0x74, 0x2f, 0xf8, 0x14, 0x6c, 0x11, 0xb4, 0x18, 0x88, 0x44, 0x13, 0xee, 0x13, 0x01, 0x35, 0x3a,
	0x5b, 0x24, 0x7c, 0x95, 0x27, 0x06, 0x8c, 0x8a, 0x0a, 0xb0, 0xe5, 0xbe, 0xae, 0xc4, 0x28, 0xe8,
	0x1a, 0xff, 0x38, 0x24, 0x9b, 0x6a, 0x6e, 0xa0, 0x81, 0x8d, 0x5f, 0x4c, 0xc1, 0x52, 0x63, 0xd0,
	0xb2, 0xbe, 0xa0, 0x29, 0x94, 0xe7, 0x98, 0x76, 0x9d, 0x3f, 0xfa, 0xe5, 0x75, 0x77, 0x51, 0xdb,
	0x5e, 0xb3, 0x6c, 0x1b, 0xcd, 0x55, 0xe5, 0x7b, 0x60, 0xda, 0xac, 0xa8, 0x4d, 0xb4, 0x06, 0x88,
	0x5b, 0xaa, 0xbd, 0xed, 0x91, 0x20, 0xed, 0x6d, 0x4f, 0x12, 0xd9, 0xf8, 0x79, 0x09, 0x20, 0xd2,
	0xfd, 0x4d, 0x38, 0x56, 0x1f, 0x78, 0xed, 0x7d, 0x93, 0x44, 0x15, 0x29, 0x67, 0x55, 0x31, 0x20,
	0x6f, 0x39, 0x43, 0x97, 0x86, 0x42, 0x60, 0x47, 0x14, 0x97, 0x26, 0x9e, 0x4c, 0x46, 0xb7, 0x58,
	0x4d, 0x59, 0x21, 0x45, 0x9d, 0x98, 0x22, 0xb5, 0x06, 0xc5, 0x5a, 0xa7, 0x23, 0xed, 0xc7, 0xfe,
	0xbe, 0xdb, 0x41, 0x27, 0x02, 0xa8, 0x42, 0xaf, 0xa4, 0xd0, 0xd1, 0x06, 0x94, 0xe5, 0x23, 0xdd,
	0x6f, 0xa2, 0xe6, 0x06, 0x94, 0x45, 0x82, 0xa1, 0x90, 0x33, 0xd2, 0xc9, 0x7b, 0x80, 0x58, 0x4a,
	0x15, 0xc5, 0x13, 0xed, 0xd1, 0x44, 0x62, 0x5f, 0x34, 0xb9, 0x3a, 0x52, 0x37, 0x47, 0xa8, 0x1c,
	0xe5, 0x87, 0x2b, 0x41, 0x09, 0x92, 0x15, 0xfe, 0x4d, 0x54, 0xcc, 0x15, 0xd1, 0xea, 0x52, 0xda,
	0x54, 0xb2, 0xe8, 0xe7, 0xf1, 0x27, 0x27, 0x37, 0x36, 0xdd, 0x09, 0x01, 0x10, 0x2c, 0x99, 0xc3,
	0x08, 0x3d, 0x82, 0x79, 0x5e, 0xaa, 0x0d, 0xfa, 0x3e, 0x15, 0x60, 0x22, 0x16, 0x87, 0xd9, 0x6d,
	0xcc, 0xd6, 0x3b, 0x50, 0x78, 0xec, 0x99, 0x7b, 0x12, 0x39, 0x79, 0xc0, 0x7e, 0x0c, 0xa5, 0xc7,
	0xd6, 0xde, 0x5e, 0x14, 0x45, 0x73, 0x08, 0x09, 0x13, 0xbc, 0xf0, 0x05, 0xad, 0x2e, 0xff, 0x90,
	0xfb, 0x74, 0xdd, 0xed, 0xf1, 0x1b, 0xf6, 0x69, 0xc5, 0x70, 0x49, 0x8e, 0x5b, 0x1e, 0x08, 0xdc,
	0x00, 0xa8, 0x75, 0x3a, 0xa2, 0x19, 0xf1, 0x96, 0xa0, 0x54, 0x62, 0x14, 0x74, 0x95, 0x6f, 0x68,
	0x75, 0xdb, 0x8c, 0xd7, 0xb8, 0xe6, 0xc3, 0x30, 0x60, 0xec, 0xeb, 0x30, 0xc7, 0x9f, 0x32, 0x49,
	0x7b, 0xd5, 0x37, 0xbe, 0x81, 0x93, 0x7c, 0x8f, 0x9e, 0x4b, 0xf7, 0xe4, 0x77, 0x5f, 0x09, 0x6f,
	0xba, 0x4f, 0xfd, 0x9e, 0x9d, 0x30, 0x87, 0x31, 0xd1, 0x87, 0xf1, 0x47, 0x8a, 0x87, 0xda, 0x7d,
	0x68, 0xe0, 0x34, 0x3d, 0xd3, 0x21, 0x7b, 0xd8, 0x7b, 0xee, 0x3a, 0x78, 0xb2, 0x88, 0xbe, 0xc9,
	0x0b, 0x22, 0xdb, 0x6e, 0x97, 0xa6, 0xbf, 0x51, 0xcf, 0x53, 0x52, 0x5c, 0x88, 0x01, 0x37, 0xa0,
	0x2c, 0xee, 0x18, 0x9e, 0xdb, 0x73, 0xd9, 0x7b, 0x22, 0xb7, 0x83, 0xa3, 0xab, 0x3c, 0x4a, 0xaf,
	0xa4, 0xd0, 0xd1, 0x7d, 0x28, 0xd2, 0x5b, 0x8d, 0x42, 0xd3, 0xdd, 0x92, 0x2a, 0xfc, 0x08, 0x8a,
	0xbb, 0x44, 0x33, 0xe0, 0xed, 0x64, 0x6c, 0xca, 0xb1, 0xf6, 0x02, 0x8e, 0xbf, 0x34, 0x6d, 0xab,
	0x13, 0x1b, 0xc7, 0x18, 0x35, 0x69, 0x16, 0x7d, 0xc2, 0x3f, 0xc7, 0xa9, 0xc4, 0x73, 0x8a, 0x4f,
	0x13, 0xf5, 0x2d, 0x25, 0xeb, 0x23, 0x91, 0x5d, 0x50, 0x51, 0x99, 0xb1, 0x0b, 0xae, 0xcb, 0x8b,
	0xf2, 0x0e, 0xde, 0xc3, 0x9e, 0x67, 0xda, 0xe8, 0x9d, 0xd0, 0x9f, 0x11, 0x06, 0xee, 0xc4, 0xd7,
	0x53, 0x20, 0xc2, 0xdf, 0x10, 0x07, 0xcd, 0xe4, 0x3d, 0x2e, 0x60, 0xdf, 0x0f, 0x5e, 0xbd, 0x05,
	0x24, 0x6d, 0x45, 0x2d, 0xc7, 0x84, 0x82, 0xeb, 0x5c, 0xf0, 0x90, 0x38, 0x90, 0x8d, 0xf7, 0x90,
	0xd4, 0xe9, 0x43, 0x28, 0xb3, 0xb2, 0x87, 0x7c, 0x9d, 0xcf, 0xc7, 0xa4, 0x98, 0x7a, 0x3a, 0x1a,
	0xb2, 0x1a, 0x90, 0xa0, 0x67, 0xb0, 0x4c, 0x15, 0xd0, 0x25, 0xb0, 0x36, 0xca, 0x52, 0x73, 0x3e,
	0xaa, 0x26, 0x11, 0x4e, 0xd0, 0x16, 0x7f, 0xe1, 0x54, 0x37, 0xad, 0xce, 0x13, 0xd7, 0x63, 0x5f,
	0xff, 0x05, 0x53, 0x7d, 0x91, 0x7a, 0x2e, 0xaa, 0x2b, 0x09, 0x4d, 0xd0, 0x26, 0x2c, 0x26, 0xaa,
	0x39, 0x3b, 0x4e, 0x54, 0x4f, 0x32, 0x5f, 0x40, 0xbe, 0x6e, 0x9b, 0x6d, 0xfc, 0x94, 0xfd, 0x20,
	0x0a, 0x3d, 0x84, 0x59, 0x51, 0x07, 0xa3, 0x07, 0x43, 0xe4, 0x97, 0x52, 0x82, 0x1a, 0x3e, 0x7c,
	0x4e, 0x60, 0x76, 0xce, 0x7f, 0xc7, 0x70, 0x60, 0xa6, 0xce, 0x7e, 0x6e, 0x85, 0x6e, 0x44, 0xef,
	0xbe, 0x8b, 0x55, 0xf1, 0x23, 0x2c, 0xe5, 0x90, 0x88, 0x65, 0xaa, 0xca, 0xcd, 0x77, 0x12, 0x19,
	0xe3, 0x6f, 0x53, 0x30, 0xf7, 0x19, 0xfb, 0x4d, 0x96, 0xcc, 0x91, 0x2f, 0x88, 0x2b, 0x93, 0xba,
	0xff, 0x8a, 0xdf, 0x6d, 0xc9, 0x7b, 0xc1, 0xd5, 0xa0, 0x40, 0xa7, 0xb3, 0xe2, 0x58, 0x03, 0x16,
	0xe4, 0xc3, 0xe1, 0xa4, 0xfb, 0x48, 0x59, 0xe2, 0xa3, 0x80, 0x07, 0x50, 0x0a, 0x9f, 0x24, 0x4b,
	0x62, 0x12, 0x32, 0x51, 0xdc, 0x70, 0x60, 0x51, 0x0c, 0xa7, 0xc6, 0x7e, 0x52, 0x26, 0xab, 0x6d,
	0x97, 0x59, 0x8d, 0x9c, 0xd3, 0xf4, 0x5f, 0xd1, 0xf0, 0xdf, 0x9e, 0x09, 0xde, 0x0a, 0x14, 0x78,
	0x59, 0x4e, 0xb4, 0x35, 0xbe, 0xee, 0xc5, 0x9f, 0x4d, 0xc3, 0xfc, 0x67, 0xb8, 0xb5, 0xef, 0xba,
	0x07, 0xd9, 0x6e, 0x14, 0x05, 0x42, 0x81, 0x45, 0x17, 0x60, 0x86, 0xef, 0x3c, 0x59, 0x9b, 0xcd,
	0x45, 0x38, 0x4a, 0xc3, 0x5e, 0xaf, 0xdd, 0x29, 0x9a, 0x88, 0x32, 0x23, 0x2a, 0x2f, 0xde, 0xed,
	0xd5, 0xa0, 0x10, 0x3b, 0x1e, 0xbb, 0x02, 0x47, 0x9b, 0x58, 0xeb, 0x7d, 0x59, 0x03, 0x35, 0xf9,
	0x4f, 0xce, 0x06, 0xb6, 0xdf, 0x9a, 0x61, 0xbf, 0xd8, 0xbb, 0xf9, 0xdf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x7e, 0x7d, 0x9d, 0xdc, 0xe0, 0x38, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ApiServerClient is the client API for ApiServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ApiServerClient interface {
	Call(ctx context.Context, in *api.Request, opts ...grpc.CallOption) (*api.Response, error)
}

type apiServerClient struct {
	cc *grpc.ClientConn
}

func NewApiServerClient(cc *grpc.ClientConn) ApiServerClient {
	return &apiServerClient{cc}
}

func (c *apiServerClient) Call(ctx context.Context, in *api.Request, opts ...grpc.CallOption) (*api.Response, error) {
	out := new(api.Response)
	err := c.cc.Invoke(ctx, "/header.ApiServer/Call", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServerServer is the server API for ApiServer service.
type ApiServerServer interface {
	Call(context.Context, *api.Request) (*api.Response, error)
}

func RegisterApiServerServer(s *grpc.Server, srv ApiServerServer) {
	s.RegisterService(&_ApiServer_serviceDesc, srv)
}

func _ApiServer_Call_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServerServer).Call(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ApiServer/Call",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServerServer).Call(ctx, req.(*api.Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApiServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ApiServer",
	HandlerType: (*ApiServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Call",
			Handler:    _ApiServer_Call_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AccSubMgrClient is the client API for AccSubMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccSubMgrClient interface {
	SearchSub(ctx context.Context, in *account.SearchSubRequest, opts ...grpc.CallOption) (*account.AccSubs, error)
}

type accSubMgrClient struct {
	cc *grpc.ClientConn
}

func NewAccSubMgrClient(cc *grpc.ClientConn) AccSubMgrClient {
	return &accSubMgrClient{cc}
}

func (c *accSubMgrClient) SearchSub(ctx context.Context, in *account.SearchSubRequest, opts ...grpc.CallOption) (*account.AccSubs, error) {
	out := new(account.AccSubs)
	err := c.cc.Invoke(ctx, "/header.AccSubMgr/SearchSub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccSubMgrServer is the server API for AccSubMgr service.
type AccSubMgrServer interface {
	SearchSub(context.Context, *account.SearchSubRequest) (*account.AccSubs, error)
}

func RegisterAccSubMgrServer(s *grpc.Server, srv AccSubMgrServer) {
	s.RegisterService(&_AccSubMgr_serviceDesc, srv)
}

func _AccSubMgr_SearchSub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.SearchSubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccSubMgrServer).SearchSub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccSubMgr/SearchSub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccSubMgrServer).SearchSub(ctx, req.(*account.SearchSubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccSubMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AccSubMgr",
	HandlerType: (*AccSubMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchSub",
			Handler:    _AccSubMgr_SearchSub_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AccountMgrClient is the client API for AccountMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountMgrClient interface {
	CreateGroup(ctx context.Context, in *account.AgentGroup, opts ...grpc.CallOption) (*account.AgentGroup, error)
	UpdateGroup(ctx context.Context, in *account.AgentGroup, opts ...grpc.CallOption) (*account.AgentGroup, error)
	GetGroup(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.AgentGroup, error)
	RequestResetPassword(ctx context.Context, in *account.ResetPasswordRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UpdatePassword(ctx context.Context, in *account.NewPassword, opts ...grpc.CallOption) (*account.Agent, error)
	UpdateAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error)
	DeleteAgent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agent, error)
	RequestChangeEmail(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*common.Empty, error)
	ConfirmChangeEmail(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Agent, error)
	AcceptInvitation(ctx context.Context, in *account.NewPassword, opts ...grpc.CallOption) (*account.Agent, error)
	GetInvitation(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Agent, error)
	InviteAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error)
	GetAgent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agent, error)
	ConfirmAccount(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Account, error)
	GetAccount(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Account, error)
	UpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error)
	CreateAccount(ctx context.Context, in *account.CreateAccountRequest, opts ...grpc.CallOption) (*account.Account, error)
	ListAgents(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agents, error)
	CheckLogin(ctx context.Context, in *account.LoginRequest, opts ...grpc.CallOption) (*common.Id, error)
	Login(ctx context.Context, in *account.LoginRequest, opts ...grpc.CallOption) (*account.Agent, error)
	DeleteGroup(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ListGroups(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.AgentGroups, error)
	AddAgentToGroup(ctx context.Context, in *account.GroupMember, opts ...grpc.CallOption) (*common.Empty, error)
	RemoveAgentFromGroup(ctx context.Context, in *account.GroupMember, opts ...grpc.CallOption) (*common.Empty, error)
	ChangeEmail(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error)
	QueryByObjectPath(ctx context.Context, in *common.ObjectPathRequest, opts ...grpc.CallOption) (*common.Ids, error)
	IntegrateBot(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error)
	SyncPublicHolidays(ctx context.Context, in *account.SyncPublicHolidaysRequest, opts ...grpc.CallOption) (*account.BusinessHours, error)
}

type accountMgrClient struct {
	cc *grpc.ClientConn
}

func NewAccountMgrClient(cc *grpc.ClientConn) AccountMgrClient {
	return &accountMgrClient{cc}
}

func (c *accountMgrClient) CreateGroup(ctx context.Context, in *account.AgentGroup, opts ...grpc.CallOption) (*account.AgentGroup, error) {
	out := new(account.AgentGroup)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateGroup(ctx context.Context, in *account.AgentGroup, opts ...grpc.CallOption) (*account.AgentGroup, error) {
	out := new(account.AgentGroup)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/UpdateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetGroup(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.AgentGroup, error) {
	out := new(account.AgentGroup)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RequestResetPassword(ctx context.Context, in *account.ResetPasswordRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/RequestResetPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdatePassword(ctx context.Context, in *account.NewPassword, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/UpdatePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/UpdateAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteAgent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/DeleteAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RequestChangeEmail(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/RequestChangeEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ConfirmChangeEmail(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/ConfirmChangeEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) AcceptInvitation(ctx context.Context, in *account.NewPassword, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/AcceptInvitation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetInvitation(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/GetInvitation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) InviteAgent(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/InviteAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetAgent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/GetAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ConfirmAccount(ctx context.Context, in *account.Token, opts ...grpc.CallOption) (*account.Account, error) {
	out := new(account.Account)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/ConfirmAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) GetAccount(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Account, error) {
	out := new(account.Account)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/GetAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) UpdateAccount(ctx context.Context, in *account.Account, opts ...grpc.CallOption) (*account.Account, error) {
	out := new(account.Account)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/UpdateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CreateAccount(ctx context.Context, in *account.CreateAccountRequest, opts ...grpc.CallOption) (*account.Account, error) {
	out := new(account.Account)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/CreateAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListAgents(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Agents, error) {
	out := new(account.Agents)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/ListAgents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) CheckLogin(ctx context.Context, in *account.LoginRequest, opts ...grpc.CallOption) (*common.Id, error) {
	out := new(common.Id)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/CheckLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) Login(ctx context.Context, in *account.LoginRequest, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) DeleteGroup(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/DeleteGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ListGroups(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.AgentGroups, error) {
	out := new(account.AgentGroups)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/ListGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) AddAgentToGroup(ctx context.Context, in *account.GroupMember, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/AddAgentToGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) RemoveAgentFromGroup(ctx context.Context, in *account.GroupMember, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/RemoveAgentFromGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) ChangeEmail(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/ChangeEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) QueryByObjectPath(ctx context.Context, in *common.ObjectPathRequest, opts ...grpc.CallOption) (*common.Ids, error) {
	out := new(common.Ids)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/QueryByObjectPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) IntegrateBot(ctx context.Context, in *account.Agent, opts ...grpc.CallOption) (*account.Agent, error) {
	out := new(account.Agent)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/IntegrateBot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountMgrClient) SyncPublicHolidays(ctx context.Context, in *account.SyncPublicHolidaysRequest, opts ...grpc.CallOption) (*account.BusinessHours, error) {
	out := new(account.BusinessHours)
	err := c.cc.Invoke(ctx, "/header.AccountMgr/SyncPublicHolidays", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountMgrServer is the server API for AccountMgr service.
type AccountMgrServer interface {
	CreateGroup(context.Context, *account.AgentGroup) (*account.AgentGroup, error)
	UpdateGroup(context.Context, *account.AgentGroup) (*account.AgentGroup, error)
	GetGroup(context.Context, *common.Id) (*account.AgentGroup, error)
	RequestResetPassword(context.Context, *account.ResetPasswordRequest) (*common.Empty, error)
	UpdatePassword(context.Context, *account.NewPassword) (*account.Agent, error)
	UpdateAgent(context.Context, *account.Agent) (*account.Agent, error)
	DeleteAgent(context.Context, *common.Id) (*account.Agent, error)
	RequestChangeEmail(context.Context, *account.Agent) (*common.Empty, error)
	ConfirmChangeEmail(context.Context, *account.Token) (*account.Agent, error)
	AcceptInvitation(context.Context, *account.NewPassword) (*account.Agent, error)
	GetInvitation(context.Context, *account.Token) (*account.Agent, error)
	InviteAgent(context.Context, *account.Agent) (*account.Agent, error)
	GetAgent(context.Context, *common.Id) (*account.Agent, error)
	ConfirmAccount(context.Context, *account.Token) (*account.Account, error)
	GetAccount(context.Context, *common.Id) (*account.Account, error)
	UpdateAccount(context.Context, *account.Account) (*account.Account, error)
	CreateAccount(context.Context, *account.CreateAccountRequest) (*account.Account, error)
	ListAgents(context.Context, *common.Id) (*account.Agents, error)
	CheckLogin(context.Context, *account.LoginRequest) (*common.Id, error)
	Login(context.Context, *account.LoginRequest) (*account.Agent, error)
	DeleteGroup(context.Context, *common.Id) (*common.Empty, error)
	ListGroups(context.Context, *common.Id) (*account.AgentGroups, error)
	AddAgentToGroup(context.Context, *account.GroupMember) (*common.Empty, error)
	RemoveAgentFromGroup(context.Context, *account.GroupMember) (*common.Empty, error)
	ChangeEmail(context.Context, *account.Agent) (*account.Agent, error)
	QueryByObjectPath(context.Context, *common.ObjectPathRequest) (*common.Ids, error)
	IntegrateBot(context.Context, *account.Agent) (*account.Agent, error)
	SyncPublicHolidays(context.Context, *account.SyncPublicHolidaysRequest) (*account.BusinessHours, error)
}

func RegisterAccountMgrServer(s *grpc.Server, srv AccountMgrServer) {
	s.RegisterService(&_AccountMgr_serviceDesc, srv)
}

func _AccountMgr_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.AgentGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateGroup(ctx, req.(*account.AgentGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.AgentGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/UpdateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateGroup(ctx, req.(*account.AgentGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetGroup(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RequestResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ResetPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RequestResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/RequestResetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RequestResetPassword(ctx, req.(*account.ResetPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdatePassword(ctx, req.(*account.NewPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/UpdateAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAgent(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/DeleteAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteAgent(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RequestChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RequestChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/RequestChangeEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RequestChangeEmail(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ConfirmChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ConfirmChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/ConfirmChangeEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ConfirmChangeEmail(ctx, req.(*account.Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_AcceptInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).AcceptInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/AcceptInvitation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).AcceptInvitation(ctx, req.(*account.NewPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/GetInvitation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetInvitation(ctx, req.(*account.Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_InviteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).InviteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/InviteAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).InviteAgent(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/GetAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetAgent(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ConfirmAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ConfirmAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/ConfirmAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ConfirmAccount(ctx, req.(*account.Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).GetAccount(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).UpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/UpdateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).UpdateAccount(ctx, req.(*account.Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CreateAccount(ctx, req.(*account.CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/ListAgents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListAgents(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_CheckLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).CheckLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/CheckLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).CheckLogin(ctx, req.(*account.LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).Login(ctx, req.(*account.LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).DeleteGroup(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ListGroups(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_AddAgentToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.GroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).AddAgentToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/AddAgentToGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).AddAgentToGroup(ctx, req.(*account.GroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_RemoveAgentFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.GroupMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).RemoveAgentFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/RemoveAgentFromGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).RemoveAgentFromGroup(ctx, req.(*account.GroupMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_ChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).ChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/ChangeEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).ChangeEmail(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_QueryByObjectPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ObjectPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).QueryByObjectPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/QueryByObjectPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).QueryByObjectPath(ctx, req.(*common.ObjectPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_IntegrateBot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Agent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).IntegrateBot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/IntegrateBot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).IntegrateBot(ctx, req.(*account.Agent))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountMgr_SyncPublicHolidays_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.SyncPublicHolidaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountMgrServer).SyncPublicHolidays(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AccountMgr/SyncPublicHolidays",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountMgrServer).SyncPublicHolidays(ctx, req.(*account.SyncPublicHolidaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AccountMgr",
	HandlerType: (*AccountMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGroup",
			Handler:    _AccountMgr_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _AccountMgr_UpdateGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _AccountMgr_GetGroup_Handler,
		},
		{
			MethodName: "RequestResetPassword",
			Handler:    _AccountMgr_RequestResetPassword_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _AccountMgr_UpdatePassword_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _AccountMgr_UpdateAgent_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _AccountMgr_DeleteAgent_Handler,
		},
		{
			MethodName: "RequestChangeEmail",
			Handler:    _AccountMgr_RequestChangeEmail_Handler,
		},
		{
			MethodName: "ConfirmChangeEmail",
			Handler:    _AccountMgr_ConfirmChangeEmail_Handler,
		},
		{
			MethodName: "AcceptInvitation",
			Handler:    _AccountMgr_AcceptInvitation_Handler,
		},
		{
			MethodName: "GetInvitation",
			Handler:    _AccountMgr_GetInvitation_Handler,
		},
		{
			MethodName: "InviteAgent",
			Handler:    _AccountMgr_InviteAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AccountMgr_GetAgent_Handler,
		},
		{
			MethodName: "ConfirmAccount",
			Handler:    _AccountMgr_ConfirmAccount_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _AccountMgr_GetAccount_Handler,
		},
		{
			MethodName: "UpdateAccount",
			Handler:    _AccountMgr_UpdateAccount_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _AccountMgr_CreateAccount_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _AccountMgr_ListAgents_Handler,
		},
		{
			MethodName: "CheckLogin",
			Handler:    _AccountMgr_CheckLogin_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AccountMgr_Login_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _AccountMgr_DeleteGroup_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _AccountMgr_ListGroups_Handler,
		},
		{
			MethodName: "AddAgentToGroup",
			Handler:    _AccountMgr_AddAgentToGroup_Handler,
		},
		{
			MethodName: "RemoveAgentFromGroup",
			Handler:    _AccountMgr_RemoveAgentFromGroup_Handler,
		},
		{
			MethodName: "ChangeEmail",
			Handler:    _AccountMgr_ChangeEmail_Handler,
		},
		{
			MethodName: "QueryByObjectPath",
			Handler:    _AccountMgr_QueryByObjectPath_Handler,
		},
		{
			MethodName: "IntegrateBot",
			Handler:    _AccountMgr_IntegrateBot_Handler,
		},
		{
			MethodName: "SyncPublicHolidays",
			Handler:    _AccountMgr_SyncPublicHolidays_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// CurrencyMgrClient is the client API for CurrencyMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CurrencyMgrClient interface {
	ListCurrencies(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*account.Currencies, error)
	GetCurrency(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Currency, error)
	CreateCurrency(ctx context.Context, in *account.Currency, opts ...grpc.CallOption) (*account.Currency, error)
	UpdateCurrency(ctx context.Context, in *account.Currency, opts ...grpc.CallOption) (*account.Currency, error)
	DeleteCurrency(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ListExchangeRates(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*account.ExchangeRates, error)
	GetExchangeRate(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*account.ExchangeRate, error)
	CreateExchangeRate(ctx context.Context, in *account.ExchangeRate, opts ...grpc.CallOption) (*account.ExchangeRate, error)
	DeleteExchangeRate(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type currencyMgrClient struct {
	cc *grpc.ClientConn
}

func NewCurrencyMgrClient(cc *grpc.ClientConn) CurrencyMgrClient {
	return &currencyMgrClient{cc}
}

func (c *currencyMgrClient) ListCurrencies(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*account.Currencies, error) {
	out := new(account.Currencies)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/ListCurrencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) GetCurrency(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*account.Currency, error) {
	out := new(account.Currency)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/GetCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) CreateCurrency(ctx context.Context, in *account.Currency, opts ...grpc.CallOption) (*account.Currency, error) {
	out := new(account.Currency)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/CreateCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) UpdateCurrency(ctx context.Context, in *account.Currency, opts ...grpc.CallOption) (*account.Currency, error) {
	out := new(account.Currency)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/UpdateCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) DeleteCurrency(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/DeleteCurrency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) ListExchangeRates(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*account.ExchangeRates, error) {
	out := new(account.ExchangeRates)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/ListExchangeRates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) GetExchangeRate(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*account.ExchangeRate, error) {
	out := new(account.ExchangeRate)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/GetExchangeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) CreateExchangeRate(ctx context.Context, in *account.ExchangeRate, opts ...grpc.CallOption) (*account.ExchangeRate, error) {
	out := new(account.ExchangeRate)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/CreateExchangeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *currencyMgrClient) DeleteExchangeRate(ctx context.Context, in *account.ExchangeRateRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.CurrencyMgr/DeleteExchangeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CurrencyMgrServer is the server API for CurrencyMgr service.
type CurrencyMgrServer interface {
	ListCurrencies(context.Context, *common.Empty) (*account.Currencies, error)
	GetCurrency(context.Context, *common.Id) (*account.Currency, error)
	CreateCurrency(context.Context, *account.Currency) (*account.Currency, error)
	UpdateCurrency(context.Context, *account.Currency) (*account.Currency, error)
	DeleteCurrency(context.Context, *common.Id) (*common.Empty, error)
	ListExchangeRates(context.Context, *account.ExchangeRateRequest) (*account.ExchangeRates, error)
	GetExchangeRate(context.Context, *account.ExchangeRateRequest) (*account.ExchangeRate, error)
	CreateExchangeRate(context.Context, *account.ExchangeRate) (*account.ExchangeRate, error)
	DeleteExchangeRate(context.Context, *account.ExchangeRateRequest) (*common.Empty, error)
}

func RegisterCurrencyMgrServer(s *grpc.Server, srv CurrencyMgrServer) {
	s.RegisterService(&_CurrencyMgr_serviceDesc, srv)
}

func _CurrencyMgr_ListCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).ListCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/ListCurrencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).ListCurrencies(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_GetCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).GetCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/GetCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).GetCurrency(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_CreateCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).CreateCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/CreateCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).CreateCurrency(ctx, req.(*account.Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_UpdateCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.Currency)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).UpdateCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/UpdateCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).UpdateCurrency(ctx, req.(*account.Currency))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_DeleteCurrency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).DeleteCurrency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/DeleteCurrency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).DeleteCurrency(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_ListExchangeRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).ListExchangeRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/ListExchangeRates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).ListExchangeRates(ctx, req.(*account.ExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_GetExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).GetExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/GetExchangeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).GetExchangeRate(ctx, req.(*account.ExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_CreateExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ExchangeRate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).CreateExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/CreateExchangeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).CreateExchangeRate(ctx, req.(*account.ExchangeRate))
	}
	return interceptor(ctx, in, info, handler)
}

func _CurrencyMgr_DeleteExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(account.ExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CurrencyMgrServer).DeleteExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.CurrencyMgr/DeleteExchangeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CurrencyMgrServer).DeleteExchangeRate(ctx, req.(*account.ExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CurrencyMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.CurrencyMgr",
	HandlerType: (*CurrencyMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCurrencies",
			Handler:    _CurrencyMgr_ListCurrencies_Handler,
		},
		{
			MethodName: "GetCurrency",
			Handler:    _CurrencyMgr_GetCurrency_Handler,
		},
		{
			MethodName: "CreateCurrency",
			Handler:    _CurrencyMgr_CreateCurrency_Handler,
		},
		{
			MethodName: "UpdateCurrency",
			Handler:    _CurrencyMgr_UpdateCurrency_Handler,
		},
		{
			MethodName: "DeleteCurrency",
			Handler:    _CurrencyMgr_DeleteCurrency_Handler,
		},
		{
			MethodName: "ListExchangeRates",
			Handler:    _CurrencyMgr_ListExchangeRates_Handler,
		},
		{
			MethodName: "GetExchangeRate",
			Handler:    _CurrencyMgr_GetExchangeRate_Handler,
		},
		{
			MethodName: "CreateExchangeRate",
			Handler:    _CurrencyMgr_CreateExchangeRate_Handler,
		},
		{
			MethodName: "DeleteExchangeRate",
			Handler:    _CurrencyMgr_DeleteExchangeRate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// UserMgrClient is the client API for UserMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UserMgrClient interface {
	SearchUsers(ctx context.Context, in *user.UserSearchRequest, opts ...grpc.CallOption) (*user.UserSearchResult, error)
	// rpc SubizID (SubizIDRequest) returns (SubizIDResponse);
	PickToSegmentation(ctx context.Context, in *user.PickRequest, opts ...grpc.CallOption) (*common.Empty, error)
	DeleteFromSegmentation(ctx context.Context, in *user.UnpickRequest, opts ...grpc.CallOption) (*common.Empty, error)
	CreateUser(ctx context.Context, in *user.User, opts ...grpc.CallOption) (*common.Id, error)
	UpdateUser(ctx context.Context, in *user.User, opts ...grpc.CallOption) (*common.Id, error)
	ReadUser(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.User, error)
	CountSegmentationUserByAttribute(ctx context.Context, in *user.CountSegmentationUserByAttributeRequest, opts ...grpc.CallOption) (*user.CountResponse, error)
	CountTotal(ctx context.Context, in *user.CountTotalRequest, opts ...grpc.CallOption) (*user.CountTotalResponse, error)
	Ping(ctx context.Context, in *common.PingRequest, opts ...grpc.CallOption) (*common.Pong, error)
	AddAlias(ctx context.Context, in *user.Alias, opts ...grpc.CallOption) (*common.Empty, error)
	MergeUsers(ctx context.Context, in *user.MergeRequest, opts ...grpc.CallOption) (*common.Empty, error)
	ReadAllTopics(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ExportUsers(ctx context.Context, in *user.UserExportRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SearchNote(ctx context.Context, in *user.SearchNoteRequest, opts ...grpc.CallOption) (*user.SearchNoteResponse, error)
}

type userMgrClient struct {
	cc *grpc.ClientConn
}

func NewUserMgrClient(cc *grpc.ClientConn) UserMgrClient {
	return &userMgrClient{cc}
}

func (c *userMgrClient) SearchUsers(ctx context.Context, in *user.UserSearchRequest, opts ...grpc.CallOption) (*user.UserSearchResult, error) {
	out := new(user.UserSearchResult)
	err := c.cc.Invoke(ctx, "/header.UserMgr/SearchUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) PickToSegmentation(ctx context.Context, in *user.PickRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/PickToSegmentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) DeleteFromSegmentation(ctx context.Context, in *user.UnpickRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/DeleteFromSegmentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CreateUser(ctx context.Context, in *user.User, opts ...grpc.CallOption) (*common.Id, error) {
	out := new(common.Id)
	err := c.cc.Invoke(ctx, "/header.UserMgr/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) UpdateUser(ctx context.Context, in *user.User, opts ...grpc.CallOption) (*common.Id, error) {
	out := new(common.Id)
	err := c.cc.Invoke(ctx, "/header.UserMgr/UpdateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ReadUser(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.User, error) {
	out := new(user.User)
	err := c.cc.Invoke(ctx, "/header.UserMgr/ReadUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CountSegmentationUserByAttribute(ctx context.Context, in *user.CountSegmentationUserByAttributeRequest, opts ...grpc.CallOption) (*user.CountResponse, error) {
	out := new(user.CountResponse)
	err := c.cc.Invoke(ctx, "/header.UserMgr/CountSegmentationUserByAttribute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) CountTotal(ctx context.Context, in *user.CountTotalRequest, opts ...grpc.CallOption) (*user.CountTotalResponse, error) {
	out := new(user.CountTotalResponse)
	err := c.cc.Invoke(ctx, "/header.UserMgr/CountTotal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) Ping(ctx context.Context, in *common.PingRequest, opts ...grpc.CallOption) (*common.Pong, error) {
	out := new(common.Pong)
	err := c.cc.Invoke(ctx, "/header.UserMgr/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) AddAlias(ctx context.Context, in *user.Alias, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/AddAlias", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) MergeUsers(ctx context.Context, in *user.MergeRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/MergeUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ReadAllTopics(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/ReadAllTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) ExportUsers(ctx context.Context, in *user.UserExportRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.UserMgr/ExportUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMgrClient) SearchNote(ctx context.Context, in *user.SearchNoteRequest, opts ...grpc.CallOption) (*user.SearchNoteResponse, error) {
	out := new(user.SearchNoteResponse)
	err := c.cc.Invoke(ctx, "/header.UserMgr/SearchNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserMgrServer is the server API for UserMgr service.
type UserMgrServer interface {
	SearchUsers(context.Context, *user.UserSearchRequest) (*user.UserSearchResult, error)
	// rpc SubizID (SubizIDRequest) returns (SubizIDResponse);
	PickToSegmentation(context.Context, *user.PickRequest) (*common.Empty, error)
	DeleteFromSegmentation(context.Context, *user.UnpickRequest) (*common.Empty, error)
	CreateUser(context.Context, *user.User) (*common.Id, error)
	UpdateUser(context.Context, *user.User) (*common.Id, error)
	ReadUser(context.Context, *common.Id) (*user.User, error)
	CountSegmentationUserByAttribute(context.Context, *user.CountSegmentationUserByAttributeRequest) (*user.CountResponse, error)
	CountTotal(context.Context, *user.CountTotalRequest) (*user.CountTotalResponse, error)
	Ping(context.Context, *common.PingRequest) (*common.Pong, error)
	AddAlias(context.Context, *user.Alias) (*common.Empty, error)
	MergeUsers(context.Context, *user.MergeRequest) (*common.Empty, error)
	ReadAllTopics(context.Context, *common.Id) (*common.Empty, error)
	ExportUsers(context.Context, *user.UserExportRequest) (*common.Empty, error)
	SearchNote(context.Context, *user.SearchNoteRequest) (*user.SearchNoteResponse, error)
}

func RegisterUserMgrServer(s *grpc.Server, srv UserMgrServer) {
	s.RegisterService(&_UserMgr_serviceDesc, srv)
}

func _UserMgr_SearchUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.UserSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).SearchUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/SearchUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).SearchUsers(ctx, req.(*user.UserSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_PickToSegmentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.PickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).PickToSegmentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/PickToSegmentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).PickToSegmentation(ctx, req.(*user.PickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_DeleteFromSegmentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.UnpickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).DeleteFromSegmentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/DeleteFromSegmentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).DeleteFromSegmentation(ctx, req.(*user.UnpickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CreateUser(ctx, req.(*user.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).UpdateUser(ctx, req.(*user.User))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ReadUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ReadUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/ReadUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ReadUser(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CountSegmentationUserByAttribute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.CountSegmentationUserByAttributeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CountSegmentationUserByAttribute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/CountSegmentationUserByAttribute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CountSegmentationUserByAttribute(ctx, req.(*user.CountSegmentationUserByAttributeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_CountTotal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.CountTotalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).CountTotal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/CountTotal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).CountTotal(ctx, req.(*user.CountTotalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).Ping(ctx, req.(*common.PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_AddAlias_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.Alias)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).AddAlias(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/AddAlias",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).AddAlias(ctx, req.(*user.Alias))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_MergeUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.MergeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).MergeUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/MergeUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).MergeUsers(ctx, req.(*user.MergeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ReadAllTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ReadAllTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/ReadAllTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ReadAllTopics(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_ExportUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.UserExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).ExportUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/ExportUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).ExportUsers(ctx, req.(*user.UserExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMgr_SearchNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.SearchNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMgrServer).SearchNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.UserMgr/SearchNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMgrServer).SearchNote(ctx, req.(*user.SearchNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.UserMgr",
	HandlerType: (*UserMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchUsers",
			Handler:    _UserMgr_SearchUsers_Handler,
		},
		{
			MethodName: "PickToSegmentation",
			Handler:    _UserMgr_PickToSegmentation_Handler,
		},
		{
			MethodName: "DeleteFromSegmentation",
			Handler:    _UserMgr_DeleteFromSegmentation_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserMgr_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserMgr_UpdateUser_Handler,
		},
		{
			MethodName: "ReadUser",
			Handler:    _UserMgr_ReadUser_Handler,
		},
		{
			MethodName: "CountSegmentationUserByAttribute",
			Handler:    _UserMgr_CountSegmentationUserByAttribute_Handler,
		},
		{
			MethodName: "CountTotal",
			Handler:    _UserMgr_CountTotal_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _UserMgr_Ping_Handler,
		},
		{
			MethodName: "AddAlias",
			Handler:    _UserMgr_AddAlias_Handler,
		},
		{
			MethodName: "MergeUsers",
			Handler:    _UserMgr_MergeUsers_Handler,
		},
		{
			MethodName: "ReadAllTopics",
			Handler:    _UserMgr_ReadAllTopics_Handler,
		},
		{
			MethodName: "ExportUsers",
			Handler:    _UserMgr_ExportUsers_Handler,
		},
		{
			MethodName: "SearchNote",
			Handler:    _UserMgr_SearchNote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// VisitorMgrClient is the client API for VisitorMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VisitorMgrClient interface {
	ReadPresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error)
	UpdatePresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error)
	ReadPreview(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.LastView, error)
	ListTopVisitors(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Visitors, error)
}

type visitorMgrClient struct {
	cc *grpc.ClientConn
}

func NewVisitorMgrClient(cc *grpc.ClientConn) VisitorMgrClient {
	return &visitorMgrClient{cc}
}

func (c *visitorMgrClient) ReadPresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error) {
	out := new(user.Presence)
	err := c.cc.Invoke(ctx, "/header.VisitorMgr/ReadPresence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *visitorMgrClient) UpdatePresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error) {
	out := new(user.Presence)
	err := c.cc.Invoke(ctx, "/header.VisitorMgr/UpdatePresence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *visitorMgrClient) ReadPreview(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.LastView, error) {
	out := new(user.LastView)
	err := c.cc.Invoke(ctx, "/header.VisitorMgr/ReadPreview", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *visitorMgrClient) ListTopVisitors(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Visitors, error) {
	out := new(user.Visitors)
	err := c.cc.Invoke(ctx, "/header.VisitorMgr/ListTopVisitors", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VisitorMgrServer is the server API for VisitorMgr service.
type VisitorMgrServer interface {
	ReadPresence(context.Context, *common.Id) (*user.Presence, error)
	UpdatePresence(context.Context, *common.Id) (*user.Presence, error)
	ReadPreview(context.Context, *common.Id) (*user.LastView, error)
	ListTopVisitors(context.Context, *common.Id) (*user.Visitors, error)
}

func RegisterVisitorMgrServer(s *grpc.Server, srv VisitorMgrServer) {
	s.RegisterService(&_VisitorMgr_serviceDesc, srv)
}

func _VisitorMgr_ReadPresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisitorMgrServer).ReadPresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.VisitorMgr/ReadPresence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisitorMgrServer).ReadPresence(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _VisitorMgr_UpdatePresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisitorMgrServer).UpdatePresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.VisitorMgr/UpdatePresence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisitorMgrServer).UpdatePresence(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _VisitorMgr_ReadPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisitorMgrServer).ReadPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.VisitorMgr/ReadPreview",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisitorMgrServer).ReadPreview(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _VisitorMgr_ListTopVisitors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VisitorMgrServer).ListTopVisitors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.VisitorMgr/ListTopVisitors",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VisitorMgrServer).ListTopVisitors(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _VisitorMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.VisitorMgr",
	HandlerType: (*VisitorMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadPresence",
			Handler:    _VisitorMgr_ReadPresence_Handler,
		},
		{
			MethodName: "UpdatePresence",
			Handler:    _VisitorMgr_UpdatePresence_Handler,
		},
		{
			MethodName: "ReadPreview",
			Handler:    _VisitorMgr_ReadPreview_Handler,
		},
		{
			MethodName: "ListTopVisitors",
			Handler:    _VisitorMgr_ListTopVisitors_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AutomationCreditMgrClient is the client API for AutomationCreditMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutomationCreditMgrClient interface {
	GetAutomationCredit(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.AutomationCredit, error)
	AddAutomationCredit(ctx context.Context, in *event.AutomationCredit, opts ...grpc.CallOption) (*common.Empty, error)
}

type automationCreditMgrClient struct {
	cc *grpc.ClientConn
}

func NewAutomationCreditMgrClient(cc *grpc.ClientConn) AutomationCreditMgrClient {
	return &automationCreditMgrClient{cc}
}

func (c *automationCreditMgrClient) GetAutomationCredit(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.AutomationCredit, error) {
	out := new(event.AutomationCredit)
	err := c.cc.Invoke(ctx, "/header.AutomationCreditMgr/GetAutomationCredit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationCreditMgrClient) AddAutomationCredit(ctx context.Context, in *event.AutomationCredit, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AutomationCreditMgr/AddAutomationCredit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutomationCreditMgrServer is the server API for AutomationCreditMgr service.
type AutomationCreditMgrServer interface {
	GetAutomationCredit(context.Context, *common.Id) (*event.AutomationCredit, error)
	AddAutomationCredit(context.Context, *event.AutomationCredit) (*common.Empty, error)
}

func RegisterAutomationCreditMgrServer(s *grpc.Server, srv AutomationCreditMgrServer) {
	s.RegisterService(&_AutomationCreditMgr_serviceDesc, srv)
}

func _AutomationCreditMgr_GetAutomationCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationCreditMgrServer).GetAutomationCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationCreditMgr/GetAutomationCredit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationCreditMgrServer).GetAutomationCredit(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutomationCreditMgr_AddAutomationCredit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.AutomationCredit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationCreditMgrServer).AddAutomationCredit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationCreditMgr/AddAutomationCredit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationCreditMgrServer).AddAutomationCredit(ctx, req.(*event.AutomationCredit))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutomationCreditMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AutomationCreditMgr",
	HandlerType: (*AutomationCreditMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAutomationCredit",
			Handler:    _AutomationCreditMgr_GetAutomationCredit_Handler,
		},
		{
			MethodName: "AddAutomationCredit",
			Handler:    _AutomationCreditMgr_AddAutomationCredit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// NoteMgrClient is the client API for NoteMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NoteMgrClient interface {
	ListNotes(ctx context.Context, in *user.ListNotesRequest, opts ...grpc.CallOption) (*user.Notes, error)
	AddNote(ctx context.Context, in *user.Note, opts ...grpc.CallOption) (*user.Note, error)
	UpdateNote(ctx context.Context, in *user.Note, opts ...grpc.CallOption) (*user.Note, error)
	DeleteNote(ctx context.Context, in *user.DeleteNoteRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetNote(ctx context.Context, in *user.GetNoteRequest, opts ...grpc.CallOption) (*user.Note, error)
	SearchNote(ctx context.Context, in *user.SearchNoteRequest, opts ...grpc.CallOption) (*user.SearchNoteResponse, error)
}

type noteMgrClient struct {
	cc *grpc.ClientConn
}

func NewNoteMgrClient(cc *grpc.ClientConn) NoteMgrClient {
	return &noteMgrClient{cc}
}

func (c *noteMgrClient) ListNotes(ctx context.Context, in *user.ListNotesRequest, opts ...grpc.CallOption) (*user.Notes, error) {
	out := new(user.Notes)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/ListNotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) AddNote(ctx context.Context, in *user.Note, opts ...grpc.CallOption) (*user.Note, error) {
	out := new(user.Note)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/AddNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) UpdateNote(ctx context.Context, in *user.Note, opts ...grpc.CallOption) (*user.Note, error) {
	out := new(user.Note)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/UpdateNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) DeleteNote(ctx context.Context, in *user.DeleteNoteRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/DeleteNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) GetNote(ctx context.Context, in *user.GetNoteRequest, opts ...grpc.CallOption) (*user.Note, error) {
	out := new(user.Note)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/GetNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteMgrClient) SearchNote(ctx context.Context, in *user.SearchNoteRequest, opts ...grpc.CallOption) (*user.SearchNoteResponse, error) {
	out := new(user.SearchNoteResponse)
	err := c.cc.Invoke(ctx, "/header.NoteMgr/SearchNote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NoteMgrServer is the server API for NoteMgr service.
type NoteMgrServer interface {
	ListNotes(context.Context, *user.ListNotesRequest) (*user.Notes, error)
	AddNote(context.Context, *user.Note) (*user.Note, error)
	UpdateNote(context.Context, *user.Note) (*user.Note, error)
	DeleteNote(context.Context, *user.DeleteNoteRequest) (*common.Empty, error)
	GetNote(context.Context, *user.GetNoteRequest) (*user.Note, error)
	SearchNote(context.Context, *user.SearchNoteRequest) (*user.SearchNoteResponse, error)
}

func RegisterNoteMgrServer(s *grpc.Server, srv NoteMgrServer) {
	s.RegisterService(&_NoteMgr_serviceDesc, srv)
}

func _NoteMgr_ListNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.ListNotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).ListNotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/ListNotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).ListNotes(ctx, req.(*user.ListNotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_AddNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).AddNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/AddNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).AddNote(ctx, req.(*user.Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_UpdateNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.Note)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).UpdateNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/UpdateNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).UpdateNote(ctx, req.(*user.Note))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_DeleteNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.DeleteNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).DeleteNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/DeleteNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).DeleteNote(ctx, req.(*user.DeleteNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_GetNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.GetNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).GetNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/GetNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).GetNote(ctx, req.(*user.GetNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteMgr_SearchNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.SearchNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteMgrServer).SearchNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NoteMgr/SearchNote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteMgrServer).SearchNote(ctx, req.(*user.SearchNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NoteMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.NoteMgr",
	HandlerType: (*NoteMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListNotes",
			Handler:    _NoteMgr_ListNotes_Handler,
		},
		{
			MethodName: "AddNote",
			Handler:    _NoteMgr_AddNote_Handler,
		},
		{
			MethodName: "UpdateNote",
			Handler:    _NoteMgr_UpdateNote_Handler,
		},
		{
			MethodName: "DeleteNote",
			Handler:    _NoteMgr_DeleteNote_Handler,
		},
		{
			MethodName: "GetNote",
			Handler:    _NoteMgr_GetNote_Handler,
		},
		{
			MethodName: "SearchNote",
			Handler:    _NoteMgr_SearchNote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AutomationMgrClient is the client API for AutomationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AutomationMgrClient interface {
	ListAutomations(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.Automations, error)
	UpdateAutomation(ctx context.Context, in *event.Automation, opts ...grpc.CallOption) (*event.Automation, error)
	DeleteAutomation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ReadAutomation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.Automation, error)
	CreateAutomation(ctx context.Context, in *event.Automation, opts ...grpc.CallOption) (*event.Automation, error)
}

type automationMgrClient struct {
	cc *grpc.ClientConn
}

func NewAutomationMgrClient(cc *grpc.ClientConn) AutomationMgrClient {
	return &automationMgrClient{cc}
}

func (c *automationMgrClient) ListAutomations(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.Automations, error) {
	out := new(event.Automations)
	err := c.cc.Invoke(ctx, "/header.AutomationMgr/ListAutomations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationMgrClient) UpdateAutomation(ctx context.Context, in *event.Automation, opts ...grpc.CallOption) (*event.Automation, error) {
	out := new(event.Automation)
	err := c.cc.Invoke(ctx, "/header.AutomationMgr/UpdateAutomation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationMgrClient) DeleteAutomation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AutomationMgr/DeleteAutomation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationMgrClient) ReadAutomation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*event.Automation, error) {
	out := new(event.Automation)
	err := c.cc.Invoke(ctx, "/header.AutomationMgr/ReadAutomation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *automationMgrClient) CreateAutomation(ctx context.Context, in *event.Automation, opts ...grpc.CallOption) (*event.Automation, error) {
	out := new(event.Automation)
	err := c.cc.Invoke(ctx, "/header.AutomationMgr/CreateAutomation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutomationMgrServer is the server API for AutomationMgr service.
type AutomationMgrServer interface {
	ListAutomations(context.Context, *common.Id) (*event.Automations, error)
	UpdateAutomation(context.Context, *event.Automation) (*event.Automation, error)
	DeleteAutomation(context.Context, *common.Id) (*common.Empty, error)
	ReadAutomation(context.Context, *common.Id) (*event.Automation, error)
	CreateAutomation(context.Context, *event.Automation) (*event.Automation, error)
}

func RegisterAutomationMgrServer(s *grpc.Server, srv AutomationMgrServer) {
	s.RegisterService(&_AutomationMgr_serviceDesc, srv)
}

func _AutomationMgr_ListAutomations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationMgrServer).ListAutomations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationMgr/ListAutomations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationMgrServer).ListAutomations(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutomationMgr_UpdateAutomation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Automation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationMgrServer).UpdateAutomation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationMgr/UpdateAutomation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationMgrServer).UpdateAutomation(ctx, req.(*event.Automation))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutomationMgr_DeleteAutomation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationMgrServer).DeleteAutomation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationMgr/DeleteAutomation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationMgrServer).DeleteAutomation(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutomationMgr_ReadAutomation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationMgrServer).ReadAutomation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationMgr/ReadAutomation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationMgrServer).ReadAutomation(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutomationMgr_CreateAutomation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Automation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutomationMgrServer).CreateAutomation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AutomationMgr/CreateAutomation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutomationMgrServer).CreateAutomation(ctx, req.(*event.Automation))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutomationMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AutomationMgr",
	HandlerType: (*AutomationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAutomations",
			Handler:    _AutomationMgr_ListAutomations_Handler,
		},
		{
			MethodName: "UpdateAutomation",
			Handler:    _AutomationMgr_UpdateAutomation_Handler,
		},
		{
			MethodName: "DeleteAutomation",
			Handler:    _AutomationMgr_DeleteAutomation_Handler,
		},
		{
			MethodName: "ReadAutomation",
			Handler:    _AutomationMgr_ReadAutomation_Handler,
		},
		{
			MethodName: "CreateAutomation",
			Handler:    _AutomationMgr_CreateAutomation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AttributeMgrClient is the client API for AttributeMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AttributeMgrClient interface {
	ListAttributeDefinitions(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*user.AttributeDefinitions, error)
	CreateAttributeDefinition(ctx context.Context, in *user.AttributeDefinition, opts ...grpc.CallOption) (*user.AttributeDefinition, error)
	UpdateAttributeDefinition(ctx context.Context, in *user.AttributeDefinition, opts ...grpc.CallOption) (*user.AttributeDefinition, error)
	DeleteAttributeDefinition(ctx context.Context, in *user.DeleteAttrRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type attributeMgrClient struct {
	cc *grpc.ClientConn
}

func NewAttributeMgrClient(cc *grpc.ClientConn) AttributeMgrClient {
	return &attributeMgrClient{cc}
}

func (c *attributeMgrClient) ListAttributeDefinitions(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*user.AttributeDefinitions, error) {
	out := new(user.AttributeDefinitions)
	err := c.cc.Invoke(ctx, "/header.AttributeMgr/ListAttributeDefinitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) CreateAttributeDefinition(ctx context.Context, in *user.AttributeDefinition, opts ...grpc.CallOption) (*user.AttributeDefinition, error) {
	out := new(user.AttributeDefinition)
	err := c.cc.Invoke(ctx, "/header.AttributeMgr/CreateAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) UpdateAttributeDefinition(ctx context.Context, in *user.AttributeDefinition, opts ...grpc.CallOption) (*user.AttributeDefinition, error) {
	out := new(user.AttributeDefinition)
	err := c.cc.Invoke(ctx, "/header.AttributeMgr/UpdateAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *attributeMgrClient) DeleteAttributeDefinition(ctx context.Context, in *user.DeleteAttrRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.AttributeMgr/DeleteAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AttributeMgrServer is the server API for AttributeMgr service.
type AttributeMgrServer interface {
	ListAttributeDefinitions(context.Context, *common.Empty) (*user.AttributeDefinitions, error)
	CreateAttributeDefinition(context.Context, *user.AttributeDefinition) (*user.AttributeDefinition, error)
	UpdateAttributeDefinition(context.Context, *user.AttributeDefinition) (*user.AttributeDefinition, error)
	DeleteAttributeDefinition(context.Context, *user.DeleteAttrRequest) (*common.Empty, error)
}

func RegisterAttributeMgrServer(s *grpc.Server, srv AttributeMgrServer) {
	s.RegisterService(&_AttributeMgr_serviceDesc, srv)
}

func _AttributeMgr_ListAttributeDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).ListAttributeDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AttributeMgr/ListAttributeDefinitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).ListAttributeDefinitions(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_CreateAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.AttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).CreateAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AttributeMgr/CreateAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).CreateAttributeDefinition(ctx, req.(*user.AttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_UpdateAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.AttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).UpdateAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AttributeMgr/UpdateAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).UpdateAttributeDefinition(ctx, req.(*user.AttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _AttributeMgr_DeleteAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.DeleteAttrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AttributeMgrServer).DeleteAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AttributeMgr/DeleteAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AttributeMgrServer).DeleteAttributeDefinition(ctx, req.(*user.DeleteAttrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AttributeMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AttributeMgr",
	HandlerType: (*AttributeMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAttributeDefinitions",
			Handler:    _AttributeMgr_ListAttributeDefinitions_Handler,
		},
		{
			MethodName: "CreateAttributeDefinition",
			Handler:    _AttributeMgr_CreateAttributeDefinition_Handler,
		},
		{
			MethodName: "UpdateAttributeDefinition",
			Handler:    _AttributeMgr_UpdateAttributeDefinition_Handler,
		},
		{
			MethodName: "DeleteAttributeDefinition",
			Handler:    _AttributeMgr_DeleteAttributeDefinition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// SegmentationMgrClient is the client API for SegmentationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SegmentationMgrClient interface {
	CreateSegment(ctx context.Context, in *user.Segmentation, opts ...grpc.CallOption) (*user.Segmentation, error)
	UpdateSegment(ctx context.Context, in *user.Segmentation, opts ...grpc.CallOption) (*user.Segmentation, error)
	ListSegments(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Segmentations, error)
	DeleteSegment(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ReadSegment(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Segmentation, error)
}

type segmentationMgrClient struct {
	cc *grpc.ClientConn
}

func NewSegmentationMgrClient(cc *grpc.ClientConn) SegmentationMgrClient {
	return &segmentationMgrClient{cc}
}

func (c *segmentationMgrClient) CreateSegment(ctx context.Context, in *user.Segmentation, opts ...grpc.CallOption) (*user.Segmentation, error) {
	out := new(user.Segmentation)
	err := c.cc.Invoke(ctx, "/header.SegmentationMgr/CreateSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentationMgrClient) UpdateSegment(ctx context.Context, in *user.Segmentation, opts ...grpc.CallOption) (*user.Segmentation, error) {
	out := new(user.Segmentation)
	err := c.cc.Invoke(ctx, "/header.SegmentationMgr/UpdateSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentationMgrClient) ListSegments(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Segmentations, error) {
	out := new(user.Segmentations)
	err := c.cc.Invoke(ctx, "/header.SegmentationMgr/ListSegments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentationMgrClient) DeleteSegment(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.SegmentationMgr/DeleteSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *segmentationMgrClient) ReadSegment(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Segmentation, error) {
	out := new(user.Segmentation)
	err := c.cc.Invoke(ctx, "/header.SegmentationMgr/ReadSegment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SegmentationMgrServer is the server API for SegmentationMgr service.
type SegmentationMgrServer interface {
	CreateSegment(context.Context, *user.Segmentation) (*user.Segmentation, error)
	UpdateSegment(context.Context, *user.Segmentation) (*user.Segmentation, error)
	ListSegments(context.Context, *common.Id) (*user.Segmentations, error)
	DeleteSegment(context.Context, *common.Id) (*common.Empty, error)
	ReadSegment(context.Context, *common.Id) (*user.Segmentation, error)
}

func RegisterSegmentationMgrServer(s *grpc.Server, srv SegmentationMgrServer) {
	s.RegisterService(&_SegmentationMgr_serviceDesc, srv)
}

func _SegmentationMgr_CreateSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.Segmentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentationMgrServer).CreateSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SegmentationMgr/CreateSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentationMgrServer).CreateSegment(ctx, req.(*user.Segmentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentationMgr_UpdateSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.Segmentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentationMgrServer).UpdateSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SegmentationMgr/UpdateSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentationMgrServer).UpdateSegment(ctx, req.(*user.Segmentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentationMgr_ListSegments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentationMgrServer).ListSegments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SegmentationMgr/ListSegments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentationMgrServer).ListSegments(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentationMgr_DeleteSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentationMgrServer).DeleteSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SegmentationMgr/DeleteSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentationMgrServer).DeleteSegment(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _SegmentationMgr_ReadSegment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SegmentationMgrServer).ReadSegment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SegmentationMgr/ReadSegment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SegmentationMgrServer).ReadSegment(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _SegmentationMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.SegmentationMgr",
	HandlerType: (*SegmentationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSegment",
			Handler:    _SegmentationMgr_CreateSegment_Handler,
		},
		{
			MethodName: "UpdateSegment",
			Handler:    _SegmentationMgr_UpdateSegment_Handler,
		},
		{
			MethodName: "ListSegments",
			Handler:    _SegmentationMgr_ListSegments_Handler,
		},
		{
			MethodName: "DeleteSegment",
			Handler:    _SegmentationMgr_DeleteSegment_Handler,
		},
		{
			MethodName: "ReadSegment",
			Handler:    _SegmentationMgr_ReadSegment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// PermClient is the client API for Perm service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PermClient interface {
	Update(ctx context.Context, in *common.UpdatePermRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UpdateState(ctx context.Context, in *common.UpdateStateRequest, opts ...grpc.CallOption) (*common.Empty, error)
	ReadPerm(ctx context.Context, in *common.ReadPermRequest, opts ...grpc.CallOption) (*common.Permission, error)
}

type permClient struct {
	cc *grpc.ClientConn
}

func NewPermClient(cc *grpc.ClientConn) PermClient {
	return &permClient{cc}
}

func (c *permClient) Update(ctx context.Context, in *common.UpdatePermRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Perm/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permClient) UpdateState(ctx context.Context, in *common.UpdateStateRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Perm/UpdateState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *permClient) ReadPerm(ctx context.Context, in *common.ReadPermRequest, opts ...grpc.CallOption) (*common.Permission, error) {
	out := new(common.Permission)
	err := c.cc.Invoke(ctx, "/header.Perm/ReadPerm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PermServer is the server API for Perm service.
type PermServer interface {
	Update(context.Context, *common.UpdatePermRequest) (*common.Empty, error)
	UpdateState(context.Context, *common.UpdateStateRequest) (*common.Empty, error)
	ReadPerm(context.Context, *common.ReadPermRequest) (*common.Permission, error)
}

func RegisterPermServer(s *grpc.Server, srv PermServer) {
	s.RegisterService(&_Perm_serviceDesc, srv)
}

func _Perm_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.UpdatePermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Perm/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermServer).Update(ctx, req.(*common.UpdatePermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Perm_UpdateState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.UpdateStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermServer).UpdateState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Perm/UpdateState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermServer).UpdateState(ctx, req.(*common.UpdateStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Perm_ReadPerm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ReadPermRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PermServer).ReadPerm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Perm/ReadPerm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PermServer).ReadPerm(ctx, req.(*common.ReadPermRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Perm_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Perm",
	HandlerType: (*PermServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _Perm_Update_Handler,
		},
		{
			MethodName: "UpdateState",
			Handler:    _Perm_UpdateState_Handler,
		},
		{
			MethodName: "ReadPerm",
			Handler:    _Perm_ReadPerm_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ConversationReporterClient is the client API for ConversationReporter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConversationReporterClient interface {
	CountConversationsByTags(ctx context.Context, in *conversation.CountByTagsRequest, opts ...grpc.CallOption) (*conversation.CountByTagsResponse, error)
	GetAvgResponseTimes(ctx context.Context, in *conversation.AvgResponseTimeRequest, opts ...grpc.CallOption) (*conversation.AvgResponseTimeResponse, error)
	GetTotalConversation(ctx context.Context, in *conversation.AvgResponseTimeRequest, opts ...grpc.CallOption) (*conversation.TotalConversationResponse, error)
	ReportConversations(ctx context.Context, in *conversation.CountReportRequest, opts ...grpc.CallOption) (*conversation.ReportResponse, error)
	ReportAvailibilities(ctx context.Context, in *conversation.AvailibilityReportRequest, opts ...grpc.CallOption) (*conversation.ReportResponse, error)
}

type conversationReporterClient struct {
	cc *grpc.ClientConn
}

func NewConversationReporterClient(cc *grpc.ClientConn) ConversationReporterClient {
	return &conversationReporterClient{cc}
}

func (c *conversationReporterClient) CountConversationsByTags(ctx context.Context, in *conversation.CountByTagsRequest, opts ...grpc.CallOption) (*conversation.CountByTagsResponse, error) {
	out := new(conversation.CountByTagsResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationReporter/CountConversationsByTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationReporterClient) GetAvgResponseTimes(ctx context.Context, in *conversation.AvgResponseTimeRequest, opts ...grpc.CallOption) (*conversation.AvgResponseTimeResponse, error) {
	out := new(conversation.AvgResponseTimeResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationReporter/GetAvgResponseTimes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationReporterClient) GetTotalConversation(ctx context.Context, in *conversation.AvgResponseTimeRequest, opts ...grpc.CallOption) (*conversation.TotalConversationResponse, error) {
	out := new(conversation.TotalConversationResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationReporter/GetTotalConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationReporterClient) ReportConversations(ctx context.Context, in *conversation.CountReportRequest, opts ...grpc.CallOption) (*conversation.ReportResponse, error) {
	out := new(conversation.ReportResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationReporter/ReportConversations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationReporterClient) ReportAvailibilities(ctx context.Context, in *conversation.AvailibilityReportRequest, opts ...grpc.CallOption) (*conversation.ReportResponse, error) {
	out := new(conversation.ReportResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationReporter/ReportAvailibilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationReporterServer is the server API for ConversationReporter service.
type ConversationReporterServer interface {
	CountConversationsByTags(context.Context, *conversation.CountByTagsRequest) (*conversation.CountByTagsResponse, error)
	GetAvgResponseTimes(context.Context, *conversation.AvgResponseTimeRequest) (*conversation.AvgResponseTimeResponse, error)
	GetTotalConversation(context.Context, *conversation.AvgResponseTimeRequest) (*conversation.TotalConversationResponse, error)
	ReportConversations(context.Context, *conversation.CountReportRequest) (*conversation.ReportResponse, error)
	ReportAvailibilities(context.Context, *conversation.AvailibilityReportRequest) (*conversation.ReportResponse, error)
}

func RegisterConversationReporterServer(s *grpc.Server, srv ConversationReporterServer) {
	s.RegisterService(&_ConversationReporter_serviceDesc, srv)
}

func _ConversationReporter_CountConversationsByTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.CountByTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationReporterServer).CountConversationsByTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationReporter/CountConversationsByTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationReporterServer).CountConversationsByTags(ctx, req.(*conversation.CountByTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationReporter_GetAvgResponseTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.AvgResponseTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationReporterServer).GetAvgResponseTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationReporter/GetAvgResponseTimes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationReporterServer).GetAvgResponseTimes(ctx, req.(*conversation.AvgResponseTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationReporter_GetTotalConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.AvgResponseTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationReporterServer).GetTotalConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationReporter/GetTotalConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationReporterServer).GetTotalConversation(ctx, req.(*conversation.AvgResponseTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationReporter_ReportConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.CountReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationReporterServer).ReportConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationReporter/ReportConversations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationReporterServer).ReportConversations(ctx, req.(*conversation.CountReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationReporter_ReportAvailibilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.AvailibilityReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationReporterServer).ReportAvailibilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationReporter/ReportAvailibilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationReporterServer).ReportAvailibilities(ctx, req.(*conversation.AvailibilityReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConversationReporter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ConversationReporter",
	HandlerType: (*ConversationReporterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CountConversationsByTags",
			Handler:    _ConversationReporter_CountConversationsByTags_Handler,
		},
		{
			MethodName: "GetAvgResponseTimes",
			Handler:    _ConversationReporter_GetAvgResponseTimes_Handler,
		},
		{
			MethodName: "GetTotalConversation",
			Handler:    _ConversationReporter_GetTotalConversation_Handler,
		},
		{
			MethodName: "ReportConversations",
			Handler:    _ConversationReporter_ReportConversations_Handler,
		},
		{
			MethodName: "ReportAvailibilities",
			Handler:    _ConversationReporter_ReportAvailibilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// AgentPresenceMgrClient is the client API for AgentPresenceMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AgentPresenceMgrClient interface {
	ReadPresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error)
	UpdatePresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error)
}

type agentPresenceMgrClient struct {
	cc *grpc.ClientConn
}

func NewAgentPresenceMgrClient(cc *grpc.ClientConn) AgentPresenceMgrClient {
	return &agentPresenceMgrClient{cc}
}

func (c *agentPresenceMgrClient) ReadPresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error) {
	out := new(user.Presence)
	err := c.cc.Invoke(ctx, "/header.AgentPresenceMgr/ReadPresence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentPresenceMgrClient) UpdatePresence(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*user.Presence, error) {
	out := new(user.Presence)
	err := c.cc.Invoke(ctx, "/header.AgentPresenceMgr/UpdatePresence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentPresenceMgrServer is the server API for AgentPresenceMgr service.
type AgentPresenceMgrServer interface {
	ReadPresence(context.Context, *common.Id) (*user.Presence, error)
	UpdatePresence(context.Context, *common.Id) (*user.Presence, error)
}

func RegisterAgentPresenceMgrServer(s *grpc.Server, srv AgentPresenceMgrServer) {
	s.RegisterService(&_AgentPresenceMgr_serviceDesc, srv)
}

func _AgentPresenceMgr_ReadPresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentPresenceMgrServer).ReadPresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AgentPresenceMgr/ReadPresence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentPresenceMgrServer).ReadPresence(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentPresenceMgr_UpdatePresence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentPresenceMgrServer).UpdatePresence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.AgentPresenceMgr/UpdatePresence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentPresenceMgrServer).UpdatePresence(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _AgentPresenceMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.AgentPresenceMgr",
	HandlerType: (*AgentPresenceMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadPresence",
			Handler:    _AgentPresenceMgr_ReadPresence_Handler,
		},
		{
			MethodName: "UpdatePresence",
			Handler:    _AgentPresenceMgr_UpdatePresence_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// RuleMgrClient is the client API for RuleMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RuleMgrClient interface {
	UpdateRule(ctx context.Context, in *conversation.Rule, opts ...grpc.CallOption) (*conversation.Rule, error)
	CreateRule(ctx context.Context, in *conversation.Rule, opts ...grpc.CallOption) (*conversation.Rule, error)
	DeleteRule(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ReadRule(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Rule, error)
	ListRules(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Route, error)
}

type ruleMgrClient struct {
	cc *grpc.ClientConn
}

func NewRuleMgrClient(cc *grpc.ClientConn) RuleMgrClient {
	return &ruleMgrClient{cc}
}

func (c *ruleMgrClient) UpdateRule(ctx context.Context, in *conversation.Rule, opts ...grpc.CallOption) (*conversation.Rule, error) {
	out := new(conversation.Rule)
	err := c.cc.Invoke(ctx, "/header.RuleMgr/UpdateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ruleMgrClient) CreateRule(ctx context.Context, in *conversation.Rule, opts ...grpc.CallOption) (*conversation.Rule, error) {
	out := new(conversation.Rule)
	err := c.cc.Invoke(ctx, "/header.RuleMgr/CreateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ruleMgrClient) DeleteRule(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.RuleMgr/DeleteRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ruleMgrClient) ReadRule(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Rule, error) {
	out := new(conversation.Rule)
	err := c.cc.Invoke(ctx, "/header.RuleMgr/ReadRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ruleMgrClient) ListRules(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Route, error) {
	out := new(conversation.Route)
	err := c.cc.Invoke(ctx, "/header.RuleMgr/ListRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RuleMgrServer is the server API for RuleMgr service.
type RuleMgrServer interface {
	UpdateRule(context.Context, *conversation.Rule) (*conversation.Rule, error)
	CreateRule(context.Context, *conversation.Rule) (*conversation.Rule, error)
	DeleteRule(context.Context, *common.Id) (*common.Empty, error)
	ReadRule(context.Context, *common.Id) (*conversation.Rule, error)
	ListRules(context.Context, *common.Id) (*conversation.Route, error)
}

func RegisterRuleMgrServer(s *grpc.Server, srv RuleMgrServer) {
	s.RegisterService(&_RuleMgr_serviceDesc, srv)
}

func _RuleMgr_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuleMgrServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.RuleMgr/UpdateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuleMgrServer).UpdateRule(ctx, req.(*conversation.Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuleMgr_CreateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuleMgrServer).CreateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.RuleMgr/CreateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuleMgrServer).CreateRule(ctx, req.(*conversation.Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuleMgr_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuleMgrServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.RuleMgr/DeleteRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuleMgrServer).DeleteRule(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuleMgr_ReadRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuleMgrServer).ReadRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.RuleMgr/ReadRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuleMgrServer).ReadRule(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuleMgr_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuleMgrServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.RuleMgr/ListRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuleMgrServer).ListRules(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _RuleMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.RuleMgr",
	HandlerType: (*RuleMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateRule",
			Handler:    _RuleMgr_UpdateRule_Handler,
		},
		{
			MethodName: "CreateRule",
			Handler:    _RuleMgr_CreateRule_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _RuleMgr_DeleteRule_Handler,
		},
		{
			MethodName: "ReadRule",
			Handler:    _RuleMgr_ReadRule_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _RuleMgr_ListRules_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ConversationMgrClient is the client API for ConversationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConversationMgrClient interface {
	PongMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error)
	// rpc UpdateConversationState(Conversation) returns (Conversation);
	StartConversation(ctx context.Context, in *conversation.StartRequest, opts ...grpc.CallOption) (*conversation.Conversation, error)
	EndConversation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Conversation, error)
	GetConversation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Conversation, error)
	ListConversations(ctx context.Context, in *conversation.ListConversationsRequest, opts ...grpc.CallOption) (*conversation.Conversations, error)
	TagConversation(ctx context.Context, in *conversation.TagRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UntagConversation(ctx context.Context, in *conversation.TagRequest, opts ...grpc.CallOption) (*common.Empty, error)
	JoinConversation(ctx context.Context, in *conversation.Member, opts ...grpc.CallOption) (*common.Empty, error)
	LeftConversation(ctx context.Context, in *conversation.Member, opts ...grpc.CallOption) (*common.Empty, error)
	Typing(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	Ping(ctx context.Context, in *common.PingRequest, opts ...grpc.CallOption) (*common.Pong, error)
	QueryByObjectPath(ctx context.Context, in *common.ObjectPathRequest, opts ...grpc.CallOption) (*common.Ids, error)
	UpdateConversationInfo(ctx context.Context, in *conversation.Conversation, opts ...grpc.CallOption) (*conversation.Conversation, error)
	FilterUser(ctx context.Context, in *conversation.FilterUserRequest, opts ...grpc.CallOption) (*conversation.FilterUserResponse, error)
	SearchConversation(ctx context.Context, in *conversation.SearchConversationRequest, opts ...grpc.CallOption) (*conversation.SearchConversationResponse, error)
}

type conversationMgrClient struct {
	cc *grpc.ClientConn
}

func NewConversationMgrClient(cc *grpc.ClientConn) ConversationMgrClient {
	return &conversationMgrClient{cc}
}

func (c *conversationMgrClient) PongMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error) {
	out := new(event.Event)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/PongMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) StartConversation(ctx context.Context, in *conversation.StartRequest, opts ...grpc.CallOption) (*conversation.Conversation, error) {
	out := new(conversation.Conversation)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/StartConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) EndConversation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Conversation, error) {
	out := new(conversation.Conversation)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/EndConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) GetConversation(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Conversation, error) {
	out := new(conversation.Conversation)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/GetConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) ListConversations(ctx context.Context, in *conversation.ListConversationsRequest, opts ...grpc.CallOption) (*conversation.Conversations, error) {
	out := new(conversation.Conversations)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/ListConversations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) TagConversation(ctx context.Context, in *conversation.TagRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/TagConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UntagConversation(ctx context.Context, in *conversation.TagRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/UntagConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) JoinConversation(ctx context.Context, in *conversation.Member, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/JoinConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) LeftConversation(ctx context.Context, in *conversation.Member, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/LeftConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) Typing(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/Typing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) Ping(ctx context.Context, in *common.PingRequest, opts ...grpc.CallOption) (*common.Pong, error) {
	out := new(common.Pong)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) QueryByObjectPath(ctx context.Context, in *common.ObjectPathRequest, opts ...grpc.CallOption) (*common.Ids, error) {
	out := new(common.Ids)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/QueryByObjectPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) UpdateConversationInfo(ctx context.Context, in *conversation.Conversation, opts ...grpc.CallOption) (*conversation.Conversation, error) {
	out := new(conversation.Conversation)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/UpdateConversationInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) FilterUser(ctx context.Context, in *conversation.FilterUserRequest, opts ...grpc.CallOption) (*conversation.FilterUserResponse, error) {
	out := new(conversation.FilterUserResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/FilterUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationMgrClient) SearchConversation(ctx context.Context, in *conversation.SearchConversationRequest, opts ...grpc.CallOption) (*conversation.SearchConversationResponse, error) {
	out := new(conversation.SearchConversationResponse)
	err := c.cc.Invoke(ctx, "/header.ConversationMgr/SearchConversation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationMgrServer is the server API for ConversationMgr service.
type ConversationMgrServer interface {
	PongMessage(context.Context, *event.Event) (*event.Event, error)
	// rpc UpdateConversationState(Conversation) returns (Conversation);
	StartConversation(context.Context, *conversation.StartRequest) (*conversation.Conversation, error)
	EndConversation(context.Context, *common.Id) (*conversation.Conversation, error)
	GetConversation(context.Context, *common.Id) (*conversation.Conversation, error)
	ListConversations(context.Context, *conversation.ListConversationsRequest) (*conversation.Conversations, error)
	TagConversation(context.Context, *conversation.TagRequest) (*common.Empty, error)
	UntagConversation(context.Context, *conversation.TagRequest) (*common.Empty, error)
	JoinConversation(context.Context, *conversation.Member) (*common.Empty, error)
	LeftConversation(context.Context, *conversation.Member) (*common.Empty, error)
	Typing(context.Context, *common.Id) (*common.Empty, error)
	Ping(context.Context, *common.PingRequest) (*common.Pong, error)
	QueryByObjectPath(context.Context, *common.ObjectPathRequest) (*common.Ids, error)
	UpdateConversationInfo(context.Context, *conversation.Conversation) (*conversation.Conversation, error)
	FilterUser(context.Context, *conversation.FilterUserRequest) (*conversation.FilterUserResponse, error)
	SearchConversation(context.Context, *conversation.SearchConversationRequest) (*conversation.SearchConversationResponse, error)
}

func RegisterConversationMgrServer(s *grpc.Server, srv ConversationMgrServer) {
	s.RegisterService(&_ConversationMgr_serviceDesc, srv)
}

func _ConversationMgr_PongMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).PongMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/PongMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).PongMessage(ctx, req.(*event.Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_StartConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).StartConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/StartConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).StartConversation(ctx, req.(*conversation.StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_EndConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).EndConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/EndConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).EndConversation(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_GetConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).GetConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/GetConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).GetConversation(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_ListConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).ListConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/ListConversations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).ListConversations(ctx, req.(*conversation.ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_TagConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).TagConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/TagConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).TagConversation(ctx, req.(*conversation.TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UntagConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UntagConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/UntagConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UntagConversation(ctx, req.(*conversation.TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_JoinConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Member)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).JoinConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/JoinConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).JoinConversation(ctx, req.(*conversation.Member))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_LeftConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Member)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).LeftConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/LeftConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).LeftConversation(ctx, req.(*conversation.Member))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_Typing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).Typing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/Typing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).Typing(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).Ping(ctx, req.(*common.PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_QueryByObjectPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.ObjectPathRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).QueryByObjectPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/QueryByObjectPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).QueryByObjectPath(ctx, req.(*common.ObjectPathRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_UpdateConversationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Conversation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).UpdateConversationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/UpdateConversationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).UpdateConversationInfo(ctx, req.(*conversation.Conversation))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_FilterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.FilterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).FilterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/FilterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).FilterUser(ctx, req.(*conversation.FilterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationMgr_SearchConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.SearchConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationMgrServer).SearchConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationMgr/SearchConversation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationMgrServer).SearchConversation(ctx, req.(*conversation.SearchConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConversationMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ConversationMgr",
	HandlerType: (*ConversationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PongMessage",
			Handler:    _ConversationMgr_PongMessage_Handler,
		},
		{
			MethodName: "StartConversation",
			Handler:    _ConversationMgr_StartConversation_Handler,
		},
		{
			MethodName: "EndConversation",
			Handler:    _ConversationMgr_EndConversation_Handler,
		},
		{
			MethodName: "GetConversation",
			Handler:    _ConversationMgr_GetConversation_Handler,
		},
		{
			MethodName: "ListConversations",
			Handler:    _ConversationMgr_ListConversations_Handler,
		},
		{
			MethodName: "TagConversation",
			Handler:    _ConversationMgr_TagConversation_Handler,
		},
		{
			MethodName: "UntagConversation",
			Handler:    _ConversationMgr_UntagConversation_Handler,
		},
		{
			MethodName: "JoinConversation",
			Handler:    _ConversationMgr_JoinConversation_Handler,
		},
		{
			MethodName: "LeftConversation",
			Handler:    _ConversationMgr_LeftConversation_Handler,
		},
		{
			MethodName: "Typing",
			Handler:    _ConversationMgr_Typing_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _ConversationMgr_Ping_Handler,
		},
		{
			MethodName: "QueryByObjectPath",
			Handler:    _ConversationMgr_QueryByObjectPath_Handler,
		},
		{
			MethodName: "UpdateConversationInfo",
			Handler:    _ConversationMgr_UpdateConversationInfo_Handler,
		},
		{
			MethodName: "FilterUser",
			Handler:    _ConversationMgr_FilterUser_Handler,
		},
		{
			MethodName: "SearchConversation",
			Handler:    _ConversationMgr_SearchConversation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// TemplateMgrClient is the client API for TemplateMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TemplateMgrClient interface {
	CreateTemplate(ctx context.Context, in *conversation.Template, opts ...grpc.CallOption) (*conversation.Template, error)
	UpdateTemplate(ctx context.Context, in *conversation.Template, opts ...grpc.CallOption) (*conversation.Template, error)
	DeleteTemplate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	GetTemplate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Template, error)
	ListTemplates(ctx context.Context, in *conversation.SearchTemplate, opts ...grpc.CallOption) (*conversation.Templates, error)
}

type templateMgrClient struct {
	cc *grpc.ClientConn
}

func NewTemplateMgrClient(cc *grpc.ClientConn) TemplateMgrClient {
	return &templateMgrClient{cc}
}

func (c *templateMgrClient) CreateTemplate(ctx context.Context, in *conversation.Template, opts ...grpc.CallOption) (*conversation.Template, error) {
	out := new(conversation.Template)
	err := c.cc.Invoke(ctx, "/header.TemplateMgr/CreateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) UpdateTemplate(ctx context.Context, in *conversation.Template, opts ...grpc.CallOption) (*conversation.Template, error) {
	out := new(conversation.Template)
	err := c.cc.Invoke(ctx, "/header.TemplateMgr/UpdateTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) DeleteTemplate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.TemplateMgr/DeleteTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) GetTemplate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Template, error) {
	out := new(conversation.Template)
	err := c.cc.Invoke(ctx, "/header.TemplateMgr/GetTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *templateMgrClient) ListTemplates(ctx context.Context, in *conversation.SearchTemplate, opts ...grpc.CallOption) (*conversation.Templates, error) {
	out := new(conversation.Templates)
	err := c.cc.Invoke(ctx, "/header.TemplateMgr/ListTemplates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TemplateMgrServer is the server API for TemplateMgr service.
type TemplateMgrServer interface {
	CreateTemplate(context.Context, *conversation.Template) (*conversation.Template, error)
	UpdateTemplate(context.Context, *conversation.Template) (*conversation.Template, error)
	DeleteTemplate(context.Context, *common.Id) (*common.Empty, error)
	GetTemplate(context.Context, *common.Id) (*conversation.Template, error)
	ListTemplates(context.Context, *conversation.SearchTemplate) (*conversation.Templates, error)
}

func RegisterTemplateMgrServer(s *grpc.Server, srv TemplateMgrServer) {
	s.RegisterService(&_TemplateMgr_serviceDesc, srv)
}

func _TemplateMgr_CreateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Template)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).CreateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TemplateMgr/CreateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).CreateTemplate(ctx, req.(*conversation.Template))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_UpdateTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Template)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).UpdateTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TemplateMgr/UpdateTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).UpdateTemplate(ctx, req.(*conversation.Template))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_DeleteTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).DeleteTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TemplateMgr/DeleteTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).DeleteTemplate(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_GetTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).GetTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TemplateMgr/GetTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).GetTemplate(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TemplateMgr_ListTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.SearchTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TemplateMgrServer).ListTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TemplateMgr/ListTemplates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TemplateMgrServer).ListTemplates(ctx, req.(*conversation.SearchTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

var _TemplateMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.TemplateMgr",
	HandlerType: (*TemplateMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTemplate",
			Handler:    _TemplateMgr_CreateTemplate_Handler,
		},
		{
			MethodName: "UpdateTemplate",
			Handler:    _TemplateMgr_UpdateTemplate_Handler,
		},
		{
			MethodName: "DeleteTemplate",
			Handler:    _TemplateMgr_DeleteTemplate_Handler,
		},
		{
			MethodName: "GetTemplate",
			Handler:    _TemplateMgr_GetTemplate_Handler,
		},
		{
			MethodName: "ListTemplates",
			Handler:    _TemplateMgr_ListTemplates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// TagMgrClient is the client API for TagMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TagMgrClient interface {
	CreateTag(ctx context.Context, in *conversation.Tag, opts ...grpc.CallOption) (*conversation.Tag, error)
	UpdateTag(ctx context.Context, in *conversation.Tag, opts ...grpc.CallOption) (*conversation.Tag, error)
	DeleteTag(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ListTags(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Tags, error)
	GetTag(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Tag, error)
}

type tagMgrClient struct {
	cc *grpc.ClientConn
}

func NewTagMgrClient(cc *grpc.ClientConn) TagMgrClient {
	return &tagMgrClient{cc}
}

func (c *tagMgrClient) CreateTag(ctx context.Context, in *conversation.Tag, opts ...grpc.CallOption) (*conversation.Tag, error) {
	out := new(conversation.Tag)
	err := c.cc.Invoke(ctx, "/header.TagMgr/CreateTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) UpdateTag(ctx context.Context, in *conversation.Tag, opts ...grpc.CallOption) (*conversation.Tag, error) {
	out := new(conversation.Tag)
	err := c.cc.Invoke(ctx, "/header.TagMgr/UpdateTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) DeleteTag(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.TagMgr/DeleteTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) ListTags(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Tags, error) {
	out := new(conversation.Tags)
	err := c.cc.Invoke(ctx, "/header.TagMgr/ListTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagMgrClient) GetTag(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Tag, error) {
	out := new(conversation.Tag)
	err := c.cc.Invoke(ctx, "/header.TagMgr/GetTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagMgrServer is the server API for TagMgr service.
type TagMgrServer interface {
	CreateTag(context.Context, *conversation.Tag) (*conversation.Tag, error)
	UpdateTag(context.Context, *conversation.Tag) (*conversation.Tag, error)
	DeleteTag(context.Context, *common.Id) (*common.Empty, error)
	ListTags(context.Context, *common.Id) (*conversation.Tags, error)
	GetTag(context.Context, *common.Id) (*conversation.Tag, error)
}

func RegisterTagMgrServer(s *grpc.Server, srv TagMgrServer) {
	s.RegisterService(&_TagMgr_serviceDesc, srv)
}

func _TagMgr_CreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).CreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TagMgr/CreateTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).CreateTag(ctx, req.(*conversation.Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_UpdateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).UpdateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TagMgr/UpdateTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).UpdateTag(ctx, req.(*conversation.Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_DeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).DeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TagMgr/DeleteTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).DeleteTag(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).ListTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TagMgr/ListTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).ListTags(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagMgr_GetTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagMgrServer).GetTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TagMgr/GetTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagMgrServer).GetTag(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _TagMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.TagMgr",
	HandlerType: (*TagMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTag",
			Handler:    _TagMgr_CreateTag_Handler,
		},
		{
			MethodName: "UpdateTag",
			Handler:    _TagMgr_UpdateTag_Handler,
		},
		{
			MethodName: "DeleteTag",
			Handler:    _TagMgr_DeleteTag_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _TagMgr_ListTags_Handler,
		},
		{
			MethodName: "GetTag",
			Handler:    _TagMgr_GetTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// IntegrationMgrClient is the client API for IntegrationMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IntegrationMgrClient interface {
	Deintegrate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ListIntegrations(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Integrations, error)
	Integrate(ctx context.Context, in *conversation.Integration, opts ...grpc.CallOption) (*conversation.Integration, error)
	CheckAvailability(ctx context.Context, in *conversation.AvailabilityCheckRequest, opts ...grpc.CallOption) (*conversation.AvailabilityCheckResult, error)
}

type integrationMgrClient struct {
	cc *grpc.ClientConn
}

func NewIntegrationMgrClient(cc *grpc.ClientConn) IntegrationMgrClient {
	return &integrationMgrClient{cc}
}

func (c *integrationMgrClient) Deintegrate(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.IntegrationMgr/Deintegrate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationMgrClient) ListIntegrations(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.Integrations, error) {
	out := new(conversation.Integrations)
	err := c.cc.Invoke(ctx, "/header.IntegrationMgr/ListIntegrations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationMgrClient) Integrate(ctx context.Context, in *conversation.Integration, opts ...grpc.CallOption) (*conversation.Integration, error) {
	out := new(conversation.Integration)
	err := c.cc.Invoke(ctx, "/header.IntegrationMgr/Integrate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationMgrClient) CheckAvailability(ctx context.Context, in *conversation.AvailabilityCheckRequest, opts ...grpc.CallOption) (*conversation.AvailabilityCheckResult, error) {
	out := new(conversation.AvailabilityCheckResult)
	err := c.cc.Invoke(ctx, "/header.IntegrationMgr/CheckAvailability", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntegrationMgrServer is the server API for IntegrationMgr service.
type IntegrationMgrServer interface {
	Deintegrate(context.Context, *common.Id) (*common.Empty, error)
	ListIntegrations(context.Context, *common.Id) (*conversation.Integrations, error)
	Integrate(context.Context, *conversation.Integration) (*conversation.Integration, error)
	CheckAvailability(context.Context, *conversation.AvailabilityCheckRequest) (*conversation.AvailabilityCheckResult, error)
}

func RegisterIntegrationMgrServer(s *grpc.Server, srv IntegrationMgrServer) {
	s.RegisterService(&_IntegrationMgr_serviceDesc, srv)
}

func _IntegrationMgr_Deintegrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationMgrServer).Deintegrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.IntegrationMgr/Deintegrate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationMgrServer).Deintegrate(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntegrationMgr_ListIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationMgrServer).ListIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.IntegrationMgr/ListIntegrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationMgrServer).ListIntegrations(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntegrationMgr_Integrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Integration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationMgrServer).Integrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.IntegrationMgr/Integrate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationMgrServer).Integrate(ctx, req.(*conversation.Integration))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntegrationMgr_CheckAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.AvailabilityCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationMgrServer).CheckAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.IntegrationMgr/CheckAvailability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationMgrServer).CheckAvailability(ctx, req.(*conversation.AvailabilityCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IntegrationMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.IntegrationMgr",
	HandlerType: (*IntegrationMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deintegrate",
			Handler:    _IntegrationMgr_Deintegrate_Handler,
		},
		{
			MethodName: "ListIntegrations",
			Handler:    _IntegrationMgr_ListIntegrations_Handler,
		},
		{
			MethodName: "Integrate",
			Handler:    _IntegrationMgr_Integrate_Handler,
		},
		{
			MethodName: "CheckAvailability",
			Handler:    _IntegrationMgr_CheckAvailability_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// TicketAttributeMgrClient is the client API for TicketAttributeMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TicketAttributeMgrClient interface {
	ListTicketAttributeDefinitions(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinitions, error)
	CreateTicketAttributeDefinition(ctx context.Context, in *conversation.TicketAttributeDefinition, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinition, error)
	UpdateTicketAttributeDefinition(ctx context.Context, in *conversation.TicketAttributeDefinition, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinition, error)
	DeleteTicketAttributeDefinition(ctx context.Context, in *conversation.DeleteTicketAttrRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type ticketAttributeMgrClient struct {
	cc *grpc.ClientConn
}

func NewTicketAttributeMgrClient(cc *grpc.ClientConn) TicketAttributeMgrClient {
	return &ticketAttributeMgrClient{cc}
}

func (c *ticketAttributeMgrClient) ListTicketAttributeDefinitions(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinitions, error) {
	out := new(conversation.TicketAttributeDefinitions)
	err := c.cc.Invoke(ctx, "/header.TicketAttributeMgr/ListTicketAttributeDefinitions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketAttributeMgrClient) CreateTicketAttributeDefinition(ctx context.Context, in *conversation.TicketAttributeDefinition, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinition, error) {
	out := new(conversation.TicketAttributeDefinition)
	err := c.cc.Invoke(ctx, "/header.TicketAttributeMgr/CreateTicketAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketAttributeMgrClient) UpdateTicketAttributeDefinition(ctx context.Context, in *conversation.TicketAttributeDefinition, opts ...grpc.CallOption) (*conversation.TicketAttributeDefinition, error) {
	out := new(conversation.TicketAttributeDefinition)
	err := c.cc.Invoke(ctx, "/header.TicketAttributeMgr/UpdateTicketAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketAttributeMgrClient) DeleteTicketAttributeDefinition(ctx context.Context, in *conversation.DeleteTicketAttrRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.TicketAttributeMgr/DeleteTicketAttributeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TicketAttributeMgrServer is the server API for TicketAttributeMgr service.
type TicketAttributeMgrServer interface {
	ListTicketAttributeDefinitions(context.Context, *common.Empty) (*conversation.TicketAttributeDefinitions, error)
	CreateTicketAttributeDefinition(context.Context, *conversation.TicketAttributeDefinition) (*conversation.TicketAttributeDefinition, error)
	UpdateTicketAttributeDefinition(context.Context, *conversation.TicketAttributeDefinition) (*conversation.TicketAttributeDefinition, error)
	DeleteTicketAttributeDefinition(context.Context, *conversation.DeleteTicketAttrRequest) (*common.Empty, error)
}

func RegisterTicketAttributeMgrServer(s *grpc.Server, srv TicketAttributeMgrServer) {
	s.RegisterService(&_TicketAttributeMgr_serviceDesc, srv)
}

func _TicketAttributeMgr_ListTicketAttributeDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketAttributeMgrServer).ListTicketAttributeDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketAttributeMgr/ListTicketAttributeDefinitions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketAttributeMgrServer).ListTicketAttributeDefinitions(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketAttributeMgr_CreateTicketAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.TicketAttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketAttributeMgrServer).CreateTicketAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketAttributeMgr/CreateTicketAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketAttributeMgrServer).CreateTicketAttributeDefinition(ctx, req.(*conversation.TicketAttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketAttributeMgr_UpdateTicketAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.TicketAttributeDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketAttributeMgrServer).UpdateTicketAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketAttributeMgr/UpdateTicketAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketAttributeMgrServer).UpdateTicketAttributeDefinition(ctx, req.(*conversation.TicketAttributeDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketAttributeMgr_DeleteTicketAttributeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.DeleteTicketAttrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketAttributeMgrServer).DeleteTicketAttributeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketAttributeMgr/DeleteTicketAttributeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketAttributeMgrServer).DeleteTicketAttributeDefinition(ctx, req.(*conversation.DeleteTicketAttrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TicketAttributeMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.TicketAttributeMgr",
	HandlerType: (*TicketAttributeMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTicketAttributeDefinitions",
			Handler:    _TicketAttributeMgr_ListTicketAttributeDefinitions_Handler,
		},
		{
			MethodName: "CreateTicketAttributeDefinition",
			Handler:    _TicketAttributeMgr_CreateTicketAttributeDefinition_Handler,
		},
		{
			MethodName: "UpdateTicketAttributeDefinition",
			Handler:    _TicketAttributeMgr_UpdateTicketAttributeDefinition_Handler,
		},
		{
			MethodName: "DeleteTicketAttributeDefinition",
			Handler:    _TicketAttributeMgr_DeleteTicketAttributeDefinition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// TicketMgrClient is the client API for TicketMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TicketMgrClient interface {
	CreateTicket(ctx context.Context, in *conversation.Ticket, opts ...grpc.CallOption) (*conversation.Ticket, error)
	UpdateTicket(ctx context.Context, in *conversation.Ticket, opts ...grpc.CallOption) (*conversation.Ticket, error)
	DeleteTicket(ctx context.Context, in *conversation.DeleteTicketRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetTicket(ctx context.Context, in *conversation.GetTicketRequest, opts ...grpc.CallOption) (*conversation.Ticket, error)
	SearchTicket(ctx context.Context, in *conversation.TicketListRequest, opts ...grpc.CallOption) (*conversation.ESTickets, error)
	ListSLAs(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreements, error)
	GetSLA(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error)
	CreateSLA(ctx context.Context, in *conversation.ServiceLevelAgreement, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error)
	UpdateSLA(ctx context.Context, in *conversation.ServiceLevelAgreement, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error)
	DeleteSLA(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	CountTicket(ctx context.Context, in *conversation.CountTicketRequest, opts ...grpc.CallOption) (*conversation.CountTicketResponse, error)
	GetAvgResolveTimes(ctx context.Context, in *conversation.AvgResolveTimeRequest, opts ...grpc.CallOption) (*conversation.AvgResolveTimeResponse, error)
}

type ticketMgrClient struct {
	cc *grpc.ClientConn
}

func NewTicketMgrClient(cc *grpc.ClientConn) TicketMgrClient {
	return &ticketMgrClient{cc}
}

func (c *ticketMgrClient) CreateTicket(ctx context.Context, in *conversation.Ticket, opts ...grpc.CallOption) (*conversation.Ticket, error) {
	out := new(conversation.Ticket)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/CreateTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateTicket(ctx context.Context, in *conversation.Ticket, opts ...grpc.CallOption) (*conversation.Ticket, error) {
	out := new(conversation.Ticket)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/UpdateTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteTicket(ctx context.Context, in *conversation.DeleteTicketRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/DeleteTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetTicket(ctx context.Context, in *conversation.GetTicketRequest, opts ...grpc.CallOption) (*conversation.Ticket, error) {
	out := new(conversation.Ticket)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/GetTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) SearchTicket(ctx context.Context, in *conversation.TicketListRequest, opts ...grpc.CallOption) (*conversation.ESTickets, error) {
	out := new(conversation.ESTickets)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/SearchTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) ListSLAs(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreements, error) {
	out := new(conversation.ServiceLevelAgreements)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/ListSLAs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetSLA(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error) {
	out := new(conversation.ServiceLevelAgreement)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/GetSLA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CreateSLA(ctx context.Context, in *conversation.ServiceLevelAgreement, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error) {
	out := new(conversation.ServiceLevelAgreement)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/CreateSLA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) UpdateSLA(ctx context.Context, in *conversation.ServiceLevelAgreement, opts ...grpc.CallOption) (*conversation.ServiceLevelAgreement, error) {
	out := new(conversation.ServiceLevelAgreement)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/UpdateSLA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) DeleteSLA(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/DeleteSLA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) CountTicket(ctx context.Context, in *conversation.CountTicketRequest, opts ...grpc.CallOption) (*conversation.CountTicketResponse, error) {
	out := new(conversation.CountTicketResponse)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/CountTicket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ticketMgrClient) GetAvgResolveTimes(ctx context.Context, in *conversation.AvgResolveTimeRequest, opts ...grpc.CallOption) (*conversation.AvgResolveTimeResponse, error) {
	out := new(conversation.AvgResolveTimeResponse)
	err := c.cc.Invoke(ctx, "/header.TicketMgr/GetAvgResolveTimes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TicketMgrServer is the server API for TicketMgr service.
type TicketMgrServer interface {
	CreateTicket(context.Context, *conversation.Ticket) (*conversation.Ticket, error)
	UpdateTicket(context.Context, *conversation.Ticket) (*conversation.Ticket, error)
	DeleteTicket(context.Context, *conversation.DeleteTicketRequest) (*common.Empty, error)
	GetTicket(context.Context, *conversation.GetTicketRequest) (*conversation.Ticket, error)
	SearchTicket(context.Context, *conversation.TicketListRequest) (*conversation.ESTickets, error)
	ListSLAs(context.Context, *common.Empty) (*conversation.ServiceLevelAgreements, error)
	GetSLA(context.Context, *common.Id) (*conversation.ServiceLevelAgreement, error)
	CreateSLA(context.Context, *conversation.ServiceLevelAgreement) (*conversation.ServiceLevelAgreement, error)
	UpdateSLA(context.Context, *conversation.ServiceLevelAgreement) (*conversation.ServiceLevelAgreement, error)
	DeleteSLA(context.Context, *common.Id) (*common.Empty, error)
	CountTicket(context.Context, *conversation.CountTicketRequest) (*conversation.CountTicketResponse, error)
	GetAvgResolveTimes(context.Context, *conversation.AvgResolveTimeRequest) (*conversation.AvgResolveTimeResponse, error)
}

func RegisterTicketMgrServer(s *grpc.Server, srv TicketMgrServer) {
	s.RegisterService(&_TicketMgr_serviceDesc, srv)
}

func _TicketMgr_CreateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Ticket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/CreateTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateTicket(ctx, req.(*conversation.Ticket))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.Ticket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/UpdateTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateTicket(ctx, req.(*conversation.Ticket))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.DeleteTicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/DeleteTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteTicket(ctx, req.(*conversation.DeleteTicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.GetTicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/GetTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetTicket(ctx, req.(*conversation.GetTicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_SearchTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.TicketListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).SearchTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/SearchTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).SearchTicket(ctx, req.(*conversation.TicketListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_ListSLAs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).ListSLAs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/ListSLAs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).ListSLAs(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetSLA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetSLA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/GetSLA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetSLA(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CreateSLA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.ServiceLevelAgreement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CreateSLA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/CreateSLA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CreateSLA(ctx, req.(*conversation.ServiceLevelAgreement))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_UpdateSLA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.ServiceLevelAgreement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).UpdateSLA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/UpdateSLA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).UpdateSLA(ctx, req.(*conversation.ServiceLevelAgreement))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_DeleteSLA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).DeleteSLA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/DeleteSLA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).DeleteSLA(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_CountTicket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.CountTicketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).CountTicket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/CountTicket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).CountTicket(ctx, req.(*conversation.CountTicketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TicketMgr_GetAvgResolveTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.AvgResolveTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TicketMgrServer).GetAvgResolveTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.TicketMgr/GetAvgResolveTimes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TicketMgrServer).GetAvgResolveTimes(ctx, req.(*conversation.AvgResolveTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TicketMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.TicketMgr",
	HandlerType: (*TicketMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTicket",
			Handler:    _TicketMgr_CreateTicket_Handler,
		},
		{
			MethodName: "UpdateTicket",
			Handler:    _TicketMgr_UpdateTicket_Handler,
		},
		{
			MethodName: "DeleteTicket",
			Handler:    _TicketMgr_DeleteTicket_Handler,
		},
		{
			MethodName: "GetTicket",
			Handler:    _TicketMgr_GetTicket_Handler,
		},
		{
			MethodName: "SearchTicket",
			Handler:    _TicketMgr_SearchTicket_Handler,
		},
		{
			MethodName: "ListSLAs",
			Handler:    _TicketMgr_ListSLAs_Handler,
		},
		{
			MethodName: "GetSLA",
			Handler:    _TicketMgr_GetSLA_Handler,
		},
		{
			MethodName: "CreateSLA",
			Handler:    _TicketMgr_CreateSLA_Handler,
		},
		{
			MethodName: "UpdateSLA",
			Handler:    _TicketMgr_UpdateSLA_Handler,
		},
		{
			MethodName: "DeleteSLA",
			Handler:    _TicketMgr_DeleteSLA_Handler,
		},
		{
			MethodName: "CountTicket",
			Handler:    _TicketMgr_CountTicket_Handler,
		},
		{
			MethodName: "GetAvgResolveTimes",
			Handler:    _TicketMgr_GetAvgResolveTimes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ClientMgrClient is the client API for ClientMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClientMgrClient interface {
	Create(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error)
	Update(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error)
	Read(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error)
	ListIntegratedClients(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.AuthorizedClient, error)
	ListAuthorizedClients(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.AuthorizedClient, error)
}

type clientMgrClient struct {
	cc *grpc.ClientConn
}

func NewClientMgrClient(cc *grpc.ClientConn) ClientMgrClient {
	return &clientMgrClient{cc}
}

func (c *clientMgrClient) Create(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error) {
	out := new(client.Client)
	err := c.cc.Invoke(ctx, "/header.ClientMgr/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientMgrClient) Update(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error) {
	out := new(client.Client)
	err := c.cc.Invoke(ctx, "/header.ClientMgr/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientMgrClient) Read(ctx context.Context, in *client.Client, opts ...grpc.CallOption) (*client.Client, error) {
	out := new(client.Client)
	err := c.cc.Invoke(ctx, "/header.ClientMgr/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientMgrClient) ListIntegratedClients(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.AuthorizedClient, error) {
	out := new(client.AuthorizedClient)
	err := c.cc.Invoke(ctx, "/header.ClientMgr/ListIntegratedClients", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientMgrClient) ListAuthorizedClients(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.AuthorizedClient, error) {
	out := new(client.AuthorizedClient)
	err := c.cc.Invoke(ctx, "/header.ClientMgr/ListAuthorizedClients", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientMgrServer is the server API for ClientMgr service.
type ClientMgrServer interface {
	Create(context.Context, *client.Client) (*client.Client, error)
	Update(context.Context, *client.Client) (*client.Client, error)
	Read(context.Context, *client.Client) (*client.Client, error)
	ListIntegratedClients(context.Context, *common.Id) (*client.AuthorizedClient, error)
	ListAuthorizedClients(context.Context, *common.Id) (*client.AuthorizedClient, error)
}

func RegisterClientMgrServer(s *grpc.Server, srv ClientMgrServer) {
	s.RegisterService(&_ClientMgr_serviceDesc, srv)
}

func _ClientMgr_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(client.Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientMgrServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ClientMgr/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientMgrServer).Create(ctx, req.(*client.Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientMgr_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(client.Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientMgrServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ClientMgr/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientMgrServer).Update(ctx, req.(*client.Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientMgr_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(client.Client)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientMgrServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ClientMgr/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientMgrServer).Read(ctx, req.(*client.Client))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientMgr_ListIntegratedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientMgrServer).ListIntegratedClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ClientMgr/ListIntegratedClients",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientMgrServer).ListIntegratedClients(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientMgr_ListAuthorizedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientMgrServer).ListAuthorizedClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ClientMgr/ListAuthorizedClients",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientMgrServer).ListAuthorizedClients(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClientMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ClientMgr",
	HandlerType: (*ClientMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ClientMgr_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ClientMgr_Update_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _ClientMgr_Read_Handler,
		},
		{
			MethodName: "ListIntegratedClients",
			Handler:    _ClientMgr_ListIntegratedClients_Handler,
		},
		{
			MethodName: "ListAuthorizedClients",
			Handler:    _ClientMgr_ListAuthorizedClients_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ServiceContentManagerClient is the client API for ServiceContentManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServiceContentManagerClient interface {
	UpsertContent(ctx context.Context, in *content.Content, opts ...grpc.CallOption) (*content.Content, error)
	DeleteContent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	GetContent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*content.Content, error)
	SearchContents(ctx context.Context, in *content.SearchContentRequest, opts ...grpc.CallOption) (*content.Contents, error)
	LookupContentsByUrl(ctx context.Context, in *content.LookupRequest, opts ...grpc.CallOption) (*content.Contents, error)
	LinkContentsToUrl(ctx context.Context, in *content.LinkRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type serviceContentManagerClient struct {
	cc *grpc.ClientConn
}

func NewServiceContentManagerClient(cc *grpc.ClientConn) ServiceContentManagerClient {
	return &serviceContentManagerClient{cc}
}

func (c *serviceContentManagerClient) UpsertContent(ctx context.Context, in *content.Content, opts ...grpc.CallOption) (*content.Content, error) {
	out := new(content.Content)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/UpsertContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceContentManagerClient) DeleteContent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/DeleteContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceContentManagerClient) GetContent(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*content.Content, error) {
	out := new(content.Content)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/GetContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceContentManagerClient) SearchContents(ctx context.Context, in *content.SearchContentRequest, opts ...grpc.CallOption) (*content.Contents, error) {
	out := new(content.Contents)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/SearchContents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceContentManagerClient) LookupContentsByUrl(ctx context.Context, in *content.LookupRequest, opts ...grpc.CallOption) (*content.Contents, error) {
	out := new(content.Contents)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/LookupContentsByUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceContentManagerClient) LinkContentsToUrl(ctx context.Context, in *content.LinkRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ServiceContentManager/LinkContentsToUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceContentManagerServer is the server API for ServiceContentManager service.
type ServiceContentManagerServer interface {
	UpsertContent(context.Context, *content.Content) (*content.Content, error)
	DeleteContent(context.Context, *common.Id) (*common.Empty, error)
	GetContent(context.Context, *common.Id) (*content.Content, error)
	SearchContents(context.Context, *content.SearchContentRequest) (*content.Contents, error)
	LookupContentsByUrl(context.Context, *content.LookupRequest) (*content.Contents, error)
	LinkContentsToUrl(context.Context, *content.LinkRequest) (*common.Empty, error)
}

func RegisterServiceContentManagerServer(s *grpc.Server, srv ServiceContentManagerServer) {
	s.RegisterService(&_ServiceContentManager_serviceDesc, srv)
}

func _ServiceContentManager_UpsertContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(content.Content)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).UpsertContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/UpsertContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).UpsertContent(ctx, req.(*content.Content))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceContentManager_DeleteContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).DeleteContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/DeleteContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).DeleteContent(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceContentManager_GetContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).GetContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/GetContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).GetContent(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceContentManager_SearchContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(content.SearchContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).SearchContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/SearchContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).SearchContents(ctx, req.(*content.SearchContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceContentManager_LookupContentsByUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(content.LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).LookupContentsByUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/LookupContentsByUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).LookupContentsByUrl(ctx, req.(*content.LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceContentManager_LinkContentsToUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(content.LinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceContentManagerServer).LinkContentsToUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceContentManager/LinkContentsToUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceContentManagerServer).LinkContentsToUrl(ctx, req.(*content.LinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceContentManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ServiceContentManager",
	HandlerType: (*ServiceContentManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpsertContent",
			Handler:    _ServiceContentManager_UpsertContent_Handler,
		},
		{
			MethodName: "DeleteContent",
			Handler:    _ServiceContentManager_DeleteContent_Handler,
		},
		{
			MethodName: "GetContent",
			Handler:    _ServiceContentManager_GetContent_Handler,
		},
		{
			MethodName: "SearchContents",
			Handler:    _ServiceContentManager_SearchContents_Handler,
		},
		{
			MethodName: "LookupContentsByUrl",
			Handler:    _ServiceContentManager_LookupContentsByUrl_Handler,
		},
		{
			MethodName: "LinkContentsToUrl",
			Handler:    _ServiceContentManager_LinkContentsToUrl_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// DealServiceClient is the client API for DealService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DealServiceClient interface {
	ListPipelines(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*deal.Pipelines, error)
	GetPipeline(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*deal.Pipeline, error)
	CreatePipeline(ctx context.Context, in *deal.Pipeline, opts ...grpc.CallOption) (*deal.Pipeline, error)
	UpdatePipeline(ctx context.Context, in *deal.Pipeline, opts ...grpc.CallOption) (*deal.Pipeline, error)
	DeletePipeline(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
}

type dealServiceClient struct {
	cc *grpc.ClientConn
}

func NewDealServiceClient(cc *grpc.ClientConn) DealServiceClient {
	return &dealServiceClient{cc}
}

func (c *dealServiceClient) ListPipelines(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*deal.Pipelines, error) {
	out := new(deal.Pipelines)
	err := c.cc.Invoke(ctx, "/header.DealService/ListPipelines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dealServiceClient) GetPipeline(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*deal.Pipeline, error) {
	out := new(deal.Pipeline)
	err := c.cc.Invoke(ctx, "/header.DealService/GetPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dealServiceClient) CreatePipeline(ctx context.Context, in *deal.Pipeline, opts ...grpc.CallOption) (*deal.Pipeline, error) {
	out := new(deal.Pipeline)
	err := c.cc.Invoke(ctx, "/header.DealService/CreatePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dealServiceClient) UpdatePipeline(ctx context.Context, in *deal.Pipeline, opts ...grpc.CallOption) (*deal.Pipeline, error) {
	out := new(deal.Pipeline)
	err := c.cc.Invoke(ctx, "/header.DealService/UpdatePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dealServiceClient) DeletePipeline(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.DealService/DeletePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DealServiceServer is the server API for DealService service.
type DealServiceServer interface {
	ListPipelines(context.Context, *common.Empty) (*deal.Pipelines, error)
	GetPipeline(context.Context, *common.Id) (*deal.Pipeline, error)
	CreatePipeline(context.Context, *deal.Pipeline) (*deal.Pipeline, error)
	UpdatePipeline(context.Context, *deal.Pipeline) (*deal.Pipeline, error)
	DeletePipeline(context.Context, *common.Id) (*common.Empty, error)
}

func RegisterDealServiceServer(s *grpc.Server, srv DealServiceServer) {
	s.RegisterService(&_DealService_serviceDesc, srv)
}

func _DealService_ListPipelines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DealServiceServer).ListPipelines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.DealService/ListPipelines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DealServiceServer).ListPipelines(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DealService_GetPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DealServiceServer).GetPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.DealService/GetPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DealServiceServer).GetPipeline(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _DealService_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(deal.Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DealServiceServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.DealService/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DealServiceServer).CreatePipeline(ctx, req.(*deal.Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _DealService_UpdatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(deal.Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DealServiceServer).UpdatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.DealService/UpdatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DealServiceServer).UpdatePipeline(ctx, req.(*deal.Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _DealService_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DealServiceServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.DealService/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DealServiceServer).DeletePipeline(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _DealService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.DealService",
	HandlerType: (*DealServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPipelines",
			Handler:    _DealService_ListPipelines_Handler,
		},
		{
			MethodName: "GetPipeline",
			Handler:    _DealService_GetPipeline_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _DealService_CreatePipeline_Handler,
		},
		{
			MethodName: "UpdatePipeline",
			Handler:    _DealService_UpdatePipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _DealService_DeletePipeline_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// PublisherClient is the client API for Publisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PublisherClient interface {
	Subscribe(ctx context.Context, in *event.Subscription, opts ...grpc.CallOption) (*event.SubscriptionResponse, error)
	Unsubscribe(ctx context.Context, in *event.Subscription, opts ...grpc.CallOption) (*event.SubscriptionResponse, error)
}

type publisherClient struct {
	cc *grpc.ClientConn
}

func NewPublisherClient(cc *grpc.ClientConn) PublisherClient {
	return &publisherClient{cc}
}

func (c *publisherClient) Subscribe(ctx context.Context, in *event.Subscription, opts ...grpc.CallOption) (*event.SubscriptionResponse, error) {
	out := new(event.SubscriptionResponse)
	err := c.cc.Invoke(ctx, "/header.Publisher/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publisherClient) Unsubscribe(ctx context.Context, in *event.Subscription, opts ...grpc.CallOption) (*event.SubscriptionResponse, error) {
	out := new(event.SubscriptionResponse)
	err := c.cc.Invoke(ctx, "/header.Publisher/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublisherServer is the server API for Publisher service.
type PublisherServer interface {
	Subscribe(context.Context, *event.Subscription) (*event.SubscriptionResponse, error)
	Unsubscribe(context.Context, *event.Subscription) (*event.SubscriptionResponse, error)
}

func RegisterPublisherServer(s *grpc.Server, srv PublisherServer) {
	s.RegisterService(&_Publisher_serviceDesc, srv)
}

func _Publisher_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Publisher/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).Subscribe(ctx, req.(*event.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Publisher_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublisherServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Publisher/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublisherServer).Unsubscribe(ctx, req.(*event.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

var _Publisher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Publisher",
	HandlerType: (*PublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _Publisher_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _Publisher_Unsubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// EventMgrClient is the client API for EventMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventMgrClient interface {
	SearchEvents(ctx context.Context, in *event.ListEventsRequest, opts ...grpc.CallOption) (*event.Events, error)
	Subscribe(ctx context.Context, in *user.SubscribeRequest, opts ...grpc.CallOption) (*common.Empty, error)
	Unsubscribe(ctx context.Context, in *user.SubscribeRequest, opts ...grpc.CallOption) (*common.Empty, error)
	CreateEvent(ctx context.Context, in *event.UserEvent, opts ...grpc.CallOption) (*event.Event, error)
	ReadTopic(ctx context.Context, in *user.ReadTopicRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SearchTopics(ctx context.Context, in *user.ListTopicsRequest, opts ...grpc.CallOption) (*user.ListTopicsResult, error)
}

type eventMgrClient struct {
	cc *grpc.ClientConn
}

func NewEventMgrClient(cc *grpc.ClientConn) EventMgrClient {
	return &eventMgrClient{cc}
}

func (c *eventMgrClient) SearchEvents(ctx context.Context, in *event.ListEventsRequest, opts ...grpc.CallOption) (*event.Events, error) {
	out := new(event.Events)
	err := c.cc.Invoke(ctx, "/header.EventMgr/SearchEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventMgrClient) Subscribe(ctx context.Context, in *user.SubscribeRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.EventMgr/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventMgrClient) Unsubscribe(ctx context.Context, in *user.SubscribeRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.EventMgr/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventMgrClient) CreateEvent(ctx context.Context, in *event.UserEvent, opts ...grpc.CallOption) (*event.Event, error) {
	out := new(event.Event)
	err := c.cc.Invoke(ctx, "/header.EventMgr/CreateEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventMgrClient) ReadTopic(ctx context.Context, in *user.ReadTopicRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.EventMgr/ReadTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventMgrClient) SearchTopics(ctx context.Context, in *user.ListTopicsRequest, opts ...grpc.CallOption) (*user.ListTopicsResult, error) {
	out := new(user.ListTopicsResult)
	err := c.cc.Invoke(ctx, "/header.EventMgr/SearchTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventMgrServer is the server API for EventMgr service.
type EventMgrServer interface {
	SearchEvents(context.Context, *event.ListEventsRequest) (*event.Events, error)
	Subscribe(context.Context, *user.SubscribeRequest) (*common.Empty, error)
	Unsubscribe(context.Context, *user.SubscribeRequest) (*common.Empty, error)
	CreateEvent(context.Context, *event.UserEvent) (*event.Event, error)
	ReadTopic(context.Context, *user.ReadTopicRequest) (*common.Empty, error)
	SearchTopics(context.Context, *user.ListTopicsRequest) (*user.ListTopicsResult, error)
}

func RegisterEventMgrServer(s *grpc.Server, srv EventMgrServer) {
	s.RegisterService(&_EventMgr_serviceDesc, srv)
}

func _EventMgr_SearchEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).SearchEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/SearchEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).SearchEvents(ctx, req.(*event.ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventMgr_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).Subscribe(ctx, req.(*user.SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventMgr_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).Unsubscribe(ctx, req.(*user.SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventMgr_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.UserEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/CreateEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).CreateEvent(ctx, req.(*event.UserEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventMgr_ReadTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.ReadTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).ReadTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/ReadTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).ReadTopic(ctx, req.(*user.ReadTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventMgr_SearchTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(user.ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventMgrServer).SearchTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.EventMgr/SearchTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventMgrServer).SearchTopics(ctx, req.(*user.ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.EventMgr",
	HandlerType: (*EventMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchEvents",
			Handler:    _EventMgr_SearchEvents_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _EventMgr_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _EventMgr_Unsubscribe_Handler,
		},
		{
			MethodName: "CreateEvent",
			Handler:    _EventMgr_CreateEvent_Handler,
		},
		{
			MethodName: "ReadTopic",
			Handler:    _EventMgr_ReadTopic_Handler,
		},
		{
			MethodName: "SearchTopics",
			Handler:    _EventMgr_SearchTopics_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ConversationEventReaderClient is the client API for ConversationEventReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConversationEventReaderClient interface {
	SendMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error)
	UpdateMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error)
	ListEvents(ctx context.Context, in *conversation.ListEventsRequest, opts ...grpc.CallOption) (*event.Events, error)
	SearchEvents(ctx context.Context, in *conversation.SearchMessageRequest, opts ...grpc.CallOption) (*event.Events, error)
}

type conversationEventReaderClient struct {
	cc *grpc.ClientConn
}

func NewConversationEventReaderClient(cc *grpc.ClientConn) ConversationEventReaderClient {
	return &conversationEventReaderClient{cc}
}

func (c *conversationEventReaderClient) SendMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error) {
	out := new(event.Event)
	err := c.cc.Invoke(ctx, "/header.ConversationEventReader/SendMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationEventReaderClient) UpdateMessage(ctx context.Context, in *event.Event, opts ...grpc.CallOption) (*event.Event, error) {
	out := new(event.Event)
	err := c.cc.Invoke(ctx, "/header.ConversationEventReader/UpdateMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationEventReaderClient) ListEvents(ctx context.Context, in *conversation.ListEventsRequest, opts ...grpc.CallOption) (*event.Events, error) {
	out := new(event.Events)
	err := c.cc.Invoke(ctx, "/header.ConversationEventReader/ListEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conversationEventReaderClient) SearchEvents(ctx context.Context, in *conversation.SearchMessageRequest, opts ...grpc.CallOption) (*event.Events, error) {
	out := new(event.Events)
	err := c.cc.Invoke(ctx, "/header.ConversationEventReader/SearchEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConversationEventReaderServer is the server API for ConversationEventReader service.
type ConversationEventReaderServer interface {
	SendMessage(context.Context, *event.Event) (*event.Event, error)
	UpdateMessage(context.Context, *event.Event) (*event.Event, error)
	ListEvents(context.Context, *conversation.ListEventsRequest) (*event.Events, error)
	SearchEvents(context.Context, *conversation.SearchMessageRequest) (*event.Events, error)
}

func RegisterConversationEventReaderServer(s *grpc.Server, srv ConversationEventReaderServer) {
	s.RegisterService(&_ConversationEventReader_serviceDesc, srv)
}

func _ConversationEventReader_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationEventReaderServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationEventReader/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationEventReaderServer).SendMessage(ctx, req.(*event.Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationEventReader_UpdateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(event.Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationEventReaderServer).UpdateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationEventReader/UpdateMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationEventReaderServer).UpdateMessage(ctx, req.(*event.Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationEventReader_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationEventReaderServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationEventReader/ListEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationEventReaderServer).ListEvents(ctx, req.(*conversation.ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConversationEventReader_SearchEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(conversation.SearchMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConversationEventReaderServer).SearchEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ConversationEventReader/SearchEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConversationEventReaderServer).SearchEvents(ctx, req.(*conversation.SearchMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ConversationEventReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ConversationEventReader",
	HandlerType: (*ConversationEventReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _ConversationEventReader_SendMessage_Handler,
		},
		{
			MethodName: "UpdateMessage",
			Handler:    _ConversationEventReader_UpdateMessage_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _ConversationEventReader_ListEvents_Handler,
		},
		{
			MethodName: "SearchEvents",
			Handler:    _ConversationEventReader_SearchEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// FileMgrClient is the client API for FileMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FileMgrClient interface {
	Presign(ctx context.Context, in *file.FileHeader, opts ...grpc.CallOption) (*file.PresignResult, error)
	Read(ctx context.Context, in *file.FileRequest, opts ...grpc.CallOption) (*file.File, error)
	Uploaded(ctx context.Context, in *file.FileRequest, opts ...grpc.CallOption) (*file.File, error)
}

type fileMgrClient struct {
	cc *grpc.ClientConn
}

func NewFileMgrClient(cc *grpc.ClientConn) FileMgrClient {
	return &fileMgrClient{cc}
}

func (c *fileMgrClient) Presign(ctx context.Context, in *file.FileHeader, opts ...grpc.CallOption) (*file.PresignResult, error) {
	out := new(file.PresignResult)
	err := c.cc.Invoke(ctx, "/header.FileMgr/Presign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) Read(ctx context.Context, in *file.FileRequest, opts ...grpc.CallOption) (*file.File, error) {
	out := new(file.File)
	err := c.cc.Invoke(ctx, "/header.FileMgr/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileMgrClient) Uploaded(ctx context.Context, in *file.FileRequest, opts ...grpc.CallOption) (*file.File, error) {
	out := new(file.File)
	err := c.cc.Invoke(ctx, "/header.FileMgr/Uploaded", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileMgrServer is the server API for FileMgr service.
type FileMgrServer interface {
	Presign(context.Context, *file.FileHeader) (*file.PresignResult, error)
	Read(context.Context, *file.FileRequest) (*file.File, error)
	Uploaded(context.Context, *file.FileRequest) (*file.File, error)
}

func RegisterFileMgrServer(s *grpc.Server, srv FileMgrServer) {
	s.RegisterService(&_FileMgr_serviceDesc, srv)
}

func _FileMgr_Presign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(file.FileHeader)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).Presign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.FileMgr/Presign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).Presign(ctx, req.(*file.FileHeader))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(file.FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.FileMgr/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).Read(ctx, req.(*file.FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileMgr_Uploaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(file.FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileMgrServer).Uploaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.FileMgr/Uploaded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileMgrServer).Uploaded(ctx, req.(*file.FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.FileMgr",
	HandlerType: (*FileMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Presign",
			Handler:    _FileMgr_Presign_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _FileMgr_Read_Handler,
		},
		{
			MethodName: "Uploaded",
			Handler:    _FileMgr_Uploaded_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// KafpcClient is the client API for Kafpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KafpcClient interface {
	Reply(ctx context.Context, in *kafpc.Response, opts ...grpc.CallOption) (*kafpc.Empty, error)
}

type kafpcClient struct {
	cc *grpc.ClientConn
}

func NewKafpcClient(cc *grpc.ClientConn) KafpcClient {
	return &kafpcClient{cc}
}

func (c *kafpcClient) Reply(ctx context.Context, in *kafpc.Response, opts ...grpc.CallOption) (*kafpc.Empty, error) {
	out := new(kafpc.Empty)
	err := c.cc.Invoke(ctx, "/header.Kafpc/Reply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KafpcServer is the server API for Kafpc service.
type KafpcServer interface {
	Reply(context.Context, *kafpc.Response) (*kafpc.Empty, error)
}

func RegisterKafpcServer(s *grpc.Server, srv KafpcServer) {
	s.RegisterService(&_Kafpc_serviceDesc, srv)
}

func _Kafpc_Reply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kafpc.Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KafpcServer).Reply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Kafpc/Reply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KafpcServer).Reply(ctx, req.(*kafpc.Response))
	}
	return interceptor(ctx, in, info, handler)
}

var _Kafpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Kafpc",
	HandlerType: (*KafpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Reply",
			Handler:    _Kafpc_Reply_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// KVClient is the client API for KV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type KVClient interface {
	Set(ctx context.Context, in *kv.Value, opts ...grpc.CallOption) (*kv.Value, error)
	Get(ctx context.Context, in *kv.Key, opts ...grpc.CallOption) (*kv.Value, error)
	Has(ctx context.Context, in *kv.Key, opts ...grpc.CallOption) (*kv.Bool, error)
}

type kVClient struct {
	cc *grpc.ClientConn
}

func NewKVClient(cc *grpc.ClientConn) KVClient {
	return &kVClient{cc}
}

func (c *kVClient) Set(ctx context.Context, in *kv.Value, opts ...grpc.CallOption) (*kv.Value, error) {
	out := new(kv.Value)
	err := c.cc.Invoke(ctx, "/header.KV/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Get(ctx context.Context, in *kv.Key, opts ...grpc.CallOption) (*kv.Value, error) {
	out := new(kv.Value)
	err := c.cc.Invoke(ctx, "/header.KV/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVClient) Has(ctx context.Context, in *kv.Key, opts ...grpc.CallOption) (*kv.Bool, error) {
	out := new(kv.Bool)
	err := c.cc.Invoke(ctx, "/header.KV/Has", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KVServer is the server API for KV service.
type KVServer interface {
	Set(context.Context, *kv.Value) (*kv.Value, error)
	Get(context.Context, *kv.Key) (*kv.Value, error)
	Has(context.Context, *kv.Key) (*kv.Bool, error)
}

func RegisterKVServer(s *grpc.Server, srv KVServer) {
	s.RegisterService(&_KV_serviceDesc, srv)
}

func _KV_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kv.Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.KV/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Set(ctx, req.(*kv.Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kv.Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.KV/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Get(ctx, req.(*kv.Key))
	}
	return interceptor(ctx, in, info, handler)
}

func _KV_Has_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(kv.Key)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVServer).Has(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.KV/Has",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVServer).Has(ctx, req.(*kv.Key))
	}
	return interceptor(ctx, in, info, handler)
}

var _KV_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.KV",
	HandlerType: (*KVServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Set",
			Handler:    _KV_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _KV_Get_Handler,
		},
		{
			MethodName: "Has",
			Handler:    _KV_Has_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// Noti5ServiceClient is the client API for Noti5Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type Noti5ServiceClient interface {
	ReadNotificationSetting(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*noti5.Setting, error)
	UpdateNotificationSetting(ctx context.Context, in *noti5.Setting, opts ...grpc.CallOption) (*noti5.Setting, error)
}

type noti5ServiceClient struct {
	cc *grpc.ClientConn
}

func NewNoti5ServiceClient(cc *grpc.ClientConn) Noti5ServiceClient {
	return &noti5ServiceClient{cc}
}

func (c *noti5ServiceClient) ReadNotificationSetting(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*noti5.Setting, error) {
	out := new(noti5.Setting)
	err := c.cc.Invoke(ctx, "/header.Noti5Service/ReadNotificationSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noti5ServiceClient) UpdateNotificationSetting(ctx context.Context, in *noti5.Setting, opts ...grpc.CallOption) (*noti5.Setting, error) {
	out := new(noti5.Setting)
	err := c.cc.Invoke(ctx, "/header.Noti5Service/UpdateNotificationSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Noti5ServiceServer is the server API for Noti5Service service.
type Noti5ServiceServer interface {
	ReadNotificationSetting(context.Context, *common.Id) (*noti5.Setting, error)
	UpdateNotificationSetting(context.Context, *noti5.Setting) (*noti5.Setting, error)
}

func RegisterNoti5ServiceServer(s *grpc.Server, srv Noti5ServiceServer) {
	s.RegisterService(&_Noti5Service_serviceDesc, srv)
}

func _Noti5Service_ReadNotificationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Noti5ServiceServer).ReadNotificationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Noti5Service/ReadNotificationSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Noti5ServiceServer).ReadNotificationSetting(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Noti5Service_UpdateNotificationSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(noti5.Setting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Noti5ServiceServer).UpdateNotificationSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Noti5Service/UpdateNotificationSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Noti5ServiceServer).UpdateNotificationSetting(ctx, req.(*noti5.Setting))
	}
	return interceptor(ctx, in, info, handler)
}

var _Noti5Service_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Noti5Service",
	HandlerType: (*Noti5ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadNotificationSetting",
			Handler:    _Noti5Service_ReadNotificationSetting_Handler,
		},
		{
			MethodName: "UpdateNotificationSetting",
			Handler:    _Noti5Service_UpdateNotificationSetting_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// Noti5TokenServiceClient is the client API for Noti5TokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type Noti5TokenServiceClient interface {
	AddToken(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error)
	RemoveToken(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error)
	CheckTokenExists(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error)
}

type noti5TokenServiceClient struct {
	cc *grpc.ClientConn
}

func NewNoti5TokenServiceClient(cc *grpc.ClientConn) Noti5TokenServiceClient {
	return &noti5TokenServiceClient{cc}
}

func (c *noti5TokenServiceClient) AddToken(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Noti5TokenService/AddToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noti5TokenServiceClient) RemoveToken(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Noti5TokenService/RemoveToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noti5TokenServiceClient) CheckTokenExists(ctx context.Context, in *noti5.Token, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Noti5TokenService/CheckTokenExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Noti5TokenServiceServer is the server API for Noti5TokenService service.
type Noti5TokenServiceServer interface {
	AddToken(context.Context, *noti5.Token) (*common.Empty, error)
	RemoveToken(context.Context, *noti5.Token) (*common.Empty, error)
	CheckTokenExists(context.Context, *noti5.Token) (*common.Empty, error)
}

func RegisterNoti5TokenServiceServer(s *grpc.Server, srv Noti5TokenServiceServer) {
	s.RegisterService(&_Noti5TokenService_serviceDesc, srv)
}

func _Noti5TokenService_AddToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(noti5.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Noti5TokenServiceServer).AddToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Noti5TokenService/AddToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Noti5TokenServiceServer).AddToken(ctx, req.(*noti5.Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _Noti5TokenService_RemoveToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(noti5.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Noti5TokenServiceServer).RemoveToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Noti5TokenService/RemoveToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Noti5TokenServiceServer).RemoveToken(ctx, req.(*noti5.Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _Noti5TokenService_CheckTokenExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(noti5.Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Noti5TokenServiceServer).CheckTokenExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Noti5TokenService/CheckTokenExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Noti5TokenServiceServer).CheckTokenExists(ctx, req.(*noti5.Token))
	}
	return interceptor(ctx, in, info, handler)
}

var _Noti5TokenService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Noti5TokenService",
	HandlerType: (*Noti5TokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddToken",
			Handler:    _Noti5TokenService_AddToken_Handler,
		},
		{
			MethodName: "RemoveToken",
			Handler:    _Noti5TokenService_RemoveToken_Handler,
		},
		{
			MethodName: "CheckTokenExists",
			Handler:    _Noti5TokenService_CheckTokenExists_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// NotiboxServiceClient is the client API for NotiboxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NotiboxServiceClient interface {
	// rpc Upsert(notibox.Notification) returns (notibox.Notification);
	ReadTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SeenTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UnreadTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error)
	ListNotis(ctx context.Context, in *notibox.ListRequest, opts ...grpc.CallOption) (*notibox.Notifications, error)
	UpdateNotibox(ctx context.Context, in *notibox.Notibox, opts ...grpc.CallOption) (*notibox.Notibox, error)
	ReadNotibox(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*notibox.Notibox, error)
}

type notiboxServiceClient struct {
	cc *grpc.ClientConn
}

func NewNotiboxServiceClient(cc *grpc.ClientConn) NotiboxServiceClient {
	return &notiboxServiceClient{cc}
}

func (c *notiboxServiceClient) ReadTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/ReadTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiboxServiceClient) SeenTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/SeenTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiboxServiceClient) UnreadTopics(ctx context.Context, in *notibox.TopicRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/UnreadTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiboxServiceClient) ListNotis(ctx context.Context, in *notibox.ListRequest, opts ...grpc.CallOption) (*notibox.Notifications, error) {
	out := new(notibox.Notifications)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/ListNotis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiboxServiceClient) UpdateNotibox(ctx context.Context, in *notibox.Notibox, opts ...grpc.CallOption) (*notibox.Notibox, error) {
	out := new(notibox.Notibox)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/UpdateNotibox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notiboxServiceClient) ReadNotibox(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*notibox.Notibox, error) {
	out := new(notibox.Notibox)
	err := c.cc.Invoke(ctx, "/header.NotiboxService/ReadNotibox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotiboxServiceServer is the server API for NotiboxService service.
type NotiboxServiceServer interface {
	// rpc Upsert(notibox.Notification) returns (notibox.Notification);
	ReadTopics(context.Context, *notibox.TopicRequest) (*common.Empty, error)
	SeenTopics(context.Context, *notibox.TopicRequest) (*common.Empty, error)
	UnreadTopics(context.Context, *notibox.TopicRequest) (*common.Empty, error)
	ListNotis(context.Context, *notibox.ListRequest) (*notibox.Notifications, error)
	UpdateNotibox(context.Context, *notibox.Notibox) (*notibox.Notibox, error)
	ReadNotibox(context.Context, *common.Id) (*notibox.Notibox, error)
}

func RegisterNotiboxServiceServer(s *grpc.Server, srv NotiboxServiceServer) {
	s.RegisterService(&_NotiboxService_serviceDesc, srv)
}

func _NotiboxService_ReadTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(notibox.TopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).ReadTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/ReadTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).ReadTopics(ctx, req.(*notibox.TopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiboxService_SeenTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(notibox.TopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).SeenTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/SeenTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).SeenTopics(ctx, req.(*notibox.TopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiboxService_UnreadTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(notibox.TopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).UnreadTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/UnreadTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).UnreadTopics(ctx, req.(*notibox.TopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiboxService_ListNotis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(notibox.ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).ListNotis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/ListNotis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).ListNotis(ctx, req.(*notibox.ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiboxService_UpdateNotibox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(notibox.Notibox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).UpdateNotibox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/UpdateNotibox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).UpdateNotibox(ctx, req.(*notibox.Notibox))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotiboxService_ReadNotibox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotiboxServiceServer).ReadNotibox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.NotiboxService/ReadNotibox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotiboxServiceServer).ReadNotibox(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _NotiboxService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.NotiboxService",
	HandlerType: (*NotiboxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadTopics",
			Handler:    _NotiboxService_ReadTopics_Handler,
		},
		{
			MethodName: "SeenTopics",
			Handler:    _NotiboxService_SeenTopics_Handler,
		},
		{
			MethodName: "UnreadTopics",
			Handler:    _NotiboxService_UnreadTopics_Handler,
		},
		{
			MethodName: "ListNotis",
			Handler:    _NotiboxService_ListNotis_Handler,
		},
		{
			MethodName: "UpdateNotibox",
			Handler:    _NotiboxService_UpdateNotibox_Handler,
		},
		{
			MethodName: "ReadNotibox",
			Handler:    _NotiboxService_ReadNotibox_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// SubizInternalPaymentMgrClient is the client API for SubizInternalPaymentMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubizInternalPaymentMgrClient interface {
	CreateBill(ctx context.Context, in *payment.Bill, opts ...grpc.CallOption) (*payment.Bill, error)
	UpdateExchangeRate(ctx context.Context, in *payment.ExchangeRate, opts ...grpc.CallOption) (*payment.ExchangeRate, error)
}

type subizInternalPaymentMgrClient struct {
	cc *grpc.ClientConn
}

func NewSubizInternalPaymentMgrClient(cc *grpc.ClientConn) SubizInternalPaymentMgrClient {
	return &subizInternalPaymentMgrClient{cc}
}

func (c *subizInternalPaymentMgrClient) CreateBill(ctx context.Context, in *payment.Bill, opts ...grpc.CallOption) (*payment.Bill, error) {
	out := new(payment.Bill)
	err := c.cc.Invoke(ctx, "/header.SubizInternalPaymentMgr/CreateBill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subizInternalPaymentMgrClient) UpdateExchangeRate(ctx context.Context, in *payment.ExchangeRate, opts ...grpc.CallOption) (*payment.ExchangeRate, error) {
	out := new(payment.ExchangeRate)
	err := c.cc.Invoke(ctx, "/header.SubizInternalPaymentMgr/UpdateExchangeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubizInternalPaymentMgrServer is the server API for SubizInternalPaymentMgr service.
type SubizInternalPaymentMgrServer interface {
	CreateBill(context.Context, *payment.Bill) (*payment.Bill, error)
	UpdateExchangeRate(context.Context, *payment.ExchangeRate) (*payment.ExchangeRate, error)
}

func RegisterSubizInternalPaymentMgrServer(s *grpc.Server, srv SubizInternalPaymentMgrServer) {
	s.RegisterService(&_SubizInternalPaymentMgr_serviceDesc, srv)
}

func _SubizInternalPaymentMgr_CreateBill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Bill)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubizInternalPaymentMgrServer).CreateBill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SubizInternalPaymentMgr/CreateBill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubizInternalPaymentMgrServer).CreateBill(ctx, req.(*payment.Bill))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubizInternalPaymentMgr_UpdateExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ExchangeRate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubizInternalPaymentMgrServer).UpdateExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.SubizInternalPaymentMgr/UpdateExchangeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubizInternalPaymentMgrServer).UpdateExchangeRate(ctx, req.(*payment.ExchangeRate))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubizInternalPaymentMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.SubizInternalPaymentMgr",
	HandlerType: (*SubizInternalPaymentMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBill",
			Handler:    _SubizInternalPaymentMgr_CreateBill_Handler,
		},
		{
			MethodName: "UpdateExchangeRate",
			Handler:    _SubizInternalPaymentMgr_UpdateExchangeRate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// PaymentMgrClient is the client API for PaymentMgr service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PaymentMgrClient interface {
	Purchase(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error)
	UpdateSubscription(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Subscription, error)
	GetSubscription(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Subscription, error)
	AddPaymentMethod(ctx context.Context, in *payment.PaymentMethod, opts ...grpc.CallOption) (*payment.PaymentMethod, error)
	UpdatePaymentMethod(ctx context.Context, in *payment.PaymentMethod, opts ...grpc.CallOption) (*payment.PaymentMethod, error)
	DeletePaymentMethod(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	ListPaymentMethods(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.PaymentMethods, error)
	Pay(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error)
	ListInvoices(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Invoices, error)
	CreateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error)
	UpdateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error)
	FilterInvoices(ctx context.Context, in *payment.ListInvoiceRequest, opts ...grpc.CallOption) (*payment.Invoices, error)
	DraftInvoice(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error)
	DiffSubscriptions(ctx context.Context, in *payment.DiffSubRequest, opts ...grpc.CallOption) (*payment.Invoice, error)
	ListComments(ctx context.Context, in *payment.ListCommentsRequest, opts ...grpc.CallOption) (*payment.Comments, error)
	AddComment(ctx context.Context, in *payment.Comment, opts ...grpc.CallOption) (*payment.Comment, error)
	ListPlans(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*payment.Plans, error)
	ExportInvoice(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.String, error)
	ConvertInvoiceToHtml(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.String, error)
	GetExchangeRate(ctx context.Context, in *payment.ExchangeRate, opts ...grpc.CallOption) (*payment.ExchangeRate, error)
	TransferMoney(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error)
	ListLogs(ctx context.Context, in *payment.ListLogsRequest, opts ...grpc.CallOption) (*payment.Logs, error)
	CreatePromotionCode(ctx context.Context, in *payment.PromotionCode, opts ...grpc.CallOption) (*payment.PromotionCode, error)
	GetPromotionCode(ctx context.Context, in *payment.String, opts ...grpc.CallOption) (*payment.PromotionCode, error)
	UsePromotionCode(ctx context.Context, in *payment.PromotionCodeRequest, opts ...grpc.CallOption) (*common.Empty, error)
	ValidatePromotionCode(ctx context.Context, in *payment.PromotionCodeRequest, opts ...grpc.CallOption) (*payment.PromotionCode, error)
	ListPromotionCode(ctx context.Context, in *payment.ListPromotionCodeRequest, opts ...grpc.CallOption) (*payment.PromotionCodes, error)
	DeletePromotionCode(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	SearchReferral(ctx context.Context, in *payment.SearchReferredRequest, opts ...grpc.CallOption) (*payment.Referral, error)
	GetReferral(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Referral, error)
	ListTopReferral(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*payment.ReferralResponse, error)
	UpdateReferral(ctx context.Context, in *payment.Referral, opts ...grpc.CallOption) (*payment.Referral, error)
	ListAccountReferred(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogAccountReferreds, error)
	ListBillByAccountReferred(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogBillByAccountReferreds, error)
	ListPaidForAgentReferrer(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogPaidForAgentReferrers, error)
	PaidForAgentReferrer(ctx context.Context, in *payment.LogPaidForAgentReferrer, opts ...grpc.CallOption) (*common.Empty, error)
}

type paymentMgrClient struct {
	cc *grpc.ClientConn
}

func NewPaymentMgrClient(cc *grpc.ClientConn) PaymentMgrClient {
	return &paymentMgrClient{cc}
}

func (c *paymentMgrClient) Purchase(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error) {
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/Purchase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdateSubscription(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Subscription, error) {
	out := new(payment.Subscription)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/UpdateSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetSubscription(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Subscription, error) {
	out := new(payment.Subscription)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/GetSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) AddPaymentMethod(ctx context.Context, in *payment.PaymentMethod, opts ...grpc.CallOption) (*payment.PaymentMethod, error) {
	out := new(payment.PaymentMethod)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/AddPaymentMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdatePaymentMethod(ctx context.Context, in *payment.PaymentMethod, opts ...grpc.CallOption) (*payment.PaymentMethod, error) {
	out := new(payment.PaymentMethod)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/UpdatePaymentMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) DeletePaymentMethod(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/DeletePaymentMethod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListPaymentMethods(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.PaymentMethods, error) {
	out := new(payment.PaymentMethods)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListPaymentMethods", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) Pay(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error) {
	out := new(payment.Bill)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/Pay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListInvoices(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Invoices, error) {
	out := new(payment.Invoices)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListInvoices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) CreateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error) {
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/CreateInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdateInvoice(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.Invoice, error) {
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/UpdateInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) FilterInvoices(ctx context.Context, in *payment.ListInvoiceRequest, opts ...grpc.CallOption) (*payment.Invoices, error) {
	out := new(payment.Invoices)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/FilterInvoices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) DraftInvoice(ctx context.Context, in *payment.Subscription, opts ...grpc.CallOption) (*payment.Invoice, error) {
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/DraftInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) DiffSubscriptions(ctx context.Context, in *payment.DiffSubRequest, opts ...grpc.CallOption) (*payment.Invoice, error) {
	out := new(payment.Invoice)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/DiffSubscriptions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListComments(ctx context.Context, in *payment.ListCommentsRequest, opts ...grpc.CallOption) (*payment.Comments, error) {
	out := new(payment.Comments)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListComments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) AddComment(ctx context.Context, in *payment.Comment, opts ...grpc.CallOption) (*payment.Comment, error) {
	out := new(payment.Comment)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/AddComment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListPlans(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*payment.Plans, error) {
	out := new(payment.Plans)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListPlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ExportInvoice(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.String, error) {
	out := new(payment.String)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ExportInvoice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ConvertInvoiceToHtml(ctx context.Context, in *payment.Invoice, opts ...grpc.CallOption) (*payment.String, error) {
	out := new(payment.String)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ConvertInvoiceToHtml", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetExchangeRate(ctx context.Context, in *payment.ExchangeRate, opts ...grpc.CallOption) (*payment.ExchangeRate, error) {
	out := new(payment.ExchangeRate)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/GetExchangeRate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) TransferMoney(ctx context.Context, in *payment.PayRequest, opts ...grpc.CallOption) (*payment.Bill, error) {
	out := new(payment.Bill)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/TransferMoney", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListLogs(ctx context.Context, in *payment.ListLogsRequest, opts ...grpc.CallOption) (*payment.Logs, error) {
	out := new(payment.Logs)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListLogs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) CreatePromotionCode(ctx context.Context, in *payment.PromotionCode, opts ...grpc.CallOption) (*payment.PromotionCode, error) {
	out := new(payment.PromotionCode)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/CreatePromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetPromotionCode(ctx context.Context, in *payment.String, opts ...grpc.CallOption) (*payment.PromotionCode, error) {
	out := new(payment.PromotionCode)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/GetPromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UsePromotionCode(ctx context.Context, in *payment.PromotionCodeRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/UsePromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ValidatePromotionCode(ctx context.Context, in *payment.PromotionCodeRequest, opts ...grpc.CallOption) (*payment.PromotionCode, error) {
	out := new(payment.PromotionCode)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ValidatePromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListPromotionCode(ctx context.Context, in *payment.ListPromotionCodeRequest, opts ...grpc.CallOption) (*payment.PromotionCodes, error) {
	out := new(payment.PromotionCodes)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListPromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) DeletePromotionCode(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/DeletePromotionCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) SearchReferral(ctx context.Context, in *payment.SearchReferredRequest, opts ...grpc.CallOption) (*payment.Referral, error) {
	out := new(payment.Referral)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/SearchReferral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) GetReferral(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.Referral, error) {
	out := new(payment.Referral)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/GetReferral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListTopReferral(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*payment.ReferralResponse, error) {
	out := new(payment.ReferralResponse)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListTopReferral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) UpdateReferral(ctx context.Context, in *payment.Referral, opts ...grpc.CallOption) (*payment.Referral, error) {
	out := new(payment.Referral)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/UpdateReferral", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListAccountReferred(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogAccountReferreds, error) {
	out := new(payment.LogAccountReferreds)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListAccountReferred", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListBillByAccountReferred(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogBillByAccountReferreds, error) {
	out := new(payment.LogBillByAccountReferreds)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListBillByAccountReferred", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) ListPaidForAgentReferrer(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*payment.LogPaidForAgentReferrers, error) {
	out := new(payment.LogPaidForAgentReferrers)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/ListPaidForAgentReferrer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentMgrClient) PaidForAgentReferrer(ctx context.Context, in *payment.LogPaidForAgentReferrer, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.PaymentMgr/PaidForAgentReferrer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentMgrServer is the server API for PaymentMgr service.
type PaymentMgrServer interface {
	Purchase(context.Context, *payment.Subscription) (*payment.Invoice, error)
	UpdateSubscription(context.Context, *payment.Subscription) (*payment.Subscription, error)
	GetSubscription(context.Context, *common.Id) (*payment.Subscription, error)
	AddPaymentMethod(context.Context, *payment.PaymentMethod) (*payment.PaymentMethod, error)
	UpdatePaymentMethod(context.Context, *payment.PaymentMethod) (*payment.PaymentMethod, error)
	DeletePaymentMethod(context.Context, *common.Id) (*common.Empty, error)
	ListPaymentMethods(context.Context, *common.Id) (*payment.PaymentMethods, error)
	Pay(context.Context, *payment.PayRequest) (*payment.Bill, error)
	ListInvoices(context.Context, *common.Id) (*payment.Invoices, error)
	CreateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error)
	UpdateInvoice(context.Context, *payment.Invoice) (*payment.Invoice, error)
	FilterInvoices(context.Context, *payment.ListInvoiceRequest) (*payment.Invoices, error)
	DraftInvoice(context.Context, *payment.Subscription) (*payment.Invoice, error)
	DiffSubscriptions(context.Context, *payment.DiffSubRequest) (*payment.Invoice, error)
	ListComments(context.Context, *payment.ListCommentsRequest) (*payment.Comments, error)
	AddComment(context.Context, *payment.Comment) (*payment.Comment, error)
	ListPlans(context.Context, *common.Empty) (*payment.Plans, error)
	ExportInvoice(context.Context, *common.Id) (*payment.String, error)
	ConvertInvoiceToHtml(context.Context, *payment.Invoice) (*payment.String, error)
	GetExchangeRate(context.Context, *payment.ExchangeRate) (*payment.ExchangeRate, error)
	TransferMoney(context.Context, *payment.PayRequest) (*payment.Bill, error)
	ListLogs(context.Context, *payment.ListLogsRequest) (*payment.Logs, error)
	CreatePromotionCode(context.Context, *payment.PromotionCode) (*payment.PromotionCode, error)
	GetPromotionCode(context.Context, *payment.String) (*payment.PromotionCode, error)
	UsePromotionCode(context.Context, *payment.PromotionCodeRequest) (*common.Empty, error)
	ValidatePromotionCode(context.Context, *payment.PromotionCodeRequest) (*payment.PromotionCode, error)
	ListPromotionCode(context.Context, *payment.ListPromotionCodeRequest) (*payment.PromotionCodes, error)
	DeletePromotionCode(context.Context, *common.Id) (*common.Empty, error)
	SearchReferral(context.Context, *payment.SearchReferredRequest) (*payment.Referral, error)
	GetReferral(context.Context, *common.Id) (*payment.Referral, error)
	ListTopReferral(context.Context, *common.Empty) (*payment.ReferralResponse, error)
	UpdateReferral(context.Context, *payment.Referral) (*payment.Referral, error)
	ListAccountReferred(context.Context, *common.Id) (*payment.LogAccountReferreds, error)
	ListBillByAccountReferred(context.Context, *common.Id) (*payment.LogBillByAccountReferreds, error)
	ListPaidForAgentReferrer(context.Context, *common.Id) (*payment.LogPaidForAgentReferrers, error)
	PaidForAgentReferrer(context.Context, *payment.LogPaidForAgentReferrer) (*common.Empty, error)
}

func RegisterPaymentMgrServer(s *grpc.Server, srv PaymentMgrServer) {
	s.RegisterService(&_PaymentMgr_serviceDesc, srv)
}

func _PaymentMgr_Purchase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).Purchase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/Purchase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).Purchase(ctx, req.(*payment.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/UpdateSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdateSubscription(ctx, req.(*payment.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/GetSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetSubscription(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_AddPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).AddPaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/AddPaymentMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).AddPaymentMethod(ctx, req.(*payment.PaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdatePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PaymentMethod)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdatePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/UpdatePaymentMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdatePaymentMethod(ctx, req.(*payment.PaymentMethod))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_DeletePaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).DeletePaymentMethod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/DeletePaymentMethod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).DeletePaymentMethod(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPaymentMethods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListPaymentMethods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPaymentMethods(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_Pay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).Pay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/Pay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).Pay(ctx, req.(*payment.PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListInvoices(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/CreateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).CreateInvoice(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/UpdateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdateInvoice(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_FilterInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ListInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).FilterInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/FilterInvoices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).FilterInvoices(ctx, req.(*payment.ListInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_DraftInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).DraftInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/DraftInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).DraftInvoice(ctx, req.(*payment.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_DiffSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.DiffSubRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).DiffSubscriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/DiffSubscriptions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).DiffSubscriptions(ctx, req.(*payment.DiffSubRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ListCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListComments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListComments(ctx, req.(*payment.ListCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Comment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/AddComment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).AddComment(ctx, req.(*payment.Comment))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListPlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPlans(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ExportInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ExportInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ExportInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ExportInvoice(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ConvertInvoiceToHtml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Invoice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ConvertInvoiceToHtml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ConvertInvoiceToHtml",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ConvertInvoiceToHtml(ctx, req.(*payment.Invoice))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ExchangeRate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/GetExchangeRate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetExchangeRate(ctx, req.(*payment.ExchangeRate))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_TransferMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).TransferMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/TransferMoney",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).TransferMoney(ctx, req.(*payment.PayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ListLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListLogs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListLogs(ctx, req.(*payment.ListLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_CreatePromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PromotionCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).CreatePromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/CreatePromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).CreatePromotionCode(ctx, req.(*payment.PromotionCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/GetPromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetPromotionCode(ctx, req.(*payment.String))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UsePromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PromotionCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UsePromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/UsePromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UsePromotionCode(ctx, req.(*payment.PromotionCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ValidatePromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.PromotionCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ValidatePromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ValidatePromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ValidatePromotionCode(ctx, req.(*payment.PromotionCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListPromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.ListPromotionCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListPromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPromotionCode(ctx, req.(*payment.ListPromotionCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_DeletePromotionCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).DeletePromotionCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/DeletePromotionCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).DeletePromotionCode(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_SearchReferral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.SearchReferredRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).SearchReferral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/SearchReferral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).SearchReferral(ctx, req.(*payment.SearchReferredRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_GetReferral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).GetReferral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/GetReferral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).GetReferral(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListTopReferral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListTopReferral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListTopReferral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListTopReferral(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_UpdateReferral_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.Referral)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).UpdateReferral(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/UpdateReferral",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).UpdateReferral(ctx, req.(*payment.Referral))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListAccountReferred_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListAccountReferred(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListAccountReferred",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListAccountReferred(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListBillByAccountReferred_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListBillByAccountReferred(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListBillByAccountReferred",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListBillByAccountReferred(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_ListPaidForAgentReferrer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).ListPaidForAgentReferrer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/ListPaidForAgentReferrer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).ListPaidForAgentReferrer(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentMgr_PaidForAgentReferrer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payment.LogPaidForAgentReferrer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentMgrServer).PaidForAgentReferrer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PaymentMgr/PaidForAgentReferrer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentMgrServer).PaidForAgentReferrer(ctx, req.(*payment.LogPaidForAgentReferrer))
	}
	return interceptor(ctx, in, info, handler)
}

var _PaymentMgr_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.PaymentMgr",
	HandlerType: (*PaymentMgrServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Purchase",
			Handler:    _PaymentMgr_Purchase_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _PaymentMgr_UpdateSubscription_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _PaymentMgr_GetSubscription_Handler,
		},
		{
			MethodName: "AddPaymentMethod",
			Handler:    _PaymentMgr_AddPaymentMethod_Handler,
		},
		{
			MethodName: "UpdatePaymentMethod",
			Handler:    _PaymentMgr_UpdatePaymentMethod_Handler,
		},
		{
			MethodName: "DeletePaymentMethod",
			Handler:    _PaymentMgr_DeletePaymentMethod_Handler,
		},
		{
			MethodName: "ListPaymentMethods",
			Handler:    _PaymentMgr_ListPaymentMethods_Handler,
		},
		{
			MethodName: "Pay",
			Handler:    _PaymentMgr_Pay_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _PaymentMgr_ListInvoices_Handler,
		},
		{
			MethodName: "CreateInvoice",
			Handler:    _PaymentMgr_CreateInvoice_Handler,
		},
		{
			MethodName: "UpdateInvoice",
			Handler:    _PaymentMgr_UpdateInvoice_Handler,
		},
		{
			MethodName: "FilterInvoices",
			Handler:    _PaymentMgr_FilterInvoices_Handler,
		},
		{
			MethodName: "DraftInvoice",
			Handler:    _PaymentMgr_DraftInvoice_Handler,
		},
		{
			MethodName: "DiffSubscriptions",
			Handler:    _PaymentMgr_DiffSubscriptions_Handler,
		},
		{
			MethodName: "ListComments",
			Handler:    _PaymentMgr_ListComments_Handler,
		},
		{
			MethodName: "AddComment",
			Handler:    _PaymentMgr_AddComment_Handler,
		},
		{
			MethodName: "ListPlans",
			Handler:    _PaymentMgr_ListPlans_Handler,
		},
		{
			MethodName: "ExportInvoice",
			Handler:    _PaymentMgr_ExportInvoice_Handler,
		},
		{
			MethodName: "ConvertInvoiceToHtml",
			Handler:    _PaymentMgr_ConvertInvoiceToHtml_Handler,
		},
		{
			MethodName: "GetExchangeRate",
			Handler:    _PaymentMgr_GetExchangeRate_Handler,
		},
		{
			MethodName: "TransferMoney",
			Handler:    _PaymentMgr_TransferMoney_Handler,
		},
		{
			MethodName: "ListLogs",
			Handler:    _PaymentMgr_ListLogs_Handler,
		},
		{
			MethodName: "CreatePromotionCode",
			Handler:    _PaymentMgr_CreatePromotionCode_Handler,
		},
		{
			MethodName: "GetPromotionCode",
			Handler:    _PaymentMgr_GetPromotionCode_Handler,
		},
		{
			MethodName: "UsePromotionCode",
			Handler:    _PaymentMgr_UsePromotionCode_Handler,
		},
		{
			MethodName: "ValidatePromotionCode",
			Handler:    _PaymentMgr_ValidatePromotionCode_Handler,
		},
		{
			MethodName: "ListPromotionCode",
			Handler:    _PaymentMgr_ListPromotionCode_Handler,
		},
		{
			MethodName: "DeletePromotionCode",
			Handler:    _PaymentMgr_DeletePromotionCode_Handler,
		},
		{
			MethodName: "SearchReferral",
			Handler:    _PaymentMgr_SearchReferral_Handler,
		},
		{
			MethodName: "GetReferral",
			Handler:    _PaymentMgr_GetReferral_Handler,
		},
		{
			MethodName: "ListTopReferral",
			Handler:    _PaymentMgr_ListTopReferral_Handler,
		},
		{
			MethodName: "UpdateReferral",
			Handler:    _PaymentMgr_UpdateReferral_Handler,
		},
		{
			MethodName: "ListAccountReferred",
			Handler:    _PaymentMgr_ListAccountReferred_Handler,
		},
		{
			MethodName: "ListBillByAccountReferred",
			Handler:    _PaymentMgr_ListBillByAccountReferred_Handler,
		},
		{
			MethodName: "ListPaidForAgentReferrer",
			Handler:    _PaymentMgr_ListPaidForAgentReferrer_Handler,
		},
		{
			MethodName: "PaidForAgentReferrer",
			Handler:    _PaymentMgr_PaidForAgentReferrer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// PlaceHolderClient is the client API for PlaceHolder service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PlaceHolderClient interface {
	Resolve(ctx context.Context, in *placeholder.ResolveRequest, opts ...grpc.CallOption) (*placeholder.Resolved, error)
}

type placeHolderClient struct {
	cc *grpc.ClientConn
}

func NewPlaceHolderClient(cc *grpc.ClientConn) PlaceHolderClient {
	return &placeHolderClient{cc}
}

func (c *placeHolderClient) Resolve(ctx context.Context, in *placeholder.ResolveRequest, opts ...grpc.CallOption) (*placeholder.Resolved, error) {
	out := new(placeholder.Resolved)
	err := c.cc.Invoke(ctx, "/header.PlaceHolder/Resolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PlaceHolderServer is the server API for PlaceHolder service.
type PlaceHolderServer interface {
	Resolve(context.Context, *placeholder.ResolveRequest) (*placeholder.Resolved, error)
}

func RegisterPlaceHolderServer(s *grpc.Server, srv PlaceHolderServer) {
	s.RegisterService(&_PlaceHolder_serviceDesc, srv)
}

func _PlaceHolder_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(placeholder.ResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlaceHolderServer).Resolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.PlaceHolder/Resolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlaceHolderServer).Resolve(ctx, req.(*placeholder.ResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlaceHolder_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.PlaceHolder",
	HandlerType: (*PlaceHolderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Resolve",
			Handler:    _PlaceHolder_Resolve_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// PubsubClient is the client API for Pubsub service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PubsubClient interface {
	Subscribe(ctx context.Context, in *pubsub.Subscription, opts ...grpc.CallOption) (*common.Empty, error)
	Unsubscribe(ctx context.Context, in *pubsub.Subscription, opts ...grpc.CallOption) (*common.Empty, error)
}

type pubsubClient struct {
	cc *grpc.ClientConn
}

func NewPubsubClient(cc *grpc.ClientConn) PubsubClient {
	return &pubsubClient{cc}
}

func (c *pubsubClient) Subscribe(ctx context.Context, in *pubsub.Subscription, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Pubsub/Subscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pubsubClient) Unsubscribe(ctx context.Context, in *pubsub.Subscription, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.Pubsub/Unsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PubsubServer is the server API for Pubsub service.
type PubsubServer interface {
	Subscribe(context.Context, *pubsub.Subscription) (*common.Empty, error)
	Unsubscribe(context.Context, *pubsub.Subscription) (*common.Empty, error)
}

func RegisterPubsubServer(s *grpc.Server, srv PubsubServer) {
	s.RegisterService(&_Pubsub_serviceDesc, srv)
}

func _Pubsub_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(pubsub.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Pubsub/Subscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).Subscribe(ctx, req.(*pubsub.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pubsub_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(pubsub.Subscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubsubServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.Pubsub/Unsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubsubServer).Unsubscribe(ctx, req.(*pubsub.Subscription))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pubsub_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.Pubsub",
	HandlerType: (*PubsubServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Subscribe",
			Handler:    _Pubsub_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _Pubsub_Unsubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// WidgetServiceClient is the client API for WidgetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WidgetServiceClient interface {
	Read(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*widget.Setting, error)
	Update(ctx context.Context, in *widget.Setting, opts ...grpc.CallOption) (*widget.Setting, error)
	ReadUserSetting(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*widget.UserSetting, error)
	UpdateUserSetting(ctx context.Context, in *widget.UserSetting, opts ...grpc.CallOption) (*widget.UserSetting, error)
}

type widgetServiceClient struct {
	cc *grpc.ClientConn
}

func NewWidgetServiceClient(cc *grpc.ClientConn) WidgetServiceClient {
	return &widgetServiceClient{cc}
}

func (c *widgetServiceClient) Read(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*widget.Setting, error) {
	out := new(widget.Setting)
	err := c.cc.Invoke(ctx, "/header.WidgetService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) Update(ctx context.Context, in *widget.Setting, opts ...grpc.CallOption) (*widget.Setting, error) {
	out := new(widget.Setting)
	err := c.cc.Invoke(ctx, "/header.WidgetService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) ReadUserSetting(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*widget.UserSetting, error) {
	out := new(widget.UserSetting)
	err := c.cc.Invoke(ctx, "/header.WidgetService/ReadUserSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *widgetServiceClient) UpdateUserSetting(ctx context.Context, in *widget.UserSetting, opts ...grpc.CallOption) (*widget.UserSetting, error) {
	out := new(widget.UserSetting)
	err := c.cc.Invoke(ctx, "/header.WidgetService/UpdateUserSetting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WidgetServiceServer is the server API for WidgetService service.
type WidgetServiceServer interface {
	Read(context.Context, *common.Id) (*widget.Setting, error)
	Update(context.Context, *widget.Setting) (*widget.Setting, error)
	ReadUserSetting(context.Context, *common.Id) (*widget.UserSetting, error)
	UpdateUserSetting(context.Context, *widget.UserSetting) (*widget.UserSetting, error)
}

func RegisterWidgetServiceServer(s *grpc.Server, srv WidgetServiceServer) {
	s.RegisterService(&_WidgetService_serviceDesc, srv)
}

func _WidgetService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WidgetService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).Read(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(widget.Setting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WidgetService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).Update(ctx, req.(*widget.Setting))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_ReadUserSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).ReadUserSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WidgetService/ReadUserSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).ReadUserSetting(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WidgetService_UpdateUserSetting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(widget.UserSetting)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WidgetServiceServer).UpdateUserSetting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WidgetService/UpdateUserSetting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WidgetServiceServer).UpdateUserSetting(ctx, req.(*widget.UserSetting))
	}
	return interceptor(ctx, in, info, handler)
}

var _WidgetService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.WidgetService",
	HandlerType: (*WidgetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _WidgetService_Read_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _WidgetService_Update_Handler,
		},
		{
			MethodName: "ReadUserSetting",
			Handler:    _WidgetService_ReadUserSetting_Handler,
		},
		{
			MethodName: "UpdateUserSetting",
			Handler:    _WidgetService_UpdateUserSetting_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ServiceAvatarManagerClient is the client API for ServiceAvatarManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServiceAvatarManagerClient interface {
	GetAvatar(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*avatar.Avatar, error)
	UpsertAvatar(ctx context.Context, in *avatar.Avatar, opts ...grpc.CallOption) (*common.Empty, error)
}

type serviceAvatarManagerClient struct {
	cc *grpc.ClientConn
}

func NewServiceAvatarManagerClient(cc *grpc.ClientConn) ServiceAvatarManagerClient {
	return &serviceAvatarManagerClient{cc}
}

func (c *serviceAvatarManagerClient) GetAvatar(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*avatar.Avatar, error) {
	out := new(avatar.Avatar)
	err := c.cc.Invoke(ctx, "/header.ServiceAvatarManager/GetAvatar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAvatarManagerClient) UpsertAvatar(ctx context.Context, in *avatar.Avatar, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.ServiceAvatarManager/UpsertAvatar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceAvatarManagerServer is the server API for ServiceAvatarManager service.
type ServiceAvatarManagerServer interface {
	GetAvatar(context.Context, *common.Id) (*avatar.Avatar, error)
	UpsertAvatar(context.Context, *avatar.Avatar) (*common.Empty, error)
}

func RegisterServiceAvatarManagerServer(s *grpc.Server, srv ServiceAvatarManagerServer) {
	s.RegisterService(&_ServiceAvatarManager_serviceDesc, srv)
}

func _ServiceAvatarManager_GetAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAvatarManagerServer).GetAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceAvatarManager/GetAvatar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAvatarManagerServer).GetAvatar(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAvatarManager_UpsertAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(avatar.Avatar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAvatarManagerServer).UpsertAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.ServiceAvatarManager/UpsertAvatar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAvatarManagerServer).UpsertAvatar(ctx, req.(*avatar.Avatar))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceAvatarManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.ServiceAvatarManager",
	HandlerType: (*ServiceAvatarManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAvatar",
			Handler:    _ServiceAvatarManager_GetAvatar_Handler,
		},
		{
			MethodName: "UpsertAvatar",
			Handler:    _ServiceAvatarManager_UpsertAvatar_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// WebhookServiceClient is the client API for WebhookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebhookServiceClient interface {
	Read(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.Webhook, error)
	Delete(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error)
	List(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.Webhooks, error)
	Update(ctx context.Context, in *client.Webhook, opts ...grpc.CallOption) (*client.Webhook, error)
	Create(ctx context.Context, in *client.Webhook, opts ...grpc.CallOption) (*client.Webhook, error)
	Test(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.WebhookTestResult, error)
}

type webhookServiceClient struct {
	cc *grpc.ClientConn
}

func NewWebhookServiceClient(cc *grpc.ClientConn) WebhookServiceClient {
	return &webhookServiceClient{cc}
}

func (c *webhookServiceClient) Read(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.Webhook, error) {
	out := new(client.Webhook)
	err := c.cc.Invoke(ctx, "/header.WebhookService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) Delete(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/header.WebhookService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) List(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.Webhooks, error) {
	out := new(client.Webhooks)
	err := c.cc.Invoke(ctx, "/header.WebhookService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) Update(ctx context.Context, in *client.Webhook, opts ...grpc.CallOption) (*client.Webhook, error) {
	out := new(client.Webhook)
	err := c.cc.Invoke(ctx, "/header.WebhookService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) Create(ctx context.Context, in *client.Webhook, opts ...grpc.CallOption) (*client.Webhook, error) {
	out := new(client.Webhook)
	err := c.cc.Invoke(ctx, "/header.WebhookService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webhookServiceClient) Test(ctx context.Context, in *common.Id, opts ...grpc.CallOption) (*client.WebhookTestResult, error) {
	out := new(client.WebhookTestResult)
	err := c.cc.Invoke(ctx, "/header.WebhookService/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebhookServiceServer is the server API for WebhookService service.
type WebhookServiceServer interface {
	Read(context.Context, *common.Id) (*client.Webhook, error)
	Delete(context.Context, *common.Id) (*common.Empty, error)
	List(context.Context, *common.Id) (*client.Webhooks, error)
	Update(context.Context, *client.Webhook) (*client.Webhook, error)
	Create(context.Context, *client.Webhook) (*client.Webhook, error)
	Test(context.Context, *common.Id) (*client.WebhookTestResult, error)
}

func RegisterWebhookServiceServer(s *grpc.Server, srv WebhookServiceServer) {
	s.RegisterService(&_WebhookService_serviceDesc, srv)
}

func _WebhookService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).Read(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).Delete(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).List(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(client.Webhook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).Update(ctx, req.(*client.Webhook))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(client.Webhook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).Create(ctx, req.(*client.Webhook))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebhookService_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebhookServiceServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/header.WebhookService/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebhookServiceServer).Test(ctx, req.(*common.Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _WebhookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "header.WebhookService",
	HandlerType: (*WebhookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Read",
			Handler:    _WebhookService_Read_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _WebhookService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _WebhookService_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _WebhookService_Update_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _WebhookService_Create_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _WebhookService_Test_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

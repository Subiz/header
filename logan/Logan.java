// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitbucket.org/subiz/header/logan/logan.proto

package logan;

public final class Logan {
  private Logan() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * Protobuf enum {@code logan.Level}
   */
  public enum Level
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>debug = 0;</code>
     */
    debug(0),
    /**
     * <code>info = 1;</code>
     */
    info(1),
    /**
     * <code>notice = 2;</code>
     */
    notice(2),
    /**
     * <code>warning = 3;</code>
     */
    warning(3),
    /**
     * <code>error = 4;</code>
     */
    error(4),
    /**
     * <code>critical = 5;</code>
     */
    critical(5),
    /**
     * <code>alert = 6;</code>
     */
    alert(6),
    /**
     * <code>emergency = 7;</code>
     */
    emergency(7),
    /**
     * <code>panic = 8;</code>
     */
    panic(8),
    /**
     * <code>fatal = 9;</code>
     */
    fatal(9),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>debug = 0;</code>
     */
    public static final int debug_VALUE = 0;
    /**
     * <code>info = 1;</code>
     */
    public static final int info_VALUE = 1;
    /**
     * <code>notice = 2;</code>
     */
    public static final int notice_VALUE = 2;
    /**
     * <code>warning = 3;</code>
     */
    public static final int warning_VALUE = 3;
    /**
     * <code>error = 4;</code>
     */
    public static final int error_VALUE = 4;
    /**
     * <code>critical = 5;</code>
     */
    public static final int critical_VALUE = 5;
    /**
     * <code>alert = 6;</code>
     */
    public static final int alert_VALUE = 6;
    /**
     * <code>emergency = 7;</code>
     */
    public static final int emergency_VALUE = 7;
    /**
     * <code>panic = 8;</code>
     */
    public static final int panic_VALUE = 8;
    /**
     * <code>fatal = 9;</code>
     */
    public static final int fatal_VALUE = 9;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Level valueOf(int value) {
      return forNumber(value);
    }

    public static Level forNumber(int value) {
      switch (value) {
        case 0: return debug;
        case 1: return info;
        case 2: return notice;
        case 3: return warning;
        case 4: return error;
        case 5: return critical;
        case 6: return alert;
        case 7: return emergency;
        case 8: return panic;
        case 9: return fatal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Level>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Level> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Level>() {
            public Level findValueByNumber(int number) {
              return Level.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return logan.Logan.getDescriptor().getEnumTypes().get(0);
    }

    private static final Level[] VALUES = values();

    public static Level valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Level(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:logan.Level)
  }

  /**
   * Protobuf enum {@code logan.Event}
   */
  public enum Event
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>LogLogRequested = 0;</code>
     */
    LogLogRequested(0),
    /**
     * <code>LogRequested = 1000;</code>
     */
    LogRequested(1000),
    /**
     * <code>LogSynced = 1001;</code>
     */
    LogSynced(1001),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>LogLogRequested = 0;</code>
     */
    public static final int LogLogRequested_VALUE = 0;
    /**
     * <code>LogRequested = 1000;</code>
     */
    public static final int LogRequested_VALUE = 1000;
    /**
     * <code>LogSynced = 1001;</code>
     */
    public static final int LogSynced_VALUE = 1001;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Event valueOf(int value) {
      return forNumber(value);
    }

    public static Event forNumber(int value) {
      switch (value) {
        case 0: return LogLogRequested;
        case 1000: return LogRequested;
        case 1001: return LogSynced;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Event>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Event> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Event>() {
            public Event findValueByNumber(int number) {
              return Event.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return logan.Logan.getDescriptor().getEnumTypes().get(1);
    }

    private static final Event[] VALUES = values();

    public static Event valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Event(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:logan.Event)
  }

  public interface DebugOrBuilder extends
      // @@protoc_insertion_point(interface_extends:logan.Debug)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    boolean hasMemStats();
    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    logan.Logan.MemStats getMemStats();
    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    logan.Logan.MemStatsOrBuilder getMemStatsOrBuilder();

    /**
     * <code>int32 num_cpu = 3;</code>
     */
    int getNumCpu();

    /**
     * <code>int32 num_goroutine = 4;</code>
     */
    int getNumGoroutine();

    /**
     * <code>bytes stack_trace = 5;</code>
     */
    com.google.protobuf.ByteString getStackTrace();

    /**
     * <code>string hostname = 6;</code>
     */
    java.lang.String getHostname();
    /**
     * <code>string hostname = 6;</code>
     */
    com.google.protobuf.ByteString
        getHostnameBytes();

    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    boolean hasKafka();
    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    logan.Logan.KafkaInfo getKafka();
    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    logan.Logan.KafkaInfoOrBuilder getKafkaOrBuilder();
  }
  /**
   * Protobuf type {@code logan.Debug}
   */
  public  static final class Debug extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:logan.Debug)
      DebugOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Debug.newBuilder() to construct.
    private Debug(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Debug() {
      numCpu_ = 0;
      numGoroutine_ = 0;
      stackTrace_ = com.google.protobuf.ByteString.EMPTY;
      hostname_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Debug(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 18: {
              logan.Logan.MemStats.Builder subBuilder = null;
              if (memStats_ != null) {
                subBuilder = memStats_.toBuilder();
              }
              memStats_ = input.readMessage(logan.Logan.MemStats.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(memStats_);
                memStats_ = subBuilder.buildPartial();
              }

              break;
            }
            case 24: {

              numCpu_ = input.readInt32();
              break;
            }
            case 32: {

              numGoroutine_ = input.readInt32();
              break;
            }
            case 42: {

              stackTrace_ = input.readBytes();
              break;
            }
            case 50: {
              java.lang.String s = input.readStringRequireUtf8();

              hostname_ = s;
              break;
            }
            case 186: {
              logan.Logan.KafkaInfo.Builder subBuilder = null;
              if (kafka_ != null) {
                subBuilder = kafka_.toBuilder();
              }
              kafka_ = input.readMessage(logan.Logan.KafkaInfo.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(kafka_);
                kafka_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return logan.Logan.internal_static_logan_Debug_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return logan.Logan.internal_static_logan_Debug_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              logan.Logan.Debug.class, logan.Logan.Debug.Builder.class);
    }

    public static final int MEM_STATS_FIELD_NUMBER = 2;
    private logan.Logan.MemStats memStats_;
    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    public boolean hasMemStats() {
      return memStats_ != null;
    }
    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    public logan.Logan.MemStats getMemStats() {
      return memStats_ == null ? logan.Logan.MemStats.getDefaultInstance() : memStats_;
    }
    /**
     * <code>.logan.MemStats mem_stats = 2;</code>
     */
    public logan.Logan.MemStatsOrBuilder getMemStatsOrBuilder() {
      return getMemStats();
    }

    public static final int NUM_CPU_FIELD_NUMBER = 3;
    private int numCpu_;
    /**
     * <code>int32 num_cpu = 3;</code>
     */
    public int getNumCpu() {
      return numCpu_;
    }

    public static final int NUM_GOROUTINE_FIELD_NUMBER = 4;
    private int numGoroutine_;
    /**
     * <code>int32 num_goroutine = 4;</code>
     */
    public int getNumGoroutine() {
      return numGoroutine_;
    }

    public static final int STACK_TRACE_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString stackTrace_;
    /**
     * <code>bytes stack_trace = 5;</code>
     */
    public com.google.protobuf.ByteString getStackTrace() {
      return stackTrace_;
    }

    public static final int HOSTNAME_FIELD_NUMBER = 6;
    private volatile java.lang.Object hostname_;
    /**
     * <code>string hostname = 6;</code>
     */
    public java.lang.String getHostname() {
      java.lang.Object ref = hostname_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        hostname_ = s;
        return s;
      }
    }
    /**
     * <code>string hostname = 6;</code>
     */
    public com.google.protobuf.ByteString
        getHostnameBytes() {
      java.lang.Object ref = hostname_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hostname_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KAFKA_FIELD_NUMBER = 23;
    private logan.Logan.KafkaInfo kafka_;
    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    public boolean hasKafka() {
      return kafka_ != null;
    }
    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    public logan.Logan.KafkaInfo getKafka() {
      return kafka_ == null ? logan.Logan.KafkaInfo.getDefaultInstance() : kafka_;
    }
    /**
     * <code>.logan.KafkaInfo kafka = 23;</code>
     */
    public logan.Logan.KafkaInfoOrBuilder getKafkaOrBuilder() {
      return getKafka();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (memStats_ != null) {
        output.writeMessage(2, getMemStats());
      }
      if (numCpu_ != 0) {
        output.writeInt32(3, numCpu_);
      }
      if (numGoroutine_ != 0) {
        output.writeInt32(4, numGoroutine_);
      }
      if (!stackTrace_.isEmpty()) {
        output.writeBytes(5, stackTrace_);
      }
      if (!getHostnameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, hostname_);
      }
      if (kafka_ != null) {
        output.writeMessage(23, getKafka());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (memStats_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getMemStats());
      }
      if (numCpu_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, numCpu_);
      }
      if (numGoroutine_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, numGoroutine_);
      }
      if (!stackTrace_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, stackTrace_);
      }
      if (!getHostnameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, hostname_);
      }
      if (kafka_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(23, getKafka());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof logan.Logan.Debug)) {
        return super.equals(obj);
      }
      logan.Logan.Debug other = (logan.Logan.Debug) obj;

      boolean result = true;
      result = result && (hasMemStats() == other.hasMemStats());
      if (hasMemStats()) {
        result = result && getMemStats()
            .equals(other.getMemStats());
      }
      result = result && (getNumCpu()
          == other.getNumCpu());
      result = result && (getNumGoroutine()
          == other.getNumGoroutine());
      result = result && getStackTrace()
          .equals(other.getStackTrace());
      result = result && getHostname()
          .equals(other.getHostname());
      result = result && (hasKafka() == other.hasKafka());
      if (hasKafka()) {
        result = result && getKafka()
            .equals(other.getKafka());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMemStats()) {
        hash = (37 * hash) + MEM_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getMemStats().hashCode();
      }
      hash = (37 * hash) + NUM_CPU_FIELD_NUMBER;
      hash = (53 * hash) + getNumCpu();
      hash = (37 * hash) + NUM_GOROUTINE_FIELD_NUMBER;
      hash = (53 * hash) + getNumGoroutine();
      hash = (37 * hash) + STACK_TRACE_FIELD_NUMBER;
      hash = (53 * hash) + getStackTrace().hashCode();
      hash = (37 * hash) + HOSTNAME_FIELD_NUMBER;
      hash = (53 * hash) + getHostname().hashCode();
      if (hasKafka()) {
        hash = (37 * hash) + KAFKA_FIELD_NUMBER;
        hash = (53 * hash) + getKafka().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static logan.Logan.Debug parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Debug parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Debug parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Debug parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Debug parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Debug parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Debug parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.Debug parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.Debug parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static logan.Logan.Debug parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.Debug parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.Debug parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(logan.Logan.Debug prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code logan.Debug}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:logan.Debug)
        logan.Logan.DebugOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return logan.Logan.internal_static_logan_Debug_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return logan.Logan.internal_static_logan_Debug_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                logan.Logan.Debug.class, logan.Logan.Debug.Builder.class);
      }

      // Construct using logan.Logan.Debug.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (memStatsBuilder_ == null) {
          memStats_ = null;
        } else {
          memStats_ = null;
          memStatsBuilder_ = null;
        }
        numCpu_ = 0;

        numGoroutine_ = 0;

        stackTrace_ = com.google.protobuf.ByteString.EMPTY;

        hostname_ = "";

        if (kafkaBuilder_ == null) {
          kafka_ = null;
        } else {
          kafka_ = null;
          kafkaBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return logan.Logan.internal_static_logan_Debug_descriptor;
      }

      public logan.Logan.Debug getDefaultInstanceForType() {
        return logan.Logan.Debug.getDefaultInstance();
      }

      public logan.Logan.Debug build() {
        logan.Logan.Debug result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public logan.Logan.Debug buildPartial() {
        logan.Logan.Debug result = new logan.Logan.Debug(this);
        if (memStatsBuilder_ == null) {
          result.memStats_ = memStats_;
        } else {
          result.memStats_ = memStatsBuilder_.build();
        }
        result.numCpu_ = numCpu_;
        result.numGoroutine_ = numGoroutine_;
        result.stackTrace_ = stackTrace_;
        result.hostname_ = hostname_;
        if (kafkaBuilder_ == null) {
          result.kafka_ = kafka_;
        } else {
          result.kafka_ = kafkaBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof logan.Logan.Debug) {
          return mergeFrom((logan.Logan.Debug)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(logan.Logan.Debug other) {
        if (other == logan.Logan.Debug.getDefaultInstance()) return this;
        if (other.hasMemStats()) {
          mergeMemStats(other.getMemStats());
        }
        if (other.getNumCpu() != 0) {
          setNumCpu(other.getNumCpu());
        }
        if (other.getNumGoroutine() != 0) {
          setNumGoroutine(other.getNumGoroutine());
        }
        if (other.getStackTrace() != com.google.protobuf.ByteString.EMPTY) {
          setStackTrace(other.getStackTrace());
        }
        if (!other.getHostname().isEmpty()) {
          hostname_ = other.hostname_;
          onChanged();
        }
        if (other.hasKafka()) {
          mergeKafka(other.getKafka());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        logan.Logan.Debug parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (logan.Logan.Debug) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private logan.Logan.MemStats memStats_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.MemStats, logan.Logan.MemStats.Builder, logan.Logan.MemStatsOrBuilder> memStatsBuilder_;
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public boolean hasMemStats() {
        return memStatsBuilder_ != null || memStats_ != null;
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public logan.Logan.MemStats getMemStats() {
        if (memStatsBuilder_ == null) {
          return memStats_ == null ? logan.Logan.MemStats.getDefaultInstance() : memStats_;
        } else {
          return memStatsBuilder_.getMessage();
        }
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public Builder setMemStats(logan.Logan.MemStats value) {
        if (memStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          memStats_ = value;
          onChanged();
        } else {
          memStatsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public Builder setMemStats(
          logan.Logan.MemStats.Builder builderForValue) {
        if (memStatsBuilder_ == null) {
          memStats_ = builderForValue.build();
          onChanged();
        } else {
          memStatsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public Builder mergeMemStats(logan.Logan.MemStats value) {
        if (memStatsBuilder_ == null) {
          if (memStats_ != null) {
            memStats_ =
              logan.Logan.MemStats.newBuilder(memStats_).mergeFrom(value).buildPartial();
          } else {
            memStats_ = value;
          }
          onChanged();
        } else {
          memStatsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public Builder clearMemStats() {
        if (memStatsBuilder_ == null) {
          memStats_ = null;
          onChanged();
        } else {
          memStats_ = null;
          memStatsBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public logan.Logan.MemStats.Builder getMemStatsBuilder() {
        
        onChanged();
        return getMemStatsFieldBuilder().getBuilder();
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      public logan.Logan.MemStatsOrBuilder getMemStatsOrBuilder() {
        if (memStatsBuilder_ != null) {
          return memStatsBuilder_.getMessageOrBuilder();
        } else {
          return memStats_ == null ?
              logan.Logan.MemStats.getDefaultInstance() : memStats_;
        }
      }
      /**
       * <code>.logan.MemStats mem_stats = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.MemStats, logan.Logan.MemStats.Builder, logan.Logan.MemStatsOrBuilder> 
          getMemStatsFieldBuilder() {
        if (memStatsBuilder_ == null) {
          memStatsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              logan.Logan.MemStats, logan.Logan.MemStats.Builder, logan.Logan.MemStatsOrBuilder>(
                  getMemStats(),
                  getParentForChildren(),
                  isClean());
          memStats_ = null;
        }
        return memStatsBuilder_;
      }

      private int numCpu_ ;
      /**
       * <code>int32 num_cpu = 3;</code>
       */
      public int getNumCpu() {
        return numCpu_;
      }
      /**
       * <code>int32 num_cpu = 3;</code>
       */
      public Builder setNumCpu(int value) {
        
        numCpu_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int32 num_cpu = 3;</code>
       */
      public Builder clearNumCpu() {
        
        numCpu_ = 0;
        onChanged();
        return this;
      }

      private int numGoroutine_ ;
      /**
       * <code>int32 num_goroutine = 4;</code>
       */
      public int getNumGoroutine() {
        return numGoroutine_;
      }
      /**
       * <code>int32 num_goroutine = 4;</code>
       */
      public Builder setNumGoroutine(int value) {
        
        numGoroutine_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int32 num_goroutine = 4;</code>
       */
      public Builder clearNumGoroutine() {
        
        numGoroutine_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString stackTrace_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes stack_trace = 5;</code>
       */
      public com.google.protobuf.ByteString getStackTrace() {
        return stackTrace_;
      }
      /**
       * <code>bytes stack_trace = 5;</code>
       */
      public Builder setStackTrace(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stackTrace_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bytes stack_trace = 5;</code>
       */
      public Builder clearStackTrace() {
        
        stackTrace_ = getDefaultInstance().getStackTrace();
        onChanged();
        return this;
      }

      private java.lang.Object hostname_ = "";
      /**
       * <code>string hostname = 6;</code>
       */
      public java.lang.String getHostname() {
        java.lang.Object ref = hostname_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          hostname_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string hostname = 6;</code>
       */
      public com.google.protobuf.ByteString
          getHostnameBytes() {
        java.lang.Object ref = hostname_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hostname_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string hostname = 6;</code>
       */
      public Builder setHostname(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        hostname_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string hostname = 6;</code>
       */
      public Builder clearHostname() {
        
        hostname_ = getDefaultInstance().getHostname();
        onChanged();
        return this;
      }
      /**
       * <code>string hostname = 6;</code>
       */
      public Builder setHostnameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        hostname_ = value;
        onChanged();
        return this;
      }

      private logan.Logan.KafkaInfo kafka_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.KafkaInfo, logan.Logan.KafkaInfo.Builder, logan.Logan.KafkaInfoOrBuilder> kafkaBuilder_;
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public boolean hasKafka() {
        return kafkaBuilder_ != null || kafka_ != null;
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public logan.Logan.KafkaInfo getKafka() {
        if (kafkaBuilder_ == null) {
          return kafka_ == null ? logan.Logan.KafkaInfo.getDefaultInstance() : kafka_;
        } else {
          return kafkaBuilder_.getMessage();
        }
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public Builder setKafka(logan.Logan.KafkaInfo value) {
        if (kafkaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          kafka_ = value;
          onChanged();
        } else {
          kafkaBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public Builder setKafka(
          logan.Logan.KafkaInfo.Builder builderForValue) {
        if (kafkaBuilder_ == null) {
          kafka_ = builderForValue.build();
          onChanged();
        } else {
          kafkaBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public Builder mergeKafka(logan.Logan.KafkaInfo value) {
        if (kafkaBuilder_ == null) {
          if (kafka_ != null) {
            kafka_ =
              logan.Logan.KafkaInfo.newBuilder(kafka_).mergeFrom(value).buildPartial();
          } else {
            kafka_ = value;
          }
          onChanged();
        } else {
          kafkaBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public Builder clearKafka() {
        if (kafkaBuilder_ == null) {
          kafka_ = null;
          onChanged();
        } else {
          kafka_ = null;
          kafkaBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public logan.Logan.KafkaInfo.Builder getKafkaBuilder() {
        
        onChanged();
        return getKafkaFieldBuilder().getBuilder();
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      public logan.Logan.KafkaInfoOrBuilder getKafkaOrBuilder() {
        if (kafkaBuilder_ != null) {
          return kafkaBuilder_.getMessageOrBuilder();
        } else {
          return kafka_ == null ?
              logan.Logan.KafkaInfo.getDefaultInstance() : kafka_;
        }
      }
      /**
       * <code>.logan.KafkaInfo kafka = 23;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.KafkaInfo, logan.Logan.KafkaInfo.Builder, logan.Logan.KafkaInfoOrBuilder> 
          getKafkaFieldBuilder() {
        if (kafkaBuilder_ == null) {
          kafkaBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              logan.Logan.KafkaInfo, logan.Logan.KafkaInfo.Builder, logan.Logan.KafkaInfoOrBuilder>(
                  getKafka(),
                  getParentForChildren(),
                  isClean());
          kafka_ = null;
        }
        return kafkaBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:logan.Debug)
    }

    // @@protoc_insertion_point(class_scope:logan.Debug)
    private static final logan.Logan.Debug DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new logan.Logan.Debug();
    }

    public static logan.Logan.Debug getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Debug>
        PARSER = new com.google.protobuf.AbstractParser<Debug>() {
      public Debug parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new Debug(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Debug> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Debug> getParserForType() {
      return PARSER;
    }

    public logan.Logan.Debug getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KafkaInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:logan.KafkaInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string topic = 2;</code>
     */
    java.lang.String getTopic();
    /**
     * <code>string topic = 2;</code>
     */
    com.google.protobuf.ByteString
        getTopicBytes();

    /**
     * <code>int32 partition = 3;</code>
     */
    int getPartition();

    /**
     * <code>int64 offset = 4;</code>
     */
    long getOffset();
  }
  /**
   * Protobuf type {@code logan.KafkaInfo}
   */
  public  static final class KafkaInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:logan.KafkaInfo)
      KafkaInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use KafkaInfo.newBuilder() to construct.
    private KafkaInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KafkaInfo() {
      topic_ = "";
      partition_ = 0;
      offset_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private KafkaInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              topic_ = s;
              break;
            }
            case 24: {

              partition_ = input.readInt32();
              break;
            }
            case 32: {

              offset_ = input.readInt64();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return logan.Logan.internal_static_logan_KafkaInfo_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return logan.Logan.internal_static_logan_KafkaInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              logan.Logan.KafkaInfo.class, logan.Logan.KafkaInfo.Builder.class);
    }

    public static final int TOPIC_FIELD_NUMBER = 2;
    private volatile java.lang.Object topic_;
    /**
     * <code>string topic = 2;</code>
     */
    public java.lang.String getTopic() {
      java.lang.Object ref = topic_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        topic_ = s;
        return s;
      }
    }
    /**
     * <code>string topic = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTopicBytes() {
      java.lang.Object ref = topic_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        topic_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARTITION_FIELD_NUMBER = 3;
    private int partition_;
    /**
     * <code>int32 partition = 3;</code>
     */
    public int getPartition() {
      return partition_;
    }

    public static final int OFFSET_FIELD_NUMBER = 4;
    private long offset_;
    /**
     * <code>int64 offset = 4;</code>
     */
    public long getOffset() {
      return offset_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getTopicBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, topic_);
      }
      if (partition_ != 0) {
        output.writeInt32(3, partition_);
      }
      if (offset_ != 0L) {
        output.writeInt64(4, offset_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getTopicBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, topic_);
      }
      if (partition_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, partition_);
      }
      if (offset_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, offset_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof logan.Logan.KafkaInfo)) {
        return super.equals(obj);
      }
      logan.Logan.KafkaInfo other = (logan.Logan.KafkaInfo) obj;

      boolean result = true;
      result = result && getTopic()
          .equals(other.getTopic());
      result = result && (getPartition()
          == other.getPartition());
      result = result && (getOffset()
          == other.getOffset());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TOPIC_FIELD_NUMBER;
      hash = (53 * hash) + getTopic().hashCode();
      hash = (37 * hash) + PARTITION_FIELD_NUMBER;
      hash = (53 * hash) + getPartition();
      hash = (37 * hash) + OFFSET_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getOffset());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static logan.Logan.KafkaInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.KafkaInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.KafkaInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.KafkaInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static logan.Logan.KafkaInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.KafkaInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(logan.Logan.KafkaInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code logan.KafkaInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:logan.KafkaInfo)
        logan.Logan.KafkaInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return logan.Logan.internal_static_logan_KafkaInfo_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return logan.Logan.internal_static_logan_KafkaInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                logan.Logan.KafkaInfo.class, logan.Logan.KafkaInfo.Builder.class);
      }

      // Construct using logan.Logan.KafkaInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        topic_ = "";

        partition_ = 0;

        offset_ = 0L;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return logan.Logan.internal_static_logan_KafkaInfo_descriptor;
      }

      public logan.Logan.KafkaInfo getDefaultInstanceForType() {
        return logan.Logan.KafkaInfo.getDefaultInstance();
      }

      public logan.Logan.KafkaInfo build() {
        logan.Logan.KafkaInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public logan.Logan.KafkaInfo buildPartial() {
        logan.Logan.KafkaInfo result = new logan.Logan.KafkaInfo(this);
        result.topic_ = topic_;
        result.partition_ = partition_;
        result.offset_ = offset_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof logan.Logan.KafkaInfo) {
          return mergeFrom((logan.Logan.KafkaInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(logan.Logan.KafkaInfo other) {
        if (other == logan.Logan.KafkaInfo.getDefaultInstance()) return this;
        if (!other.getTopic().isEmpty()) {
          topic_ = other.topic_;
          onChanged();
        }
        if (other.getPartition() != 0) {
          setPartition(other.getPartition());
        }
        if (other.getOffset() != 0L) {
          setOffset(other.getOffset());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        logan.Logan.KafkaInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (logan.Logan.KafkaInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object topic_ = "";
      /**
       * <code>string topic = 2;</code>
       */
      public java.lang.String getTopic() {
        java.lang.Object ref = topic_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          topic_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string topic = 2;</code>
       */
      public com.google.protobuf.ByteString
          getTopicBytes() {
        java.lang.Object ref = topic_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          topic_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string topic = 2;</code>
       */
      public Builder setTopic(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        topic_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string topic = 2;</code>
       */
      public Builder clearTopic() {
        
        topic_ = getDefaultInstance().getTopic();
        onChanged();
        return this;
      }
      /**
       * <code>string topic = 2;</code>
       */
      public Builder setTopicBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        topic_ = value;
        onChanged();
        return this;
      }

      private int partition_ ;
      /**
       * <code>int32 partition = 3;</code>
       */
      public int getPartition() {
        return partition_;
      }
      /**
       * <code>int32 partition = 3;</code>
       */
      public Builder setPartition(int value) {
        
        partition_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int32 partition = 3;</code>
       */
      public Builder clearPartition() {
        
        partition_ = 0;
        onChanged();
        return this;
      }

      private long offset_ ;
      /**
       * <code>int64 offset = 4;</code>
       */
      public long getOffset() {
        return offset_;
      }
      /**
       * <code>int64 offset = 4;</code>
       */
      public Builder setOffset(long value) {
        
        offset_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 offset = 4;</code>
       */
      public Builder clearOffset() {
        
        offset_ = 0L;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:logan.KafkaInfo)
    }

    // @@protoc_insertion_point(class_scope:logan.KafkaInfo)
    private static final logan.Logan.KafkaInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new logan.Logan.KafkaInfo();
    }

    public static logan.Logan.KafkaInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<KafkaInfo>
        PARSER = new com.google.protobuf.AbstractParser<KafkaInfo>() {
      public KafkaInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new KafkaInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<KafkaInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KafkaInfo> getParserForType() {
      return PARSER;
    }

    public logan.Logan.KafkaInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface LogOrBuilder extends
      // @@protoc_insertion_point(interface_extends:logan.Log)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.common.Context ctx = 1;</code>
     */
    boolean hasCtx();
    /**
     * <code>.common.Context ctx = 1;</code>
     */
    common.Common.Context getCtx();
    /**
     * <code>.common.Context ctx = 1;</code>
     */
    common.Common.ContextOrBuilder getCtxOrBuilder();

    /**
     * <code>string trace_id = 2;</code>
     */
    java.lang.String getTraceId();
    /**
     * <code>string trace_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getTraceIdBytes();

    /**
     * <code>int64 created = 8;</code>
     */
    long getCreated();

    /**
     * <code>string level = 10;</code>
     */
    java.lang.String getLevel();
    /**
     * <code>string level = 10;</code>
     */
    com.google.protobuf.ByteString
        getLevelBytes();

    /**
     * <code>repeated string tags = 4;</code>
     */
    java.util.List<java.lang.String>
        getTagsList();
    /**
     * <code>repeated string tags = 4;</code>
     */
    int getTagsCount();
    /**
     * <code>repeated string tags = 4;</code>
     */
    java.lang.String getTags(int index);
    /**
     * <code>repeated string tags = 4;</code>
     */
    com.google.protobuf.ByteString
        getTagsBytes(int index);

    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    boolean hasDebug();
    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    logan.Logan.Debug getDebug();
    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    logan.Logan.DebugOrBuilder getDebugOrBuilder();

    /**
     * <code>bytes message = 24;</code>
     */
    com.google.protobuf.ByteString getMessage();
  }
  /**
   * Protobuf type {@code logan.Log}
   */
  public  static final class Log extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:logan.Log)
      LogOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Log.newBuilder() to construct.
    private Log(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Log() {
      traceId_ = "";
      created_ = 0L;
      level_ = "";
      tags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      message_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Log(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              common.Common.Context.Builder subBuilder = null;
              if (ctx_ != null) {
                subBuilder = ctx_.toBuilder();
              }
              ctx_ = input.readMessage(common.Common.Context.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ctx_);
                ctx_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              traceId_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                tags_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000010;
              }
              tags_.add(s);
              break;
            }
            case 64: {

              created_ = input.readInt64();
              break;
            }
            case 82: {
              java.lang.String s = input.readStringRequireUtf8();

              level_ = s;
              break;
            }
            case 178: {
              logan.Logan.Debug.Builder subBuilder = null;
              if (debug_ != null) {
                subBuilder = debug_.toBuilder();
              }
              debug_ = input.readMessage(logan.Logan.Debug.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(debug_);
                debug_ = subBuilder.buildPartial();
              }

              break;
            }
            case 194: {

              message_ = input.readBytes();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          tags_ = tags_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return logan.Logan.internal_static_logan_Log_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return logan.Logan.internal_static_logan_Log_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              logan.Logan.Log.class, logan.Logan.Log.Builder.class);
    }

    private int bitField0_;
    public static final int CTX_FIELD_NUMBER = 1;
    private common.Common.Context ctx_;
    /**
     * <code>.common.Context ctx = 1;</code>
     */
    public boolean hasCtx() {
      return ctx_ != null;
    }
    /**
     * <code>.common.Context ctx = 1;</code>
     */
    public common.Common.Context getCtx() {
      return ctx_ == null ? common.Common.Context.getDefaultInstance() : ctx_;
    }
    /**
     * <code>.common.Context ctx = 1;</code>
     */
    public common.Common.ContextOrBuilder getCtxOrBuilder() {
      return getCtx();
    }

    public static final int TRACE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object traceId_;
    /**
     * <code>string trace_id = 2;</code>
     */
    public java.lang.String getTraceId() {
      java.lang.Object ref = traceId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        traceId_ = s;
        return s;
      }
    }
    /**
     * <code>string trace_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTraceIdBytes() {
      java.lang.Object ref = traceId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        traceId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CREATED_FIELD_NUMBER = 8;
    private long created_;
    /**
     * <code>int64 created = 8;</code>
     */
    public long getCreated() {
      return created_;
    }

    public static final int LEVEL_FIELD_NUMBER = 10;
    private volatile java.lang.Object level_;
    /**
     * <code>string level = 10;</code>
     */
    public java.lang.String getLevel() {
      java.lang.Object ref = level_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        level_ = s;
        return s;
      }
    }
    /**
     * <code>string level = 10;</code>
     */
    public com.google.protobuf.ByteString
        getLevelBytes() {
      java.lang.Object ref = level_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        level_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TAGS_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList tags_;
    /**
     * <code>repeated string tags = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getTagsList() {
      return tags_;
    }
    /**
     * <code>repeated string tags = 4;</code>
     */
    public int getTagsCount() {
      return tags_.size();
    }
    /**
     * <code>repeated string tags = 4;</code>
     */
    public java.lang.String getTags(int index) {
      return tags_.get(index);
    }
    /**
     * <code>repeated string tags = 4;</code>
     */
    public com.google.protobuf.ByteString
        getTagsBytes(int index) {
      return tags_.getByteString(index);
    }

    public static final int DEBUG_FIELD_NUMBER = 22;
    private logan.Logan.Debug debug_;
    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    public boolean hasDebug() {
      return debug_ != null;
    }
    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    public logan.Logan.Debug getDebug() {
      return debug_ == null ? logan.Logan.Debug.getDefaultInstance() : debug_;
    }
    /**
     * <code>.logan.Debug debug = 22;</code>
     */
    public logan.Logan.DebugOrBuilder getDebugOrBuilder() {
      return getDebug();
    }

    public static final int MESSAGE_FIELD_NUMBER = 24;
    private com.google.protobuf.ByteString message_;
    /**
     * <code>bytes message = 24;</code>
     */
    public com.google.protobuf.ByteString getMessage() {
      return message_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (ctx_ != null) {
        output.writeMessage(1, getCtx());
      }
      if (!getTraceIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, traceId_);
      }
      for (int i = 0; i < tags_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, tags_.getRaw(i));
      }
      if (created_ != 0L) {
        output.writeInt64(8, created_);
      }
      if (!getLevelBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, level_);
      }
      if (debug_ != null) {
        output.writeMessage(22, getDebug());
      }
      if (!message_.isEmpty()) {
        output.writeBytes(24, message_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (ctx_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCtx());
      }
      if (!getTraceIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, traceId_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < tags_.size(); i++) {
          dataSize += computeStringSizeNoTag(tags_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getTagsList().size();
      }
      if (created_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(8, created_);
      }
      if (!getLevelBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(10, level_);
      }
      if (debug_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getDebug());
      }
      if (!message_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(24, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof logan.Logan.Log)) {
        return super.equals(obj);
      }
      logan.Logan.Log other = (logan.Logan.Log) obj;

      boolean result = true;
      result = result && (hasCtx() == other.hasCtx());
      if (hasCtx()) {
        result = result && getCtx()
            .equals(other.getCtx());
      }
      result = result && getTraceId()
          .equals(other.getTraceId());
      result = result && (getCreated()
          == other.getCreated());
      result = result && getLevel()
          .equals(other.getLevel());
      result = result && getTagsList()
          .equals(other.getTagsList());
      result = result && (hasDebug() == other.hasDebug());
      if (hasDebug()) {
        result = result && getDebug()
            .equals(other.getDebug());
      }
      result = result && getMessage()
          .equals(other.getMessage());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCtx()) {
        hash = (37 * hash) + CTX_FIELD_NUMBER;
        hash = (53 * hash) + getCtx().hashCode();
      }
      hash = (37 * hash) + TRACE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getTraceId().hashCode();
      hash = (37 * hash) + CREATED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCreated());
      hash = (37 * hash) + LEVEL_FIELD_NUMBER;
      hash = (53 * hash) + getLevel().hashCode();
      if (getTagsCount() > 0) {
        hash = (37 * hash) + TAGS_FIELD_NUMBER;
        hash = (53 * hash) + getTagsList().hashCode();
      }
      if (hasDebug()) {
        hash = (37 * hash) + DEBUG_FIELD_NUMBER;
        hash = (53 * hash) + getDebug().hashCode();
      }
      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static logan.Logan.Log parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Log parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Log parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Log parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Log parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.Log parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.Log parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.Log parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.Log parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static logan.Logan.Log parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.Log parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.Log parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(logan.Logan.Log prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code logan.Log}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:logan.Log)
        logan.Logan.LogOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return logan.Logan.internal_static_logan_Log_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return logan.Logan.internal_static_logan_Log_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                logan.Logan.Log.class, logan.Logan.Log.Builder.class);
      }

      // Construct using logan.Logan.Log.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (ctxBuilder_ == null) {
          ctx_ = null;
        } else {
          ctx_ = null;
          ctxBuilder_ = null;
        }
        traceId_ = "";

        created_ = 0L;

        level_ = "";

        tags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (debugBuilder_ == null) {
          debug_ = null;
        } else {
          debug_ = null;
          debugBuilder_ = null;
        }
        message_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return logan.Logan.internal_static_logan_Log_descriptor;
      }

      public logan.Logan.Log getDefaultInstanceForType() {
        return logan.Logan.Log.getDefaultInstance();
      }

      public logan.Logan.Log build() {
        logan.Logan.Log result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public logan.Logan.Log buildPartial() {
        logan.Logan.Log result = new logan.Logan.Log(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (ctxBuilder_ == null) {
          result.ctx_ = ctx_;
        } else {
          result.ctx_ = ctxBuilder_.build();
        }
        result.traceId_ = traceId_;
        result.created_ = created_;
        result.level_ = level_;
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          tags_ = tags_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.tags_ = tags_;
        if (debugBuilder_ == null) {
          result.debug_ = debug_;
        } else {
          result.debug_ = debugBuilder_.build();
        }
        result.message_ = message_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof logan.Logan.Log) {
          return mergeFrom((logan.Logan.Log)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(logan.Logan.Log other) {
        if (other == logan.Logan.Log.getDefaultInstance()) return this;
        if (other.hasCtx()) {
          mergeCtx(other.getCtx());
        }
        if (!other.getTraceId().isEmpty()) {
          traceId_ = other.traceId_;
          onChanged();
        }
        if (other.getCreated() != 0L) {
          setCreated(other.getCreated());
        }
        if (!other.getLevel().isEmpty()) {
          level_ = other.level_;
          onChanged();
        }
        if (!other.tags_.isEmpty()) {
          if (tags_.isEmpty()) {
            tags_ = other.tags_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureTagsIsMutable();
            tags_.addAll(other.tags_);
          }
          onChanged();
        }
        if (other.hasDebug()) {
          mergeDebug(other.getDebug());
        }
        if (other.getMessage() != com.google.protobuf.ByteString.EMPTY) {
          setMessage(other.getMessage());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        logan.Logan.Log parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (logan.Logan.Log) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private common.Common.Context ctx_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          common.Common.Context, common.Common.Context.Builder, common.Common.ContextOrBuilder> ctxBuilder_;
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public boolean hasCtx() {
        return ctxBuilder_ != null || ctx_ != null;
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public common.Common.Context getCtx() {
        if (ctxBuilder_ == null) {
          return ctx_ == null ? common.Common.Context.getDefaultInstance() : ctx_;
        } else {
          return ctxBuilder_.getMessage();
        }
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public Builder setCtx(common.Common.Context value) {
        if (ctxBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ctx_ = value;
          onChanged();
        } else {
          ctxBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public Builder setCtx(
          common.Common.Context.Builder builderForValue) {
        if (ctxBuilder_ == null) {
          ctx_ = builderForValue.build();
          onChanged();
        } else {
          ctxBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public Builder mergeCtx(common.Common.Context value) {
        if (ctxBuilder_ == null) {
          if (ctx_ != null) {
            ctx_ =
              common.Common.Context.newBuilder(ctx_).mergeFrom(value).buildPartial();
          } else {
            ctx_ = value;
          }
          onChanged();
        } else {
          ctxBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public Builder clearCtx() {
        if (ctxBuilder_ == null) {
          ctx_ = null;
          onChanged();
        } else {
          ctx_ = null;
          ctxBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public common.Common.Context.Builder getCtxBuilder() {
        
        onChanged();
        return getCtxFieldBuilder().getBuilder();
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      public common.Common.ContextOrBuilder getCtxOrBuilder() {
        if (ctxBuilder_ != null) {
          return ctxBuilder_.getMessageOrBuilder();
        } else {
          return ctx_ == null ?
              common.Common.Context.getDefaultInstance() : ctx_;
        }
      }
      /**
       * <code>.common.Context ctx = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          common.Common.Context, common.Common.Context.Builder, common.Common.ContextOrBuilder> 
          getCtxFieldBuilder() {
        if (ctxBuilder_ == null) {
          ctxBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              common.Common.Context, common.Common.Context.Builder, common.Common.ContextOrBuilder>(
                  getCtx(),
                  getParentForChildren(),
                  isClean());
          ctx_ = null;
        }
        return ctxBuilder_;
      }

      private java.lang.Object traceId_ = "";
      /**
       * <code>string trace_id = 2;</code>
       */
      public java.lang.String getTraceId() {
        java.lang.Object ref = traceId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          traceId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string trace_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getTraceIdBytes() {
        java.lang.Object ref = traceId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          traceId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string trace_id = 2;</code>
       */
      public Builder setTraceId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        traceId_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string trace_id = 2;</code>
       */
      public Builder clearTraceId() {
        
        traceId_ = getDefaultInstance().getTraceId();
        onChanged();
        return this;
      }
      /**
       * <code>string trace_id = 2;</code>
       */
      public Builder setTraceIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        traceId_ = value;
        onChanged();
        return this;
      }

      private long created_ ;
      /**
       * <code>int64 created = 8;</code>
       */
      public long getCreated() {
        return created_;
      }
      /**
       * <code>int64 created = 8;</code>
       */
      public Builder setCreated(long value) {
        
        created_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 created = 8;</code>
       */
      public Builder clearCreated() {
        
        created_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object level_ = "";
      /**
       * <code>string level = 10;</code>
       */
      public java.lang.String getLevel() {
        java.lang.Object ref = level_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          level_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string level = 10;</code>
       */
      public com.google.protobuf.ByteString
          getLevelBytes() {
        java.lang.Object ref = level_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          level_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string level = 10;</code>
       */
      public Builder setLevel(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        level_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string level = 10;</code>
       */
      public Builder clearLevel() {
        
        level_ = getDefaultInstance().getLevel();
        onChanged();
        return this;
      }
      /**
       * <code>string level = 10;</code>
       */
      public Builder setLevelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        level_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList tags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureTagsIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          tags_ = new com.google.protobuf.LazyStringArrayList(tags_);
          bitField0_ |= 0x00000010;
         }
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getTagsList() {
        return tags_.getUnmodifiableView();
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public int getTagsCount() {
        return tags_.size();
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public java.lang.String getTags(int index) {
        return tags_.get(index);
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public com.google.protobuf.ByteString
          getTagsBytes(int index) {
        return tags_.getByteString(index);
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public Builder setTags(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureTagsIsMutable();
        tags_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public Builder addTags(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureTagsIsMutable();
        tags_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public Builder addAllTags(
          java.lang.Iterable<java.lang.String> values) {
        ensureTagsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, tags_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public Builder clearTags() {
        tags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string tags = 4;</code>
       */
      public Builder addTagsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureTagsIsMutable();
        tags_.add(value);
        onChanged();
        return this;
      }

      private logan.Logan.Debug debug_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.Debug, logan.Logan.Debug.Builder, logan.Logan.DebugOrBuilder> debugBuilder_;
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public boolean hasDebug() {
        return debugBuilder_ != null || debug_ != null;
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public logan.Logan.Debug getDebug() {
        if (debugBuilder_ == null) {
          return debug_ == null ? logan.Logan.Debug.getDefaultInstance() : debug_;
        } else {
          return debugBuilder_.getMessage();
        }
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public Builder setDebug(logan.Logan.Debug value) {
        if (debugBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          debug_ = value;
          onChanged();
        } else {
          debugBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public Builder setDebug(
          logan.Logan.Debug.Builder builderForValue) {
        if (debugBuilder_ == null) {
          debug_ = builderForValue.build();
          onChanged();
        } else {
          debugBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public Builder mergeDebug(logan.Logan.Debug value) {
        if (debugBuilder_ == null) {
          if (debug_ != null) {
            debug_ =
              logan.Logan.Debug.newBuilder(debug_).mergeFrom(value).buildPartial();
          } else {
            debug_ = value;
          }
          onChanged();
        } else {
          debugBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public Builder clearDebug() {
        if (debugBuilder_ == null) {
          debug_ = null;
          onChanged();
        } else {
          debug_ = null;
          debugBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public logan.Logan.Debug.Builder getDebugBuilder() {
        
        onChanged();
        return getDebugFieldBuilder().getBuilder();
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      public logan.Logan.DebugOrBuilder getDebugOrBuilder() {
        if (debugBuilder_ != null) {
          return debugBuilder_.getMessageOrBuilder();
        } else {
          return debug_ == null ?
              logan.Logan.Debug.getDefaultInstance() : debug_;
        }
      }
      /**
       * <code>.logan.Debug debug = 22;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          logan.Logan.Debug, logan.Logan.Debug.Builder, logan.Logan.DebugOrBuilder> 
          getDebugFieldBuilder() {
        if (debugBuilder_ == null) {
          debugBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              logan.Logan.Debug, logan.Logan.Debug.Builder, logan.Logan.DebugOrBuilder>(
                  getDebug(),
                  getParentForChildren(),
                  isClean());
          debug_ = null;
        }
        return debugBuilder_;
      }

      private com.google.protobuf.ByteString message_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>bytes message = 24;</code>
       */
      public com.google.protobuf.ByteString getMessage() {
        return message_;
      }
      /**
       * <code>bytes message = 24;</code>
       */
      public Builder setMessage(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>bytes message = 24;</code>
       */
      public Builder clearMessage() {
        
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:logan.Log)
    }

    // @@protoc_insertion_point(class_scope:logan.Log)
    private static final logan.Logan.Log DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new logan.Logan.Log();
    }

    public static logan.Logan.Log getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Log>
        PARSER = new com.google.protobuf.AbstractParser<Log>() {
      public Log parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new Log(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Log> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Log> getParserForType() {
      return PARSER;
    }

    public logan.Logan.Log getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MemStatsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:logan.MemStats)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>uint64 alloc = 2;</code>
     */
    long getAlloc();

    /**
     * <pre>
     * TotalAlloc is cumulative bytes allocated for heap objects.
     * TotalAlloc increases as heap objects are allocated, but
     * unlike Alloc and HeapAlloc, it does not decrease when
     * objects are freed.
     * </pre>
     *
     * <code>uint64 total_alloc = 3;</code>
     */
    long getTotalAlloc();

    /**
     * <pre>
     * Sys is the total bytes of memory obtained from the OS.
     * Sys is the sum of the XSys fields below. Sys measures the
     * virtual address space reserved by the Go runtime for the
     * heap, stacks, and other internal data structures. It's
     * likely that not all of the virtual address space is backed
     * by physical memory at any given moment, though in general
     * it all was at some point.
     * </pre>
     *
     * <code>uint64 sys = 4;</code>
     */
    long getSys();

    /**
     * <pre>
     * Lookups is the number of pointer lookups performed by the
     * runtime.
     * This is primarily useful for debugging runtime internals.
     * </pre>
     *
     * <code>uint64 lookups = 5;</code>
     */
    long getLookups();

    /**
     * <pre>
     * Mallocs is the cumulative count of heap objects allocated.
     * The number of live objects is Mallocs - Frees.
     * </pre>
     *
     * <code>uint64 mallocs = 6;</code>
     */
    long getMallocs();

    /**
     * <pre>
     * Frees is the cumulative count of heap objects freed.
     * </pre>
     *
     * <code>uint64 frees = 7;</code>
     */
    long getFrees();

    /**
     * <pre>
     * HeapAlloc is bytes of allocated heap objects.
     * "Allocated" heap objects include all reachable objects, as
     * well as unreachable objects that the garbage collector has
     * not yet freed. Specifically, HeapAlloc increases as heap
     * objects are allocated and decreases as the heap is swept
     * and unreachable objects are freed. Sweeping occurs
     * incrementally between GC cycles, so these two processes
     * occur simultaneously, and as a result HeapAlloc tends to
     * change smoothly (in contrast with the sawtooth that is
     * typical of stop-the-world garbage collectors).
     * </pre>
     *
     * <code>uint64 heap_alloc = 8;</code>
     */
    long getHeapAlloc();

    /**
     * <pre>
     * HeapSys is bytes of heap memory obtained from the OS.
     * HeapSys measures the amount of virtual address space
     * reserved for the heap. This includes virtual address space
     * that has been reserved but not yet used, which consumes no
     * physical memory, but tends to be small, as well as virtual
     * address space for which the physical memory has been
     * returned to the OS after it became unused (see HeapReleased
     * for a measure of the latter).
     * HeapSys estimates the largest size the heap has had.
     * </pre>
     *
     * <code>uint64 heap_sys = 9;</code>
     */
    long getHeapSys();

    /**
     * <pre>
     * HeapIdle is bytes in idle (unused) spans.
     * Idle spans have no objects in them. These spans could be
     * (and may already have been) returned to the OS, or they can
     * be reused for heap allocations, or they can be reused as
     * stack memory.
     * HeapIdle minus HeapReleased estimates the amount of memory
     * that could be returned to the OS, but is being retained by
     * the runtime so it can grow the heap without requesting more
     * memory from the OS. If this difference is significantly
     * larger than the heap size, it indicates there was a recent
     * transient spike in live heap size.
     * </pre>
     *
     * <code>uint64 heap_idle = 10;</code>
     */
    long getHeapIdle();

    /**
     * <pre>
     * HeapInuse is bytes in in-use spans.
     * In-use spans have at least one object in them. These spans
     * can only be used for other objects of roughly the same
     * size.
     * HeapInuse minus HeapAlloc esimates the amount of memory
     * that has been dedicated to particular size classes, but is
     * not currently being used. This is an upper bound on
     * fragmentation, but in general this memory can be reused
     * efficiently.
     * </pre>
     *
     * <code>uint64 heap_inuse = 11;</code>
     */
    long getHeapInuse();

    /**
     * <pre>
     * HeapReleased is bytes of physical memory returned to the OS.
     * This counts heap memory from idle spans that was returned
     * to the OS and has not yet been reacquired for the heap.
     * </pre>
     *
     * <code>uint64 heap_released = 12;</code>
     */
    long getHeapReleased();

    /**
     * <pre>
     * HeapObjects is the number of allocated heap objects.
     * Like HeapAlloc, this increases as objects are allocated and
     * decreases as the heap is swept and unreachable objects are
     * freed.
     * </pre>
     *
     * <code>uint64 heap_objects = 13;</code>
     */
    long getHeapObjects();

    /**
     * <pre>
     * StackInuse is bytes in stack spans.
     * In-use stack spans have at least one stack in them. These
     * spans can only be used for other stacks of the same size.
     * There is no StackIdle because unused stack spans are
     * returned to the heap (and hence counted toward HeapIdle).
     * </pre>
     *
     * <code>uint64 stack_inuse = 14;</code>
     */
    long getStackInuse();

    /**
     * <pre>
     * StackSys is bytes of stack memory obtained from the OS.
     * StackSys is StackInuse, plus any memory obtained directly
     * from the OS for OS thread stacks (which should be minimal).
     * </pre>
     *
     * <code>uint64 stack_sys = 15;</code>
     */
    long getStackSys();

    /**
     * <pre>
     * MSpanInuse is bytes of allocated mspan structures.
     * </pre>
     *
     * <code>uint64 m_span_inuse = 16;</code>
     */
    long getMSpanInuse();

    /**
     * <pre>
     * MSpanSys is bytes of memory obtained from the OS for mspan
     * structures.
     * </pre>
     *
     * <code>uint64 m_span_sys = 17;</code>
     */
    long getMSpanSys();

    /**
     * <pre>
     * MCacheInuse is bytes of allocated mcache structures.
     * </pre>
     *
     * <code>uint64 m_cache_inuse = 18;</code>
     */
    long getMCacheInuse();

    /**
     * <pre>
     * MCacheSys is bytes of memory obtained from the OS for
     * mcache structures.
     * </pre>
     *
     * <code>uint64 m_cache_sys = 19;</code>
     */
    long getMCacheSys();

    /**
     * <pre>
     * BuckHashSys is bytes of memory in profiling bucket hash tables.
     * </pre>
     *
     * <code>uint64 buck_hash_sys = 20;</code>
     */
    long getBuckHashSys();

    /**
     * <pre>
     * GCSys is bytes of memory in garbage collection metadata.
     * </pre>
     *
     * <code>uint64 gc_sys = 21;</code>
     */
    long getGcSys();

    /**
     * <pre>
     * OtherSys is bytes of memory in miscellaneous off-heap
     * runtime allocations.
     * </pre>
     *
     * <code>uint64 other_sys = 22;</code>
     */
    long getOtherSys();

    /**
     * <pre>
     * NextGC is the target heap size of the next GC cycle.
     * The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
     * At the end of each GC cycle, the target for the next cycle
     * is computed based on the amount of reachable data and the
     * value of GOGC.
     * </pre>
     *
     * <code>uint64 next_gc = 23;</code>
     */
    long getNextGc();

    /**
     * <pre>
     * LastGC is the time the last garbage collection finished, as
     * nanoseconds since 1970 (the UNIX epoch).
     * </pre>
     *
     * <code>uint64 last_gc = 24;</code>
     */
    long getLastGc();

    /**
     * <pre>
     * PauseTotalNs is the cumulative nanoseconds in GC
     * stop-the-world pauses since the program started.
     * During a stop-the-world pause, all goroutines are paused
     * and only the garbage collector can run.
     * </pre>
     *
     * <code>uint64 pause_total_ns = 25;</code>
     */
    long getPauseTotalNs();

    /**
     * <pre>
     * NumGC is the number of completed GC cycles.
     * </pre>
     *
     * <code>uint32 num_gc = 26;</code>
     */
    int getNumGc();

    /**
     * <pre>
     * NumForcedGC is the number of GC cycles that were forced by
     * the application calling the GC function.
     * </pre>
     *
     * <code>uint32 num_forced_gc = 27;</code>
     */
    int getNumForcedGc();

    /**
     * <pre>
     * GCCPUFraction is the fraction of this program's available
     * CPU time used by the GC since the program started.
     * GCCPUFraction is expressed as a number between 0 and 1,
     * where 0 means GC has consumed none of this program's CPU. A
     * program's available CPU time is defined as the integral of
     * GOMAXPROCS since the program started. That is, if
     * GOMAXPROCS is 2 and a program has been running for 10
     * seconds, its "available CPU" is 20 seconds. GCCPUFraction
     * does not include CPU time used for write barrier activity.
     * This is the same as the fraction of CPU reported by
     * GODEBUG=gctrace=1.
     * </pre>
     *
     * <code>double gc_cpu_fraction = 28;</code>
     */
    double getGcCpuFraction();
  }
  /**
   * Protobuf type {@code logan.MemStats}
   */
  public  static final class MemStats extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:logan.MemStats)
      MemStatsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MemStats.newBuilder() to construct.
    private MemStats(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MemStats() {
      alloc_ = 0L;
      totalAlloc_ = 0L;
      sys_ = 0L;
      lookups_ = 0L;
      mallocs_ = 0L;
      frees_ = 0L;
      heapAlloc_ = 0L;
      heapSys_ = 0L;
      heapIdle_ = 0L;
      heapInuse_ = 0L;
      heapReleased_ = 0L;
      heapObjects_ = 0L;
      stackInuse_ = 0L;
      stackSys_ = 0L;
      mSpanInuse_ = 0L;
      mSpanSys_ = 0L;
      mCacheInuse_ = 0L;
      mCacheSys_ = 0L;
      buckHashSys_ = 0L;
      gcSys_ = 0L;
      otherSys_ = 0L;
      nextGc_ = 0L;
      lastGc_ = 0L;
      pauseTotalNs_ = 0L;
      numGc_ = 0;
      numForcedGc_ = 0;
      gcCpuFraction_ = 0D;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private MemStats(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 16: {

              alloc_ = input.readUInt64();
              break;
            }
            case 24: {

              totalAlloc_ = input.readUInt64();
              break;
            }
            case 32: {

              sys_ = input.readUInt64();
              break;
            }
            case 40: {

              lookups_ = input.readUInt64();
              break;
            }
            case 48: {

              mallocs_ = input.readUInt64();
              break;
            }
            case 56: {

              frees_ = input.readUInt64();
              break;
            }
            case 64: {

              heapAlloc_ = input.readUInt64();
              break;
            }
            case 72: {

              heapSys_ = input.readUInt64();
              break;
            }
            case 80: {

              heapIdle_ = input.readUInt64();
              break;
            }
            case 88: {

              heapInuse_ = input.readUInt64();
              break;
            }
            case 96: {

              heapReleased_ = input.readUInt64();
              break;
            }
            case 104: {

              heapObjects_ = input.readUInt64();
              break;
            }
            case 112: {

              stackInuse_ = input.readUInt64();
              break;
            }
            case 120: {

              stackSys_ = input.readUInt64();
              break;
            }
            case 128: {

              mSpanInuse_ = input.readUInt64();
              break;
            }
            case 136: {

              mSpanSys_ = input.readUInt64();
              break;
            }
            case 144: {

              mCacheInuse_ = input.readUInt64();
              break;
            }
            case 152: {

              mCacheSys_ = input.readUInt64();
              break;
            }
            case 160: {

              buckHashSys_ = input.readUInt64();
              break;
            }
            case 168: {

              gcSys_ = input.readUInt64();
              break;
            }
            case 176: {

              otherSys_ = input.readUInt64();
              break;
            }
            case 184: {

              nextGc_ = input.readUInt64();
              break;
            }
            case 192: {

              lastGc_ = input.readUInt64();
              break;
            }
            case 200: {

              pauseTotalNs_ = input.readUInt64();
              break;
            }
            case 208: {

              numGc_ = input.readUInt32();
              break;
            }
            case 216: {

              numForcedGc_ = input.readUInt32();
              break;
            }
            case 225: {

              gcCpuFraction_ = input.readDouble();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return logan.Logan.internal_static_logan_MemStats_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return logan.Logan.internal_static_logan_MemStats_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              logan.Logan.MemStats.class, logan.Logan.MemStats.Builder.class);
    }

    public static final int ALLOC_FIELD_NUMBER = 2;
    private long alloc_;
    /**
     * <code>uint64 alloc = 2;</code>
     */
    public long getAlloc() {
      return alloc_;
    }

    public static final int TOTAL_ALLOC_FIELD_NUMBER = 3;
    private long totalAlloc_;
    /**
     * <pre>
     * TotalAlloc is cumulative bytes allocated for heap objects.
     * TotalAlloc increases as heap objects are allocated, but
     * unlike Alloc and HeapAlloc, it does not decrease when
     * objects are freed.
     * </pre>
     *
     * <code>uint64 total_alloc = 3;</code>
     */
    public long getTotalAlloc() {
      return totalAlloc_;
    }

    public static final int SYS_FIELD_NUMBER = 4;
    private long sys_;
    /**
     * <pre>
     * Sys is the total bytes of memory obtained from the OS.
     * Sys is the sum of the XSys fields below. Sys measures the
     * virtual address space reserved by the Go runtime for the
     * heap, stacks, and other internal data structures. It's
     * likely that not all of the virtual address space is backed
     * by physical memory at any given moment, though in general
     * it all was at some point.
     * </pre>
     *
     * <code>uint64 sys = 4;</code>
     */
    public long getSys() {
      return sys_;
    }

    public static final int LOOKUPS_FIELD_NUMBER = 5;
    private long lookups_;
    /**
     * <pre>
     * Lookups is the number of pointer lookups performed by the
     * runtime.
     * This is primarily useful for debugging runtime internals.
     * </pre>
     *
     * <code>uint64 lookups = 5;</code>
     */
    public long getLookups() {
      return lookups_;
    }

    public static final int MALLOCS_FIELD_NUMBER = 6;
    private long mallocs_;
    /**
     * <pre>
     * Mallocs is the cumulative count of heap objects allocated.
     * The number of live objects is Mallocs - Frees.
     * </pre>
     *
     * <code>uint64 mallocs = 6;</code>
     */
    public long getMallocs() {
      return mallocs_;
    }

    public static final int FREES_FIELD_NUMBER = 7;
    private long frees_;
    /**
     * <pre>
     * Frees is the cumulative count of heap objects freed.
     * </pre>
     *
     * <code>uint64 frees = 7;</code>
     */
    public long getFrees() {
      return frees_;
    }

    public static final int HEAP_ALLOC_FIELD_NUMBER = 8;
    private long heapAlloc_;
    /**
     * <pre>
     * HeapAlloc is bytes of allocated heap objects.
     * "Allocated" heap objects include all reachable objects, as
     * well as unreachable objects that the garbage collector has
     * not yet freed. Specifically, HeapAlloc increases as heap
     * objects are allocated and decreases as the heap is swept
     * and unreachable objects are freed. Sweeping occurs
     * incrementally between GC cycles, so these two processes
     * occur simultaneously, and as a result HeapAlloc tends to
     * change smoothly (in contrast with the sawtooth that is
     * typical of stop-the-world garbage collectors).
     * </pre>
     *
     * <code>uint64 heap_alloc = 8;</code>
     */
    public long getHeapAlloc() {
      return heapAlloc_;
    }

    public static final int HEAP_SYS_FIELD_NUMBER = 9;
    private long heapSys_;
    /**
     * <pre>
     * HeapSys is bytes of heap memory obtained from the OS.
     * HeapSys measures the amount of virtual address space
     * reserved for the heap. This includes virtual address space
     * that has been reserved but not yet used, which consumes no
     * physical memory, but tends to be small, as well as virtual
     * address space for which the physical memory has been
     * returned to the OS after it became unused (see HeapReleased
     * for a measure of the latter).
     * HeapSys estimates the largest size the heap has had.
     * </pre>
     *
     * <code>uint64 heap_sys = 9;</code>
     */
    public long getHeapSys() {
      return heapSys_;
    }

    public static final int HEAP_IDLE_FIELD_NUMBER = 10;
    private long heapIdle_;
    /**
     * <pre>
     * HeapIdle is bytes in idle (unused) spans.
     * Idle spans have no objects in them. These spans could be
     * (and may already have been) returned to the OS, or they can
     * be reused for heap allocations, or they can be reused as
     * stack memory.
     * HeapIdle minus HeapReleased estimates the amount of memory
     * that could be returned to the OS, but is being retained by
     * the runtime so it can grow the heap without requesting more
     * memory from the OS. If this difference is significantly
     * larger than the heap size, it indicates there was a recent
     * transient spike in live heap size.
     * </pre>
     *
     * <code>uint64 heap_idle = 10;</code>
     */
    public long getHeapIdle() {
      return heapIdle_;
    }

    public static final int HEAP_INUSE_FIELD_NUMBER = 11;
    private long heapInuse_;
    /**
     * <pre>
     * HeapInuse is bytes in in-use spans.
     * In-use spans have at least one object in them. These spans
     * can only be used for other objects of roughly the same
     * size.
     * HeapInuse minus HeapAlloc esimates the amount of memory
     * that has been dedicated to particular size classes, but is
     * not currently being used. This is an upper bound on
     * fragmentation, but in general this memory can be reused
     * efficiently.
     * </pre>
     *
     * <code>uint64 heap_inuse = 11;</code>
     */
    public long getHeapInuse() {
      return heapInuse_;
    }

    public static final int HEAP_RELEASED_FIELD_NUMBER = 12;
    private long heapReleased_;
    /**
     * <pre>
     * HeapReleased is bytes of physical memory returned to the OS.
     * This counts heap memory from idle spans that was returned
     * to the OS and has not yet been reacquired for the heap.
     * </pre>
     *
     * <code>uint64 heap_released = 12;</code>
     */
    public long getHeapReleased() {
      return heapReleased_;
    }

    public static final int HEAP_OBJECTS_FIELD_NUMBER = 13;
    private long heapObjects_;
    /**
     * <pre>
     * HeapObjects is the number of allocated heap objects.
     * Like HeapAlloc, this increases as objects are allocated and
     * decreases as the heap is swept and unreachable objects are
     * freed.
     * </pre>
     *
     * <code>uint64 heap_objects = 13;</code>
     */
    public long getHeapObjects() {
      return heapObjects_;
    }

    public static final int STACK_INUSE_FIELD_NUMBER = 14;
    private long stackInuse_;
    /**
     * <pre>
     * StackInuse is bytes in stack spans.
     * In-use stack spans have at least one stack in them. These
     * spans can only be used for other stacks of the same size.
     * There is no StackIdle because unused stack spans are
     * returned to the heap (and hence counted toward HeapIdle).
     * </pre>
     *
     * <code>uint64 stack_inuse = 14;</code>
     */
    public long getStackInuse() {
      return stackInuse_;
    }

    public static final int STACK_SYS_FIELD_NUMBER = 15;
    private long stackSys_;
    /**
     * <pre>
     * StackSys is bytes of stack memory obtained from the OS.
     * StackSys is StackInuse, plus any memory obtained directly
     * from the OS for OS thread stacks (which should be minimal).
     * </pre>
     *
     * <code>uint64 stack_sys = 15;</code>
     */
    public long getStackSys() {
      return stackSys_;
    }

    public static final int M_SPAN_INUSE_FIELD_NUMBER = 16;
    private long mSpanInuse_;
    /**
     * <pre>
     * MSpanInuse is bytes of allocated mspan structures.
     * </pre>
     *
     * <code>uint64 m_span_inuse = 16;</code>
     */
    public long getMSpanInuse() {
      return mSpanInuse_;
    }

    public static final int M_SPAN_SYS_FIELD_NUMBER = 17;
    private long mSpanSys_;
    /**
     * <pre>
     * MSpanSys is bytes of memory obtained from the OS for mspan
     * structures.
     * </pre>
     *
     * <code>uint64 m_span_sys = 17;</code>
     */
    public long getMSpanSys() {
      return mSpanSys_;
    }

    public static final int M_CACHE_INUSE_FIELD_NUMBER = 18;
    private long mCacheInuse_;
    /**
     * <pre>
     * MCacheInuse is bytes of allocated mcache structures.
     * </pre>
     *
     * <code>uint64 m_cache_inuse = 18;</code>
     */
    public long getMCacheInuse() {
      return mCacheInuse_;
    }

    public static final int M_CACHE_SYS_FIELD_NUMBER = 19;
    private long mCacheSys_;
    /**
     * <pre>
     * MCacheSys is bytes of memory obtained from the OS for
     * mcache structures.
     * </pre>
     *
     * <code>uint64 m_cache_sys = 19;</code>
     */
    public long getMCacheSys() {
      return mCacheSys_;
    }

    public static final int BUCK_HASH_SYS_FIELD_NUMBER = 20;
    private long buckHashSys_;
    /**
     * <pre>
     * BuckHashSys is bytes of memory in profiling bucket hash tables.
     * </pre>
     *
     * <code>uint64 buck_hash_sys = 20;</code>
     */
    public long getBuckHashSys() {
      return buckHashSys_;
    }

    public static final int GC_SYS_FIELD_NUMBER = 21;
    private long gcSys_;
    /**
     * <pre>
     * GCSys is bytes of memory in garbage collection metadata.
     * </pre>
     *
     * <code>uint64 gc_sys = 21;</code>
     */
    public long getGcSys() {
      return gcSys_;
    }

    public static final int OTHER_SYS_FIELD_NUMBER = 22;
    private long otherSys_;
    /**
     * <pre>
     * OtherSys is bytes of memory in miscellaneous off-heap
     * runtime allocations.
     * </pre>
     *
     * <code>uint64 other_sys = 22;</code>
     */
    public long getOtherSys() {
      return otherSys_;
    }

    public static final int NEXT_GC_FIELD_NUMBER = 23;
    private long nextGc_;
    /**
     * <pre>
     * NextGC is the target heap size of the next GC cycle.
     * The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
     * At the end of each GC cycle, the target for the next cycle
     * is computed based on the amount of reachable data and the
     * value of GOGC.
     * </pre>
     *
     * <code>uint64 next_gc = 23;</code>
     */
    public long getNextGc() {
      return nextGc_;
    }

    public static final int LAST_GC_FIELD_NUMBER = 24;
    private long lastGc_;
    /**
     * <pre>
     * LastGC is the time the last garbage collection finished, as
     * nanoseconds since 1970 (the UNIX epoch).
     * </pre>
     *
     * <code>uint64 last_gc = 24;</code>
     */
    public long getLastGc() {
      return lastGc_;
    }

    public static final int PAUSE_TOTAL_NS_FIELD_NUMBER = 25;
    private long pauseTotalNs_;
    /**
     * <pre>
     * PauseTotalNs is the cumulative nanoseconds in GC
     * stop-the-world pauses since the program started.
     * During a stop-the-world pause, all goroutines are paused
     * and only the garbage collector can run.
     * </pre>
     *
     * <code>uint64 pause_total_ns = 25;</code>
     */
    public long getPauseTotalNs() {
      return pauseTotalNs_;
    }

    public static final int NUM_GC_FIELD_NUMBER = 26;
    private int numGc_;
    /**
     * <pre>
     * NumGC is the number of completed GC cycles.
     * </pre>
     *
     * <code>uint32 num_gc = 26;</code>
     */
    public int getNumGc() {
      return numGc_;
    }

    public static final int NUM_FORCED_GC_FIELD_NUMBER = 27;
    private int numForcedGc_;
    /**
     * <pre>
     * NumForcedGC is the number of GC cycles that were forced by
     * the application calling the GC function.
     * </pre>
     *
     * <code>uint32 num_forced_gc = 27;</code>
     */
    public int getNumForcedGc() {
      return numForcedGc_;
    }

    public static final int GC_CPU_FRACTION_FIELD_NUMBER = 28;
    private double gcCpuFraction_;
    /**
     * <pre>
     * GCCPUFraction is the fraction of this program's available
     * CPU time used by the GC since the program started.
     * GCCPUFraction is expressed as a number between 0 and 1,
     * where 0 means GC has consumed none of this program's CPU. A
     * program's available CPU time is defined as the integral of
     * GOMAXPROCS since the program started. That is, if
     * GOMAXPROCS is 2 and a program has been running for 10
     * seconds, its "available CPU" is 20 seconds. GCCPUFraction
     * does not include CPU time used for write barrier activity.
     * This is the same as the fraction of CPU reported by
     * GODEBUG=gctrace=1.
     * </pre>
     *
     * <code>double gc_cpu_fraction = 28;</code>
     */
    public double getGcCpuFraction() {
      return gcCpuFraction_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (alloc_ != 0L) {
        output.writeUInt64(2, alloc_);
      }
      if (totalAlloc_ != 0L) {
        output.writeUInt64(3, totalAlloc_);
      }
      if (sys_ != 0L) {
        output.writeUInt64(4, sys_);
      }
      if (lookups_ != 0L) {
        output.writeUInt64(5, lookups_);
      }
      if (mallocs_ != 0L) {
        output.writeUInt64(6, mallocs_);
      }
      if (frees_ != 0L) {
        output.writeUInt64(7, frees_);
      }
      if (heapAlloc_ != 0L) {
        output.writeUInt64(8, heapAlloc_);
      }
      if (heapSys_ != 0L) {
        output.writeUInt64(9, heapSys_);
      }
      if (heapIdle_ != 0L) {
        output.writeUInt64(10, heapIdle_);
      }
      if (heapInuse_ != 0L) {
        output.writeUInt64(11, heapInuse_);
      }
      if (heapReleased_ != 0L) {
        output.writeUInt64(12, heapReleased_);
      }
      if (heapObjects_ != 0L) {
        output.writeUInt64(13, heapObjects_);
      }
      if (stackInuse_ != 0L) {
        output.writeUInt64(14, stackInuse_);
      }
      if (stackSys_ != 0L) {
        output.writeUInt64(15, stackSys_);
      }
      if (mSpanInuse_ != 0L) {
        output.writeUInt64(16, mSpanInuse_);
      }
      if (mSpanSys_ != 0L) {
        output.writeUInt64(17, mSpanSys_);
      }
      if (mCacheInuse_ != 0L) {
        output.writeUInt64(18, mCacheInuse_);
      }
      if (mCacheSys_ != 0L) {
        output.writeUInt64(19, mCacheSys_);
      }
      if (buckHashSys_ != 0L) {
        output.writeUInt64(20, buckHashSys_);
      }
      if (gcSys_ != 0L) {
        output.writeUInt64(21, gcSys_);
      }
      if (otherSys_ != 0L) {
        output.writeUInt64(22, otherSys_);
      }
      if (nextGc_ != 0L) {
        output.writeUInt64(23, nextGc_);
      }
      if (lastGc_ != 0L) {
        output.writeUInt64(24, lastGc_);
      }
      if (pauseTotalNs_ != 0L) {
        output.writeUInt64(25, pauseTotalNs_);
      }
      if (numGc_ != 0) {
        output.writeUInt32(26, numGc_);
      }
      if (numForcedGc_ != 0) {
        output.writeUInt32(27, numForcedGc_);
      }
      if (gcCpuFraction_ != 0D) {
        output.writeDouble(28, gcCpuFraction_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (alloc_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, alloc_);
      }
      if (totalAlloc_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, totalAlloc_);
      }
      if (sys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, sys_);
      }
      if (lookups_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, lookups_);
      }
      if (mallocs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(6, mallocs_);
      }
      if (frees_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, frees_);
      }
      if (heapAlloc_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(8, heapAlloc_);
      }
      if (heapSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(9, heapSys_);
      }
      if (heapIdle_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(10, heapIdle_);
      }
      if (heapInuse_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(11, heapInuse_);
      }
      if (heapReleased_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(12, heapReleased_);
      }
      if (heapObjects_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(13, heapObjects_);
      }
      if (stackInuse_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(14, stackInuse_);
      }
      if (stackSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(15, stackSys_);
      }
      if (mSpanInuse_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(16, mSpanInuse_);
      }
      if (mSpanSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(17, mSpanSys_);
      }
      if (mCacheInuse_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(18, mCacheInuse_);
      }
      if (mCacheSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(19, mCacheSys_);
      }
      if (buckHashSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(20, buckHashSys_);
      }
      if (gcSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(21, gcSys_);
      }
      if (otherSys_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(22, otherSys_);
      }
      if (nextGc_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(23, nextGc_);
      }
      if (lastGc_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(24, lastGc_);
      }
      if (pauseTotalNs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(25, pauseTotalNs_);
      }
      if (numGc_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(26, numGc_);
      }
      if (numForcedGc_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(27, numForcedGc_);
      }
      if (gcCpuFraction_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(28, gcCpuFraction_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof logan.Logan.MemStats)) {
        return super.equals(obj);
      }
      logan.Logan.MemStats other = (logan.Logan.MemStats) obj;

      boolean result = true;
      result = result && (getAlloc()
          == other.getAlloc());
      result = result && (getTotalAlloc()
          == other.getTotalAlloc());
      result = result && (getSys()
          == other.getSys());
      result = result && (getLookups()
          == other.getLookups());
      result = result && (getMallocs()
          == other.getMallocs());
      result = result && (getFrees()
          == other.getFrees());
      result = result && (getHeapAlloc()
          == other.getHeapAlloc());
      result = result && (getHeapSys()
          == other.getHeapSys());
      result = result && (getHeapIdle()
          == other.getHeapIdle());
      result = result && (getHeapInuse()
          == other.getHeapInuse());
      result = result && (getHeapReleased()
          == other.getHeapReleased());
      result = result && (getHeapObjects()
          == other.getHeapObjects());
      result = result && (getStackInuse()
          == other.getStackInuse());
      result = result && (getStackSys()
          == other.getStackSys());
      result = result && (getMSpanInuse()
          == other.getMSpanInuse());
      result = result && (getMSpanSys()
          == other.getMSpanSys());
      result = result && (getMCacheInuse()
          == other.getMCacheInuse());
      result = result && (getMCacheSys()
          == other.getMCacheSys());
      result = result && (getBuckHashSys()
          == other.getBuckHashSys());
      result = result && (getGcSys()
          == other.getGcSys());
      result = result && (getOtherSys()
          == other.getOtherSys());
      result = result && (getNextGc()
          == other.getNextGc());
      result = result && (getLastGc()
          == other.getLastGc());
      result = result && (getPauseTotalNs()
          == other.getPauseTotalNs());
      result = result && (getNumGc()
          == other.getNumGc());
      result = result && (getNumForcedGc()
          == other.getNumForcedGc());
      result = result && (
          java.lang.Double.doubleToLongBits(getGcCpuFraction())
          == java.lang.Double.doubleToLongBits(
              other.getGcCpuFraction()));
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + ALLOC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAlloc());
      hash = (37 * hash) + TOTAL_ALLOC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getTotalAlloc());
      hash = (37 * hash) + SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSys());
      hash = (37 * hash) + LOOKUPS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLookups());
      hash = (37 * hash) + MALLOCS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMallocs());
      hash = (37 * hash) + FREES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFrees());
      hash = (37 * hash) + HEAP_ALLOC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapAlloc());
      hash = (37 * hash) + HEAP_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapSys());
      hash = (37 * hash) + HEAP_IDLE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapIdle());
      hash = (37 * hash) + HEAP_INUSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapInuse());
      hash = (37 * hash) + HEAP_RELEASED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapReleased());
      hash = (37 * hash) + HEAP_OBJECTS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeapObjects());
      hash = (37 * hash) + STACK_INUSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getStackInuse());
      hash = (37 * hash) + STACK_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getStackSys());
      hash = (37 * hash) + M_SPAN_INUSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMSpanInuse());
      hash = (37 * hash) + M_SPAN_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMSpanSys());
      hash = (37 * hash) + M_CACHE_INUSE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMCacheInuse());
      hash = (37 * hash) + M_CACHE_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMCacheSys());
      hash = (37 * hash) + BUCK_HASH_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getBuckHashSys());
      hash = (37 * hash) + GC_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getGcSys());
      hash = (37 * hash) + OTHER_SYS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getOtherSys());
      hash = (37 * hash) + NEXT_GC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getNextGc());
      hash = (37 * hash) + LAST_GC_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLastGc());
      hash = (37 * hash) + PAUSE_TOTAL_NS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPauseTotalNs());
      hash = (37 * hash) + NUM_GC_FIELD_NUMBER;
      hash = (53 * hash) + getNumGc();
      hash = (37 * hash) + NUM_FORCED_GC_FIELD_NUMBER;
      hash = (53 * hash) + getNumForcedGc();
      hash = (37 * hash) + GC_CPU_FRACTION_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getGcCpuFraction()));
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static logan.Logan.MemStats parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.MemStats parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.MemStats parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.MemStats parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.MemStats parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static logan.Logan.MemStats parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static logan.Logan.MemStats parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.MemStats parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.MemStats parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static logan.Logan.MemStats parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static logan.Logan.MemStats parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static logan.Logan.MemStats parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(logan.Logan.MemStats prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code logan.MemStats}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:logan.MemStats)
        logan.Logan.MemStatsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return logan.Logan.internal_static_logan_MemStats_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return logan.Logan.internal_static_logan_MemStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                logan.Logan.MemStats.class, logan.Logan.MemStats.Builder.class);
      }

      // Construct using logan.Logan.MemStats.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        alloc_ = 0L;

        totalAlloc_ = 0L;

        sys_ = 0L;

        lookups_ = 0L;

        mallocs_ = 0L;

        frees_ = 0L;

        heapAlloc_ = 0L;

        heapSys_ = 0L;

        heapIdle_ = 0L;

        heapInuse_ = 0L;

        heapReleased_ = 0L;

        heapObjects_ = 0L;

        stackInuse_ = 0L;

        stackSys_ = 0L;

        mSpanInuse_ = 0L;

        mSpanSys_ = 0L;

        mCacheInuse_ = 0L;

        mCacheSys_ = 0L;

        buckHashSys_ = 0L;

        gcSys_ = 0L;

        otherSys_ = 0L;

        nextGc_ = 0L;

        lastGc_ = 0L;

        pauseTotalNs_ = 0L;

        numGc_ = 0;

        numForcedGc_ = 0;

        gcCpuFraction_ = 0D;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return logan.Logan.internal_static_logan_MemStats_descriptor;
      }

      public logan.Logan.MemStats getDefaultInstanceForType() {
        return logan.Logan.MemStats.getDefaultInstance();
      }

      public logan.Logan.MemStats build() {
        logan.Logan.MemStats result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public logan.Logan.MemStats buildPartial() {
        logan.Logan.MemStats result = new logan.Logan.MemStats(this);
        result.alloc_ = alloc_;
        result.totalAlloc_ = totalAlloc_;
        result.sys_ = sys_;
        result.lookups_ = lookups_;
        result.mallocs_ = mallocs_;
        result.frees_ = frees_;
        result.heapAlloc_ = heapAlloc_;
        result.heapSys_ = heapSys_;
        result.heapIdle_ = heapIdle_;
        result.heapInuse_ = heapInuse_;
        result.heapReleased_ = heapReleased_;
        result.heapObjects_ = heapObjects_;
        result.stackInuse_ = stackInuse_;
        result.stackSys_ = stackSys_;
        result.mSpanInuse_ = mSpanInuse_;
        result.mSpanSys_ = mSpanSys_;
        result.mCacheInuse_ = mCacheInuse_;
        result.mCacheSys_ = mCacheSys_;
        result.buckHashSys_ = buckHashSys_;
        result.gcSys_ = gcSys_;
        result.otherSys_ = otherSys_;
        result.nextGc_ = nextGc_;
        result.lastGc_ = lastGc_;
        result.pauseTotalNs_ = pauseTotalNs_;
        result.numGc_ = numGc_;
        result.numForcedGc_ = numForcedGc_;
        result.gcCpuFraction_ = gcCpuFraction_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof logan.Logan.MemStats) {
          return mergeFrom((logan.Logan.MemStats)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(logan.Logan.MemStats other) {
        if (other == logan.Logan.MemStats.getDefaultInstance()) return this;
        if (other.getAlloc() != 0L) {
          setAlloc(other.getAlloc());
        }
        if (other.getTotalAlloc() != 0L) {
          setTotalAlloc(other.getTotalAlloc());
        }
        if (other.getSys() != 0L) {
          setSys(other.getSys());
        }
        if (other.getLookups() != 0L) {
          setLookups(other.getLookups());
        }
        if (other.getMallocs() != 0L) {
          setMallocs(other.getMallocs());
        }
        if (other.getFrees() != 0L) {
          setFrees(other.getFrees());
        }
        if (other.getHeapAlloc() != 0L) {
          setHeapAlloc(other.getHeapAlloc());
        }
        if (other.getHeapSys() != 0L) {
          setHeapSys(other.getHeapSys());
        }
        if (other.getHeapIdle() != 0L) {
          setHeapIdle(other.getHeapIdle());
        }
        if (other.getHeapInuse() != 0L) {
          setHeapInuse(other.getHeapInuse());
        }
        if (other.getHeapReleased() != 0L) {
          setHeapReleased(other.getHeapReleased());
        }
        if (other.getHeapObjects() != 0L) {
          setHeapObjects(other.getHeapObjects());
        }
        if (other.getStackInuse() != 0L) {
          setStackInuse(other.getStackInuse());
        }
        if (other.getStackSys() != 0L) {
          setStackSys(other.getStackSys());
        }
        if (other.getMSpanInuse() != 0L) {
          setMSpanInuse(other.getMSpanInuse());
        }
        if (other.getMSpanSys() != 0L) {
          setMSpanSys(other.getMSpanSys());
        }
        if (other.getMCacheInuse() != 0L) {
          setMCacheInuse(other.getMCacheInuse());
        }
        if (other.getMCacheSys() != 0L) {
          setMCacheSys(other.getMCacheSys());
        }
        if (other.getBuckHashSys() != 0L) {
          setBuckHashSys(other.getBuckHashSys());
        }
        if (other.getGcSys() != 0L) {
          setGcSys(other.getGcSys());
        }
        if (other.getOtherSys() != 0L) {
          setOtherSys(other.getOtherSys());
        }
        if (other.getNextGc() != 0L) {
          setNextGc(other.getNextGc());
        }
        if (other.getLastGc() != 0L) {
          setLastGc(other.getLastGc());
        }
        if (other.getPauseTotalNs() != 0L) {
          setPauseTotalNs(other.getPauseTotalNs());
        }
        if (other.getNumGc() != 0) {
          setNumGc(other.getNumGc());
        }
        if (other.getNumForcedGc() != 0) {
          setNumForcedGc(other.getNumForcedGc());
        }
        if (other.getGcCpuFraction() != 0D) {
          setGcCpuFraction(other.getGcCpuFraction());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        logan.Logan.MemStats parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (logan.Logan.MemStats) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long alloc_ ;
      /**
       * <code>uint64 alloc = 2;</code>
       */
      public long getAlloc() {
        return alloc_;
      }
      /**
       * <code>uint64 alloc = 2;</code>
       */
      public Builder setAlloc(long value) {
        
        alloc_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>uint64 alloc = 2;</code>
       */
      public Builder clearAlloc() {
        
        alloc_ = 0L;
        onChanged();
        return this;
      }

      private long totalAlloc_ ;
      /**
       * <pre>
       * TotalAlloc is cumulative bytes allocated for heap objects.
       * TotalAlloc increases as heap objects are allocated, but
       * unlike Alloc and HeapAlloc, it does not decrease when
       * objects are freed.
       * </pre>
       *
       * <code>uint64 total_alloc = 3;</code>
       */
      public long getTotalAlloc() {
        return totalAlloc_;
      }
      /**
       * <pre>
       * TotalAlloc is cumulative bytes allocated for heap objects.
       * TotalAlloc increases as heap objects are allocated, but
       * unlike Alloc and HeapAlloc, it does not decrease when
       * objects are freed.
       * </pre>
       *
       * <code>uint64 total_alloc = 3;</code>
       */
      public Builder setTotalAlloc(long value) {
        
        totalAlloc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * TotalAlloc is cumulative bytes allocated for heap objects.
       * TotalAlloc increases as heap objects are allocated, but
       * unlike Alloc and HeapAlloc, it does not decrease when
       * objects are freed.
       * </pre>
       *
       * <code>uint64 total_alloc = 3;</code>
       */
      public Builder clearTotalAlloc() {
        
        totalAlloc_ = 0L;
        onChanged();
        return this;
      }

      private long sys_ ;
      /**
       * <pre>
       * Sys is the total bytes of memory obtained from the OS.
       * Sys is the sum of the XSys fields below. Sys measures the
       * virtual address space reserved by the Go runtime for the
       * heap, stacks, and other internal data structures. It's
       * likely that not all of the virtual address space is backed
       * by physical memory at any given moment, though in general
       * it all was at some point.
       * </pre>
       *
       * <code>uint64 sys = 4;</code>
       */
      public long getSys() {
        return sys_;
      }
      /**
       * <pre>
       * Sys is the total bytes of memory obtained from the OS.
       * Sys is the sum of the XSys fields below. Sys measures the
       * virtual address space reserved by the Go runtime for the
       * heap, stacks, and other internal data structures. It's
       * likely that not all of the virtual address space is backed
       * by physical memory at any given moment, though in general
       * it all was at some point.
       * </pre>
       *
       * <code>uint64 sys = 4;</code>
       */
      public Builder setSys(long value) {
        
        sys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Sys is the total bytes of memory obtained from the OS.
       * Sys is the sum of the XSys fields below. Sys measures the
       * virtual address space reserved by the Go runtime for the
       * heap, stacks, and other internal data structures. It's
       * likely that not all of the virtual address space is backed
       * by physical memory at any given moment, though in general
       * it all was at some point.
       * </pre>
       *
       * <code>uint64 sys = 4;</code>
       */
      public Builder clearSys() {
        
        sys_ = 0L;
        onChanged();
        return this;
      }

      private long lookups_ ;
      /**
       * <pre>
       * Lookups is the number of pointer lookups performed by the
       * runtime.
       * This is primarily useful for debugging runtime internals.
       * </pre>
       *
       * <code>uint64 lookups = 5;</code>
       */
      public long getLookups() {
        return lookups_;
      }
      /**
       * <pre>
       * Lookups is the number of pointer lookups performed by the
       * runtime.
       * This is primarily useful for debugging runtime internals.
       * </pre>
       *
       * <code>uint64 lookups = 5;</code>
       */
      public Builder setLookups(long value) {
        
        lookups_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Lookups is the number of pointer lookups performed by the
       * runtime.
       * This is primarily useful for debugging runtime internals.
       * </pre>
       *
       * <code>uint64 lookups = 5;</code>
       */
      public Builder clearLookups() {
        
        lookups_ = 0L;
        onChanged();
        return this;
      }

      private long mallocs_ ;
      /**
       * <pre>
       * Mallocs is the cumulative count of heap objects allocated.
       * The number of live objects is Mallocs - Frees.
       * </pre>
       *
       * <code>uint64 mallocs = 6;</code>
       */
      public long getMallocs() {
        return mallocs_;
      }
      /**
       * <pre>
       * Mallocs is the cumulative count of heap objects allocated.
       * The number of live objects is Mallocs - Frees.
       * </pre>
       *
       * <code>uint64 mallocs = 6;</code>
       */
      public Builder setMallocs(long value) {
        
        mallocs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Mallocs is the cumulative count of heap objects allocated.
       * The number of live objects is Mallocs - Frees.
       * </pre>
       *
       * <code>uint64 mallocs = 6;</code>
       */
      public Builder clearMallocs() {
        
        mallocs_ = 0L;
        onChanged();
        return this;
      }

      private long frees_ ;
      /**
       * <pre>
       * Frees is the cumulative count of heap objects freed.
       * </pre>
       *
       * <code>uint64 frees = 7;</code>
       */
      public long getFrees() {
        return frees_;
      }
      /**
       * <pre>
       * Frees is the cumulative count of heap objects freed.
       * </pre>
       *
       * <code>uint64 frees = 7;</code>
       */
      public Builder setFrees(long value) {
        
        frees_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Frees is the cumulative count of heap objects freed.
       * </pre>
       *
       * <code>uint64 frees = 7;</code>
       */
      public Builder clearFrees() {
        
        frees_ = 0L;
        onChanged();
        return this;
      }

      private long heapAlloc_ ;
      /**
       * <pre>
       * HeapAlloc is bytes of allocated heap objects.
       * "Allocated" heap objects include all reachable objects, as
       * well as unreachable objects that the garbage collector has
       * not yet freed. Specifically, HeapAlloc increases as heap
       * objects are allocated and decreases as the heap is swept
       * and unreachable objects are freed. Sweeping occurs
       * incrementally between GC cycles, so these two processes
       * occur simultaneously, and as a result HeapAlloc tends to
       * change smoothly (in contrast with the sawtooth that is
       * typical of stop-the-world garbage collectors).
       * </pre>
       *
       * <code>uint64 heap_alloc = 8;</code>
       */
      public long getHeapAlloc() {
        return heapAlloc_;
      }
      /**
       * <pre>
       * HeapAlloc is bytes of allocated heap objects.
       * "Allocated" heap objects include all reachable objects, as
       * well as unreachable objects that the garbage collector has
       * not yet freed. Specifically, HeapAlloc increases as heap
       * objects are allocated and decreases as the heap is swept
       * and unreachable objects are freed. Sweeping occurs
       * incrementally between GC cycles, so these two processes
       * occur simultaneously, and as a result HeapAlloc tends to
       * change smoothly (in contrast with the sawtooth that is
       * typical of stop-the-world garbage collectors).
       * </pre>
       *
       * <code>uint64 heap_alloc = 8;</code>
       */
      public Builder setHeapAlloc(long value) {
        
        heapAlloc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapAlloc is bytes of allocated heap objects.
       * "Allocated" heap objects include all reachable objects, as
       * well as unreachable objects that the garbage collector has
       * not yet freed. Specifically, HeapAlloc increases as heap
       * objects are allocated and decreases as the heap is swept
       * and unreachable objects are freed. Sweeping occurs
       * incrementally between GC cycles, so these two processes
       * occur simultaneously, and as a result HeapAlloc tends to
       * change smoothly (in contrast with the sawtooth that is
       * typical of stop-the-world garbage collectors).
       * </pre>
       *
       * <code>uint64 heap_alloc = 8;</code>
       */
      public Builder clearHeapAlloc() {
        
        heapAlloc_ = 0L;
        onChanged();
        return this;
      }

      private long heapSys_ ;
      /**
       * <pre>
       * HeapSys is bytes of heap memory obtained from the OS.
       * HeapSys measures the amount of virtual address space
       * reserved for the heap. This includes virtual address space
       * that has been reserved but not yet used, which consumes no
       * physical memory, but tends to be small, as well as virtual
       * address space for which the physical memory has been
       * returned to the OS after it became unused (see HeapReleased
       * for a measure of the latter).
       * HeapSys estimates the largest size the heap has had.
       * </pre>
       *
       * <code>uint64 heap_sys = 9;</code>
       */
      public long getHeapSys() {
        return heapSys_;
      }
      /**
       * <pre>
       * HeapSys is bytes of heap memory obtained from the OS.
       * HeapSys measures the amount of virtual address space
       * reserved for the heap. This includes virtual address space
       * that has been reserved but not yet used, which consumes no
       * physical memory, but tends to be small, as well as virtual
       * address space for which the physical memory has been
       * returned to the OS after it became unused (see HeapReleased
       * for a measure of the latter).
       * HeapSys estimates the largest size the heap has had.
       * </pre>
       *
       * <code>uint64 heap_sys = 9;</code>
       */
      public Builder setHeapSys(long value) {
        
        heapSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapSys is bytes of heap memory obtained from the OS.
       * HeapSys measures the amount of virtual address space
       * reserved for the heap. This includes virtual address space
       * that has been reserved but not yet used, which consumes no
       * physical memory, but tends to be small, as well as virtual
       * address space for which the physical memory has been
       * returned to the OS after it became unused (see HeapReleased
       * for a measure of the latter).
       * HeapSys estimates the largest size the heap has had.
       * </pre>
       *
       * <code>uint64 heap_sys = 9;</code>
       */
      public Builder clearHeapSys() {
        
        heapSys_ = 0L;
        onChanged();
        return this;
      }

      private long heapIdle_ ;
      /**
       * <pre>
       * HeapIdle is bytes in idle (unused) spans.
       * Idle spans have no objects in them. These spans could be
       * (and may already have been) returned to the OS, or they can
       * be reused for heap allocations, or they can be reused as
       * stack memory.
       * HeapIdle minus HeapReleased estimates the amount of memory
       * that could be returned to the OS, but is being retained by
       * the runtime so it can grow the heap without requesting more
       * memory from the OS. If this difference is significantly
       * larger than the heap size, it indicates there was a recent
       * transient spike in live heap size.
       * </pre>
       *
       * <code>uint64 heap_idle = 10;</code>
       */
      public long getHeapIdle() {
        return heapIdle_;
      }
      /**
       * <pre>
       * HeapIdle is bytes in idle (unused) spans.
       * Idle spans have no objects in them. These spans could be
       * (and may already have been) returned to the OS, or they can
       * be reused for heap allocations, or they can be reused as
       * stack memory.
       * HeapIdle minus HeapReleased estimates the amount of memory
       * that could be returned to the OS, but is being retained by
       * the runtime so it can grow the heap without requesting more
       * memory from the OS. If this difference is significantly
       * larger than the heap size, it indicates there was a recent
       * transient spike in live heap size.
       * </pre>
       *
       * <code>uint64 heap_idle = 10;</code>
       */
      public Builder setHeapIdle(long value) {
        
        heapIdle_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapIdle is bytes in idle (unused) spans.
       * Idle spans have no objects in them. These spans could be
       * (and may already have been) returned to the OS, or they can
       * be reused for heap allocations, or they can be reused as
       * stack memory.
       * HeapIdle minus HeapReleased estimates the amount of memory
       * that could be returned to the OS, but is being retained by
       * the runtime so it can grow the heap without requesting more
       * memory from the OS. If this difference is significantly
       * larger than the heap size, it indicates there was a recent
       * transient spike in live heap size.
       * </pre>
       *
       * <code>uint64 heap_idle = 10;</code>
       */
      public Builder clearHeapIdle() {
        
        heapIdle_ = 0L;
        onChanged();
        return this;
      }

      private long heapInuse_ ;
      /**
       * <pre>
       * HeapInuse is bytes in in-use spans.
       * In-use spans have at least one object in them. These spans
       * can only be used for other objects of roughly the same
       * size.
       * HeapInuse minus HeapAlloc esimates the amount of memory
       * that has been dedicated to particular size classes, but is
       * not currently being used. This is an upper bound on
       * fragmentation, but in general this memory can be reused
       * efficiently.
       * </pre>
       *
       * <code>uint64 heap_inuse = 11;</code>
       */
      public long getHeapInuse() {
        return heapInuse_;
      }
      /**
       * <pre>
       * HeapInuse is bytes in in-use spans.
       * In-use spans have at least one object in them. These spans
       * can only be used for other objects of roughly the same
       * size.
       * HeapInuse minus HeapAlloc esimates the amount of memory
       * that has been dedicated to particular size classes, but is
       * not currently being used. This is an upper bound on
       * fragmentation, but in general this memory can be reused
       * efficiently.
       * </pre>
       *
       * <code>uint64 heap_inuse = 11;</code>
       */
      public Builder setHeapInuse(long value) {
        
        heapInuse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapInuse is bytes in in-use spans.
       * In-use spans have at least one object in them. These spans
       * can only be used for other objects of roughly the same
       * size.
       * HeapInuse minus HeapAlloc esimates the amount of memory
       * that has been dedicated to particular size classes, but is
       * not currently being used. This is an upper bound on
       * fragmentation, but in general this memory can be reused
       * efficiently.
       * </pre>
       *
       * <code>uint64 heap_inuse = 11;</code>
       */
      public Builder clearHeapInuse() {
        
        heapInuse_ = 0L;
        onChanged();
        return this;
      }

      private long heapReleased_ ;
      /**
       * <pre>
       * HeapReleased is bytes of physical memory returned to the OS.
       * This counts heap memory from idle spans that was returned
       * to the OS and has not yet been reacquired for the heap.
       * </pre>
       *
       * <code>uint64 heap_released = 12;</code>
       */
      public long getHeapReleased() {
        return heapReleased_;
      }
      /**
       * <pre>
       * HeapReleased is bytes of physical memory returned to the OS.
       * This counts heap memory from idle spans that was returned
       * to the OS and has not yet been reacquired for the heap.
       * </pre>
       *
       * <code>uint64 heap_released = 12;</code>
       */
      public Builder setHeapReleased(long value) {
        
        heapReleased_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapReleased is bytes of physical memory returned to the OS.
       * This counts heap memory from idle spans that was returned
       * to the OS and has not yet been reacquired for the heap.
       * </pre>
       *
       * <code>uint64 heap_released = 12;</code>
       */
      public Builder clearHeapReleased() {
        
        heapReleased_ = 0L;
        onChanged();
        return this;
      }

      private long heapObjects_ ;
      /**
       * <pre>
       * HeapObjects is the number of allocated heap objects.
       * Like HeapAlloc, this increases as objects are allocated and
       * decreases as the heap is swept and unreachable objects are
       * freed.
       * </pre>
       *
       * <code>uint64 heap_objects = 13;</code>
       */
      public long getHeapObjects() {
        return heapObjects_;
      }
      /**
       * <pre>
       * HeapObjects is the number of allocated heap objects.
       * Like HeapAlloc, this increases as objects are allocated and
       * decreases as the heap is swept and unreachable objects are
       * freed.
       * </pre>
       *
       * <code>uint64 heap_objects = 13;</code>
       */
      public Builder setHeapObjects(long value) {
        
        heapObjects_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * HeapObjects is the number of allocated heap objects.
       * Like HeapAlloc, this increases as objects are allocated and
       * decreases as the heap is swept and unreachable objects are
       * freed.
       * </pre>
       *
       * <code>uint64 heap_objects = 13;</code>
       */
      public Builder clearHeapObjects() {
        
        heapObjects_ = 0L;
        onChanged();
        return this;
      }

      private long stackInuse_ ;
      /**
       * <pre>
       * StackInuse is bytes in stack spans.
       * In-use stack spans have at least one stack in them. These
       * spans can only be used for other stacks of the same size.
       * There is no StackIdle because unused stack spans are
       * returned to the heap (and hence counted toward HeapIdle).
       * </pre>
       *
       * <code>uint64 stack_inuse = 14;</code>
       */
      public long getStackInuse() {
        return stackInuse_;
      }
      /**
       * <pre>
       * StackInuse is bytes in stack spans.
       * In-use stack spans have at least one stack in them. These
       * spans can only be used for other stacks of the same size.
       * There is no StackIdle because unused stack spans are
       * returned to the heap (and hence counted toward HeapIdle).
       * </pre>
       *
       * <code>uint64 stack_inuse = 14;</code>
       */
      public Builder setStackInuse(long value) {
        
        stackInuse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * StackInuse is bytes in stack spans.
       * In-use stack spans have at least one stack in them. These
       * spans can only be used for other stacks of the same size.
       * There is no StackIdle because unused stack spans are
       * returned to the heap (and hence counted toward HeapIdle).
       * </pre>
       *
       * <code>uint64 stack_inuse = 14;</code>
       */
      public Builder clearStackInuse() {
        
        stackInuse_ = 0L;
        onChanged();
        return this;
      }

      private long stackSys_ ;
      /**
       * <pre>
       * StackSys is bytes of stack memory obtained from the OS.
       * StackSys is StackInuse, plus any memory obtained directly
       * from the OS for OS thread stacks (which should be minimal).
       * </pre>
       *
       * <code>uint64 stack_sys = 15;</code>
       */
      public long getStackSys() {
        return stackSys_;
      }
      /**
       * <pre>
       * StackSys is bytes of stack memory obtained from the OS.
       * StackSys is StackInuse, plus any memory obtained directly
       * from the OS for OS thread stacks (which should be minimal).
       * </pre>
       *
       * <code>uint64 stack_sys = 15;</code>
       */
      public Builder setStackSys(long value) {
        
        stackSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * StackSys is bytes of stack memory obtained from the OS.
       * StackSys is StackInuse, plus any memory obtained directly
       * from the OS for OS thread stacks (which should be minimal).
       * </pre>
       *
       * <code>uint64 stack_sys = 15;</code>
       */
      public Builder clearStackSys() {
        
        stackSys_ = 0L;
        onChanged();
        return this;
      }

      private long mSpanInuse_ ;
      /**
       * <pre>
       * MSpanInuse is bytes of allocated mspan structures.
       * </pre>
       *
       * <code>uint64 m_span_inuse = 16;</code>
       */
      public long getMSpanInuse() {
        return mSpanInuse_;
      }
      /**
       * <pre>
       * MSpanInuse is bytes of allocated mspan structures.
       * </pre>
       *
       * <code>uint64 m_span_inuse = 16;</code>
       */
      public Builder setMSpanInuse(long value) {
        
        mSpanInuse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MSpanInuse is bytes of allocated mspan structures.
       * </pre>
       *
       * <code>uint64 m_span_inuse = 16;</code>
       */
      public Builder clearMSpanInuse() {
        
        mSpanInuse_ = 0L;
        onChanged();
        return this;
      }

      private long mSpanSys_ ;
      /**
       * <pre>
       * MSpanSys is bytes of memory obtained from the OS for mspan
       * structures.
       * </pre>
       *
       * <code>uint64 m_span_sys = 17;</code>
       */
      public long getMSpanSys() {
        return mSpanSys_;
      }
      /**
       * <pre>
       * MSpanSys is bytes of memory obtained from the OS for mspan
       * structures.
       * </pre>
       *
       * <code>uint64 m_span_sys = 17;</code>
       */
      public Builder setMSpanSys(long value) {
        
        mSpanSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MSpanSys is bytes of memory obtained from the OS for mspan
       * structures.
       * </pre>
       *
       * <code>uint64 m_span_sys = 17;</code>
       */
      public Builder clearMSpanSys() {
        
        mSpanSys_ = 0L;
        onChanged();
        return this;
      }

      private long mCacheInuse_ ;
      /**
       * <pre>
       * MCacheInuse is bytes of allocated mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_inuse = 18;</code>
       */
      public long getMCacheInuse() {
        return mCacheInuse_;
      }
      /**
       * <pre>
       * MCacheInuse is bytes of allocated mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_inuse = 18;</code>
       */
      public Builder setMCacheInuse(long value) {
        
        mCacheInuse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MCacheInuse is bytes of allocated mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_inuse = 18;</code>
       */
      public Builder clearMCacheInuse() {
        
        mCacheInuse_ = 0L;
        onChanged();
        return this;
      }

      private long mCacheSys_ ;
      /**
       * <pre>
       * MCacheSys is bytes of memory obtained from the OS for
       * mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_sys = 19;</code>
       */
      public long getMCacheSys() {
        return mCacheSys_;
      }
      /**
       * <pre>
       * MCacheSys is bytes of memory obtained from the OS for
       * mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_sys = 19;</code>
       */
      public Builder setMCacheSys(long value) {
        
        mCacheSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * MCacheSys is bytes of memory obtained from the OS for
       * mcache structures.
       * </pre>
       *
       * <code>uint64 m_cache_sys = 19;</code>
       */
      public Builder clearMCacheSys() {
        
        mCacheSys_ = 0L;
        onChanged();
        return this;
      }

      private long buckHashSys_ ;
      /**
       * <pre>
       * BuckHashSys is bytes of memory in profiling bucket hash tables.
       * </pre>
       *
       * <code>uint64 buck_hash_sys = 20;</code>
       */
      public long getBuckHashSys() {
        return buckHashSys_;
      }
      /**
       * <pre>
       * BuckHashSys is bytes of memory in profiling bucket hash tables.
       * </pre>
       *
       * <code>uint64 buck_hash_sys = 20;</code>
       */
      public Builder setBuckHashSys(long value) {
        
        buckHashSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * BuckHashSys is bytes of memory in profiling bucket hash tables.
       * </pre>
       *
       * <code>uint64 buck_hash_sys = 20;</code>
       */
      public Builder clearBuckHashSys() {
        
        buckHashSys_ = 0L;
        onChanged();
        return this;
      }

      private long gcSys_ ;
      /**
       * <pre>
       * GCSys is bytes of memory in garbage collection metadata.
       * </pre>
       *
       * <code>uint64 gc_sys = 21;</code>
       */
      public long getGcSys() {
        return gcSys_;
      }
      /**
       * <pre>
       * GCSys is bytes of memory in garbage collection metadata.
       * </pre>
       *
       * <code>uint64 gc_sys = 21;</code>
       */
      public Builder setGcSys(long value) {
        
        gcSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * GCSys is bytes of memory in garbage collection metadata.
       * </pre>
       *
       * <code>uint64 gc_sys = 21;</code>
       */
      public Builder clearGcSys() {
        
        gcSys_ = 0L;
        onChanged();
        return this;
      }

      private long otherSys_ ;
      /**
       * <pre>
       * OtherSys is bytes of memory in miscellaneous off-heap
       * runtime allocations.
       * </pre>
       *
       * <code>uint64 other_sys = 22;</code>
       */
      public long getOtherSys() {
        return otherSys_;
      }
      /**
       * <pre>
       * OtherSys is bytes of memory in miscellaneous off-heap
       * runtime allocations.
       * </pre>
       *
       * <code>uint64 other_sys = 22;</code>
       */
      public Builder setOtherSys(long value) {
        
        otherSys_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * OtherSys is bytes of memory in miscellaneous off-heap
       * runtime allocations.
       * </pre>
       *
       * <code>uint64 other_sys = 22;</code>
       */
      public Builder clearOtherSys() {
        
        otherSys_ = 0L;
        onChanged();
        return this;
      }

      private long nextGc_ ;
      /**
       * <pre>
       * NextGC is the target heap size of the next GC cycle.
       * The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
       * At the end of each GC cycle, the target for the next cycle
       * is computed based on the amount of reachable data and the
       * value of GOGC.
       * </pre>
       *
       * <code>uint64 next_gc = 23;</code>
       */
      public long getNextGc() {
        return nextGc_;
      }
      /**
       * <pre>
       * NextGC is the target heap size of the next GC cycle.
       * The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
       * At the end of each GC cycle, the target for the next cycle
       * is computed based on the amount of reachable data and the
       * value of GOGC.
       * </pre>
       *
       * <code>uint64 next_gc = 23;</code>
       */
      public Builder setNextGc(long value) {
        
        nextGc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NextGC is the target heap size of the next GC cycle.
       * The garbage collector's goal is to keep HeapAlloc ≤ NextGC.
       * At the end of each GC cycle, the target for the next cycle
       * is computed based on the amount of reachable data and the
       * value of GOGC.
       * </pre>
       *
       * <code>uint64 next_gc = 23;</code>
       */
      public Builder clearNextGc() {
        
        nextGc_ = 0L;
        onChanged();
        return this;
      }

      private long lastGc_ ;
      /**
       * <pre>
       * LastGC is the time the last garbage collection finished, as
       * nanoseconds since 1970 (the UNIX epoch).
       * </pre>
       *
       * <code>uint64 last_gc = 24;</code>
       */
      public long getLastGc() {
        return lastGc_;
      }
      /**
       * <pre>
       * LastGC is the time the last garbage collection finished, as
       * nanoseconds since 1970 (the UNIX epoch).
       * </pre>
       *
       * <code>uint64 last_gc = 24;</code>
       */
      public Builder setLastGc(long value) {
        
        lastGc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * LastGC is the time the last garbage collection finished, as
       * nanoseconds since 1970 (the UNIX epoch).
       * </pre>
       *
       * <code>uint64 last_gc = 24;</code>
       */
      public Builder clearLastGc() {
        
        lastGc_ = 0L;
        onChanged();
        return this;
      }

      private long pauseTotalNs_ ;
      /**
       * <pre>
       * PauseTotalNs is the cumulative nanoseconds in GC
       * stop-the-world pauses since the program started.
       * During a stop-the-world pause, all goroutines are paused
       * and only the garbage collector can run.
       * </pre>
       *
       * <code>uint64 pause_total_ns = 25;</code>
       */
      public long getPauseTotalNs() {
        return pauseTotalNs_;
      }
      /**
       * <pre>
       * PauseTotalNs is the cumulative nanoseconds in GC
       * stop-the-world pauses since the program started.
       * During a stop-the-world pause, all goroutines are paused
       * and only the garbage collector can run.
       * </pre>
       *
       * <code>uint64 pause_total_ns = 25;</code>
       */
      public Builder setPauseTotalNs(long value) {
        
        pauseTotalNs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PauseTotalNs is the cumulative nanoseconds in GC
       * stop-the-world pauses since the program started.
       * During a stop-the-world pause, all goroutines are paused
       * and only the garbage collector can run.
       * </pre>
       *
       * <code>uint64 pause_total_ns = 25;</code>
       */
      public Builder clearPauseTotalNs() {
        
        pauseTotalNs_ = 0L;
        onChanged();
        return this;
      }

      private int numGc_ ;
      /**
       * <pre>
       * NumGC is the number of completed GC cycles.
       * </pre>
       *
       * <code>uint32 num_gc = 26;</code>
       */
      public int getNumGc() {
        return numGc_;
      }
      /**
       * <pre>
       * NumGC is the number of completed GC cycles.
       * </pre>
       *
       * <code>uint32 num_gc = 26;</code>
       */
      public Builder setNumGc(int value) {
        
        numGc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NumGC is the number of completed GC cycles.
       * </pre>
       *
       * <code>uint32 num_gc = 26;</code>
       */
      public Builder clearNumGc() {
        
        numGc_ = 0;
        onChanged();
        return this;
      }

      private int numForcedGc_ ;
      /**
       * <pre>
       * NumForcedGC is the number of GC cycles that were forced by
       * the application calling the GC function.
       * </pre>
       *
       * <code>uint32 num_forced_gc = 27;</code>
       */
      public int getNumForcedGc() {
        return numForcedGc_;
      }
      /**
       * <pre>
       * NumForcedGC is the number of GC cycles that were forced by
       * the application calling the GC function.
       * </pre>
       *
       * <code>uint32 num_forced_gc = 27;</code>
       */
      public Builder setNumForcedGc(int value) {
        
        numForcedGc_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * NumForcedGC is the number of GC cycles that were forced by
       * the application calling the GC function.
       * </pre>
       *
       * <code>uint32 num_forced_gc = 27;</code>
       */
      public Builder clearNumForcedGc() {
        
        numForcedGc_ = 0;
        onChanged();
        return this;
      }

      private double gcCpuFraction_ ;
      /**
       * <pre>
       * GCCPUFraction is the fraction of this program's available
       * CPU time used by the GC since the program started.
       * GCCPUFraction is expressed as a number between 0 and 1,
       * where 0 means GC has consumed none of this program's CPU. A
       * program's available CPU time is defined as the integral of
       * GOMAXPROCS since the program started. That is, if
       * GOMAXPROCS is 2 and a program has been running for 10
       * seconds, its "available CPU" is 20 seconds. GCCPUFraction
       * does not include CPU time used for write barrier activity.
       * This is the same as the fraction of CPU reported by
       * GODEBUG=gctrace=1.
       * </pre>
       *
       * <code>double gc_cpu_fraction = 28;</code>
       */
      public double getGcCpuFraction() {
        return gcCpuFraction_;
      }
      /**
       * <pre>
       * GCCPUFraction is the fraction of this program's available
       * CPU time used by the GC since the program started.
       * GCCPUFraction is expressed as a number between 0 and 1,
       * where 0 means GC has consumed none of this program's CPU. A
       * program's available CPU time is defined as the integral of
       * GOMAXPROCS since the program started. That is, if
       * GOMAXPROCS is 2 and a program has been running for 10
       * seconds, its "available CPU" is 20 seconds. GCCPUFraction
       * does not include CPU time used for write barrier activity.
       * This is the same as the fraction of CPU reported by
       * GODEBUG=gctrace=1.
       * </pre>
       *
       * <code>double gc_cpu_fraction = 28;</code>
       */
      public Builder setGcCpuFraction(double value) {
        
        gcCpuFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * GCCPUFraction is the fraction of this program's available
       * CPU time used by the GC since the program started.
       * GCCPUFraction is expressed as a number between 0 and 1,
       * where 0 means GC has consumed none of this program's CPU. A
       * program's available CPU time is defined as the integral of
       * GOMAXPROCS since the program started. That is, if
       * GOMAXPROCS is 2 and a program has been running for 10
       * seconds, its "available CPU" is 20 seconds. GCCPUFraction
       * does not include CPU time used for write barrier activity.
       * This is the same as the fraction of CPU reported by
       * GODEBUG=gctrace=1.
       * </pre>
       *
       * <code>double gc_cpu_fraction = 28;</code>
       */
      public Builder clearGcCpuFraction() {
        
        gcCpuFraction_ = 0D;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:logan.MemStats)
    }

    // @@protoc_insertion_point(class_scope:logan.MemStats)
    private static final logan.Logan.MemStats DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new logan.Logan.MemStats();
    }

    public static logan.Logan.MemStats getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MemStats>
        PARSER = new com.google.protobuf.AbstractParser<MemStats>() {
      public MemStats parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new MemStats(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<MemStats> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MemStats> getParserForType() {
      return PARSER;
    }

    public logan.Logan.MemStats getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_logan_Debug_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_logan_Debug_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_logan_KafkaInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_logan_KafkaInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_logan_Log_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_logan_Log_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_logan_MemStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_logan_MemStats_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n,bitbucket.org/subiz/header/logan/logan" +
      ".proto\022\005logan\032.bitbucket.org/subiz/heade" +
      "r/common/common.proto\"\233\001\n\005Debug\022\"\n\tmem_s" +
      "tats\030\002 \001(\0132\017.logan.MemStats\022\017\n\007num_cpu\030\003" +
      " \001(\005\022\025\n\rnum_goroutine\030\004 \001(\005\022\023\n\013stack_tra" +
      "ce\030\005 \001(\014\022\020\n\010hostname\030\006 \001(\t\022\037\n\005kafka\030\027 \001(" +
      "\0132\020.logan.KafkaInfo\"=\n\tKafkaInfo\022\r\n\005topi" +
      "c\030\002 \001(\t\022\021\n\tpartition\030\003 \001(\005\022\016\n\006offset\030\004 \001" +
      "(\003\"\221\001\n\003Log\022\034\n\003ctx\030\001 \001(\0132\017.common.Context" +
      "\022\020\n\010trace_id\030\002 \001(\t\022\017\n\007created\030\010 \001(\003\022\r\n\005l",
      "evel\030\n \001(\t\022\014\n\004tags\030\004 \003(\t\022\033\n\005debug\030\026 \001(\0132" +
      "\014.logan.Debug\022\017\n\007message\030\030 \001(\014\"\230\004\n\010MemSt" +
      "ats\022\r\n\005alloc\030\002 \001(\004\022\023\n\013total_alloc\030\003 \001(\004\022" +
      "\013\n\003sys\030\004 \001(\004\022\017\n\007lookups\030\005 \001(\004\022\017\n\007mallocs" +
      "\030\006 \001(\004\022\r\n\005frees\030\007 \001(\004\022\022\n\nheap_alloc\030\010 \001(" +
      "\004\022\020\n\010heap_sys\030\t \001(\004\022\021\n\theap_idle\030\n \001(\004\022\022" +
      "\n\nheap_inuse\030\013 \001(\004\022\025\n\rheap_released\030\014 \001(" +
      "\004\022\024\n\014heap_objects\030\r \001(\004\022\023\n\013stack_inuse\030\016" +
      " \001(\004\022\021\n\tstack_sys\030\017 \001(\004\022\024\n\014m_span_inuse\030" +
      "\020 \001(\004\022\022\n\nm_span_sys\030\021 \001(\004\022\025\n\rm_cache_inu",
      "se\030\022 \001(\004\022\023\n\013m_cache_sys\030\023 \001(\004\022\025\n\rbuck_ha" +
      "sh_sys\030\024 \001(\004\022\016\n\006gc_sys\030\025 \001(\004\022\021\n\tother_sy" +
      "s\030\026 \001(\004\022\017\n\007next_gc\030\027 \001(\004\022\017\n\007last_gc\030\030 \001(" +
      "\004\022\026\n\016pause_total_ns\030\031 \001(\004\022\016\n\006num_gc\030\032 \001(" +
      "\r\022\025\n\rnum_forced_gc\030\033 \001(\r\022\027\n\017gc_cpu_fract" +
      "ion\030\034 \001(\001*~\n\005Level\022\t\n\005debug\020\000\022\010\n\004info\020\001\022" +
      "\n\n\006notice\020\002\022\013\n\007warning\020\003\022\t\n\005error\020\004\022\014\n\010c" +
      "ritical\020\005\022\t\n\005alert\020\006\022\r\n\temergency\020\007\022\t\n\005p" +
      "anic\020\010\022\t\n\005fatal\020\t*?\n\005Event\022\023\n\017LogLogRequ" +
      "ested\020\000\022\021\n\014LogRequested\020\350\007\022\016\n\tLogSynced\020",
      "\351\007b\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          common.Common.getDescriptor(),
        }, assigner);
    internal_static_logan_Debug_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_logan_Debug_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_logan_Debug_descriptor,
        new java.lang.String[] { "MemStats", "NumCpu", "NumGoroutine", "StackTrace", "Hostname", "Kafka", });
    internal_static_logan_KafkaInfo_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_logan_KafkaInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_logan_KafkaInfo_descriptor,
        new java.lang.String[] { "Topic", "Partition", "Offset", });
    internal_static_logan_Log_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_logan_Log_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_logan_Log_descriptor,
        new java.lang.String[] { "Ctx", "TraceId", "Created", "Level", "Tags", "Debug", "Message", });
    internal_static_logan_MemStats_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_logan_MemStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_logan_MemStats_descriptor,
        new java.lang.String[] { "Alloc", "TotalAlloc", "Sys", "Lookups", "Mallocs", "Frees", "HeapAlloc", "HeapSys", "HeapIdle", "HeapInuse", "HeapReleased", "HeapObjects", "StackInuse", "StackSys", "MSpanInuse", "MSpanSys", "MCacheInuse", "MCacheSys", "BuckHashSys", "GcSys", "OtherSys", "NextGc", "LastGc", "PauseTotalNs", "NumGc", "NumForcedGc", "GcCpuFraction", });
    common.Common.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
